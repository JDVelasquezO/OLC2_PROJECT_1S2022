// Code generated from ProjectParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // ProjectParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

import "OLC2_Project1/server/interpreter/AST"
import "OLC2_Project1/server/interpreter/Abstract"
import "OLC2_Project1/server/interpreter/AST/Expression"
import "OLC2_Project1/server/interpreter/AST/Natives"
import "OLC2_Project1/server/interpreter/AST/Natives/BucleForIn"
import "OLC2_Project1/server/interpreter/SymbolTable"
import "OLC2_Project1/server/interpreter/SymbolTable/Environment"
import "OLC2_Project1/server/interpreter/AST/ExpressionSpecial"
import "OLC2_Project1/server/interpreter/AST/Natives/DecArrays"
import "OLC2_Project1/server/interpreter/AST/Natives/DecVectors"
import "OLC2_Project1/server/interpreter/AST/Natives/DecStructs"
import "OLC2_Project1/server/interpreter/AST/Natives/DecObjects"
import "OLC2_Project1/server/interpreter/AST/Natives/Module"
import "OLC2_Project1/server/interpreter/AST/Expression/Access"
import "OLC2_Project1/server/interpreter/AST/Expression/Objects"
import arrayList "github.com/colegno/arraylist"

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 79, 1173,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3,
	3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 160, 10, 4, 3, 4, 3,
	4, 3, 4, 3, 4, 7, 4, 166, 10, 4, 12, 4, 14, 4, 169, 11, 4, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 178, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	7, 5, 184, 10, 5, 12, 5, 14, 5, 187, 11, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 196, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 202, 10,
	6, 12, 6, 14, 6, 205, 11, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7,
	3, 7, 7, 7, 215, 10, 7, 12, 7, 14, 7, 218, 11, 7, 3, 8, 5, 8, 221, 10,
	8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 267, 10, 9, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 284, 10, 11, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 294, 10, 12, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 7,
	13, 309, 10, 13, 12, 13, 14, 13, 312, 11, 13, 3, 14, 7, 14, 315, 10, 14,
	12, 14, 14, 14, 318, 11, 14, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 5, 15, 339, 10, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 361, 10, 15, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 5, 16, 399, 10, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 7, 17, 410, 10, 17, 12, 17, 14, 17, 413, 11, 17, 3,
	18, 3, 18, 5, 18, 417, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 423,
	10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 429, 10, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 5, 18, 437, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	5, 18, 443, 10, 18, 3, 18, 3, 18, 5, 18, 447, 10, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 5, 18, 453, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 459,
	10, 18, 3, 18, 3, 18, 5, 18, 463, 10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 5,
	19, 469, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19,
	478, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5,
	19, 488, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 504, 10, 20, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 7, 21, 514, 10, 21, 12, 21,
	14, 21, 517, 11, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 525,
	10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5,
	23, 546, 10, 23, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 572, 10, 27, 12, 27, 14,
	27, 575, 11, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 591, 10, 29, 12, 29, 14,
	29, 594, 11, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 5, 30, 605, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3,
	32, 3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 630, 10, 33, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 5, 35, 647, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3,
	36, 3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 658, 10, 36, 12, 36, 14, 36, 661,
	11, 36, 3, 37, 3, 37, 5, 37, 665, 10, 37, 3, 37, 3, 37, 3, 37, 5, 37, 670,
	10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5,
	38, 691, 10, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 699,
	10, 39, 3, 40, 3, 40, 5, 40, 703, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 718,
	10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40,
	728, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 746, 10, 40,
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 5, 40, 760, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 774, 10, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 784, 10, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 796,
	10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42,
	3, 42, 5, 42, 808, 10, 42, 3, 42, 3, 42, 5, 42, 812, 10, 42, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 823, 10, 43,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 833, 10,
	44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	5, 46, 845, 10, 46, 3, 46, 3, 46, 5, 46, 849, 10, 46, 3, 47, 3, 47, 3,
	47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49,
	3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 7, 49, 869, 10, 49, 12, 49, 14, 49,
	872, 11, 49, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 878, 10, 50, 3, 50, 3,
	50, 3, 51, 3, 51, 5, 51, 884, 10, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3,
	52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52,
	3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 5, 52, 918, 10, 52, 3, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	5, 53, 932, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3,
	55, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 946, 10, 55, 12, 55, 14, 55, 949,
	11, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 7, 58, 968, 10,
	58, 12, 58, 14, 58, 971, 11, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 7, 61, 993, 10, 61, 12, 61, 14, 61, 996, 11,
	61, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 1002, 10, 62, 3, 62, 3, 62, 3, 63,
	3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3,
	64, 7, 64, 1018, 10, 64, 12, 64, 14, 64, 1021, 11, 64, 3, 65, 3, 65, 3,
	65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 7, 66,
	1035, 10, 66, 12, 66, 14, 66, 1038, 11, 66, 3, 67, 3, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1061, 10, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 1073,
	10, 67, 12, 67, 14, 67, 1076, 11, 67, 3, 68, 3, 68, 5, 68, 1080, 10, 68,
	3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 5, 68, 1096, 10, 68, 3, 69, 3, 69, 3, 69, 3, 69,
	3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1106, 10, 69, 3, 70, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 1116, 10, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 7, 70, 1123, 10, 70, 12, 70, 14, 70, 1126, 11, 70, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3,
	72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1147, 10, 72,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1158,
	10, 73, 3, 73, 3, 73, 5, 73, 1162, 10, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 5, 73, 1171, 10, 73, 3, 73, 2, 20, 6, 8, 10, 12, 24,
	32, 40, 52, 56, 70, 96, 108, 114, 120, 126, 130, 132, 138, 74, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 2, 7, 3, 2, 49, 50, 3, 2, 63, 68, 3, 2, 69, 71, 3, 2, 72, 73, 3, 2,
	74, 75, 2, 1225, 2, 146, 3, 2, 2, 2, 4, 149, 3, 2, 2, 2, 6, 159, 3, 2,
	2, 2, 8, 177, 3, 2, 2, 2, 10, 195, 3, 2, 2, 2, 12, 206, 3, 2, 2, 2, 14,
	220, 3, 2, 2, 2, 16, 266, 3, 2, 2, 2, 18, 268, 3, 2, 2, 2, 20, 283, 3,
	2, 2, 2, 22, 293, 3, 2, 2, 2, 24, 295, 3, 2, 2, 2, 26, 316, 3, 2, 2, 2,
	28, 360, 3, 2, 2, 2, 30, 398, 3, 2, 2, 2, 32, 400, 3, 2, 2, 2, 34, 462,
	3, 2, 2, 2, 36, 487, 3, 2, 2, 2, 38, 503, 3, 2, 2, 2, 40, 505, 3, 2, 2,
	2, 42, 524, 3, 2, 2, 2, 44, 545, 3, 2, 2, 2, 46, 547, 3, 2, 2, 2, 48, 550,
	3, 2, 2, 2, 50, 556, 3, 2, 2, 2, 52, 563, 3, 2, 2, 2, 54, 576, 3, 2, 2,
	2, 56, 581, 3, 2, 2, 2, 58, 604, 3, 2, 2, 2, 60, 606, 3, 2, 2, 2, 62, 611,
	3, 2, 2, 2, 64, 629, 3, 2, 2, 2, 66, 631, 3, 2, 2, 2, 68, 646, 3, 2, 2,
	2, 70, 648, 3, 2, 2, 2, 72, 662, 3, 2, 2, 2, 74, 690, 3, 2, 2, 2, 76, 698,
	3, 2, 2, 2, 78, 759, 3, 2, 2, 2, 80, 761, 3, 2, 2, 2, 82, 811, 3, 2, 2,
	2, 84, 822, 3, 2, 2, 2, 86, 832, 3, 2, 2, 2, 88, 834, 3, 2, 2, 2, 90, 848,
	3, 2, 2, 2, 92, 850, 3, 2, 2, 2, 94, 855, 3, 2, 2, 2, 96, 860, 3, 2, 2,
	2, 98, 873, 3, 2, 2, 2, 100, 881, 3, 2, 2, 2, 102, 917, 3, 2, 2, 2, 104,
	931, 3, 2, 2, 2, 106, 933, 3, 2, 2, 2, 108, 937, 3, 2, 2, 2, 110, 950,
	3, 2, 2, 2, 112, 955, 3, 2, 2, 2, 114, 959, 3, 2, 2, 2, 116, 972, 3, 2,
	2, 2, 118, 977, 3, 2, 2, 2, 120, 984, 3, 2, 2, 2, 122, 997, 3, 2, 2, 2,
	124, 1005, 3, 2, 2, 2, 126, 1008, 3, 2, 2, 2, 128, 1022, 3, 2, 2, 2, 130,
	1025, 3, 2, 2, 2, 132, 1060, 3, 2, 2, 2, 134, 1095, 3, 2, 2, 2, 136, 1105,
	3, 2, 2, 2, 138, 1115, 3, 2, 2, 2, 140, 1127, 3, 2, 2, 2, 142, 1146, 3,
	2, 2, 2, 144, 1170, 3, 2, 2, 2, 146, 147, 5, 4, 3, 2, 147, 148, 8, 2, 1,
	2, 148, 3, 3, 2, 2, 2, 149, 150, 5, 6, 4, 2, 150, 151, 8, 3, 1, 2, 151,
	5, 3, 2, 2, 2, 152, 153, 8, 4, 1, 2, 153, 154, 5, 8, 5, 2, 154, 155, 8,
	4, 1, 2, 155, 160, 3, 2, 2, 2, 156, 157, 5, 16, 9, 2, 157, 158, 8, 4, 1,
	2, 158, 160, 3, 2, 2, 2, 159, 152, 3, 2, 2, 2, 159, 156, 3, 2, 2, 2, 160,
	167, 3, 2, 2, 2, 161, 162, 12, 5, 2, 2, 162, 163, 5, 16, 9, 2, 163, 164,
	8, 4, 1, 2, 164, 166, 3, 2, 2, 2, 165, 161, 3, 2, 2, 2, 166, 169, 3, 2,
	2, 2, 167, 165, 3, 2, 2, 2, 167, 168, 3, 2, 2, 2, 168, 7, 3, 2, 2, 2, 169,
	167, 3, 2, 2, 2, 170, 171, 8, 5, 1, 2, 171, 172, 5, 10, 6, 2, 172, 173,
	8, 5, 1, 2, 173, 178, 3, 2, 2, 2, 174, 175, 5, 72, 37, 2, 175, 176, 8,
	5, 1, 2, 176, 178, 3, 2, 2, 2, 177, 170, 3, 2, 2, 2, 177, 174, 3, 2, 2,
	2, 178, 185, 3, 2, 2, 2, 179, 180, 12, 5, 2, 2, 180, 181, 5, 72, 37, 2,
	181, 182, 8, 5, 1, 2, 182, 184, 3, 2, 2, 2, 183, 179, 3, 2, 2, 2, 184,
	187, 3, 2, 2, 2, 185, 183, 3, 2, 2, 2, 185, 186, 3, 2, 2, 2, 186, 9, 3,
	2, 2, 2, 187, 185, 3, 2, 2, 2, 188, 189, 8, 6, 1, 2, 189, 190, 5, 12, 7,
	2, 190, 191, 8, 6, 1, 2, 191, 196, 3, 2, 2, 2, 192, 193, 5, 92, 47, 2,
	193, 194, 8, 6, 1, 2, 194, 196, 3, 2, 2, 2, 195, 188, 3, 2, 2, 2, 195,
	192, 3, 2, 2, 2, 196, 203, 3, 2, 2, 2, 197, 198, 12, 5, 2, 2, 198, 199,
	5, 92, 47, 2, 199, 200, 8, 6, 1, 2, 200, 202, 3, 2, 2, 2, 201, 197, 3,
	2, 2, 2, 202, 205, 3, 2, 2, 2, 203, 201, 3, 2, 2, 2, 203, 204, 3, 2, 2,
	2, 204, 11, 3, 2, 2, 2, 205, 203, 3, 2, 2, 2, 206, 207, 8, 7, 1, 2, 207,
	208, 5, 14, 8, 2, 208, 209, 8, 7, 1, 2, 209, 216, 3, 2, 2, 2, 210, 211,
	12, 4, 2, 2, 211, 212, 5, 14, 8, 2, 212, 213, 8, 7, 1, 2, 213, 215, 3,
	2, 2, 2, 214, 210, 3, 2, 2, 2, 215, 218, 3, 2, 2, 2, 216, 214, 3, 2, 2,
	2, 216, 217, 3, 2, 2, 2, 217, 13, 3, 2, 2, 2, 218, 216, 3, 2, 2, 2, 219,
	221, 7, 38, 2, 2, 220, 219, 3, 2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 222,
	3, 2, 2, 2, 222, 223, 7, 37, 2, 2, 223, 224, 7, 46, 2, 2, 224, 225, 7,
	59, 2, 2, 225, 226, 5, 6, 4, 2, 226, 227, 7, 60, 2, 2, 227, 228, 8, 8,
	1, 2, 228, 15, 3, 2, 2, 2, 229, 230, 5, 18, 10, 2, 230, 231, 8, 9, 1, 2,
	231, 267, 3, 2, 2, 2, 232, 233, 7, 29, 2, 2, 233, 234, 7, 46, 2, 2, 234,
	235, 7, 57, 2, 2, 235, 236, 7, 58, 2, 2, 236, 237, 5, 20, 11, 2, 237, 238,
	8, 9, 1, 2, 238, 267, 3, 2, 2, 2, 239, 240, 7, 29, 2, 2, 240, 241, 7, 46,
	2, 2, 241, 242, 7, 57, 2, 2, 242, 243, 7, 58, 2, 2, 243, 244, 7, 55, 2,
	2, 244, 245, 5, 142, 72, 2, 245, 246, 5, 20, 11, 2, 246, 247, 8, 9, 1,
	2, 247, 267, 3, 2, 2, 2, 248, 249, 7, 29, 2, 2, 249, 250, 7, 46, 2, 2,
	250, 251, 7, 57, 2, 2, 251, 252, 5, 24, 13, 2, 252, 253, 7, 58, 2, 2, 253,
	254, 5, 20, 11, 2, 254, 255, 8, 9, 1, 2, 255, 267, 3, 2, 2, 2, 256, 257,
	7, 29, 2, 2, 257, 258, 7, 46, 2, 2, 258, 259, 7, 57, 2, 2, 259, 260, 5,
	24, 13, 2, 260, 261, 7, 58, 2, 2, 261, 262, 7, 55, 2, 2, 262, 263, 5, 142,
	72, 2, 263, 264, 5, 20, 11, 2, 264, 265, 8, 9, 1, 2, 265, 267, 3, 2, 2,
	2, 266, 229, 3, 2, 2, 2, 266, 232, 3, 2, 2, 2, 266, 239, 3, 2, 2, 2, 266,
	248, 3, 2, 2, 2, 266, 256, 3, 2, 2, 2, 267, 17, 3, 2, 2, 2, 268, 269, 7,
	29, 2, 2, 269, 270, 7, 28, 2, 2, 270, 271, 7, 57, 2, 2, 271, 272, 7, 58,
	2, 2, 272, 273, 5, 20, 11, 2, 273, 274, 8, 10, 1, 2, 274, 19, 3, 2, 2,
	2, 275, 276, 7, 59, 2, 2, 276, 277, 5, 26, 14, 2, 277, 278, 7, 60, 2, 2,
	278, 279, 8, 11, 1, 2, 279, 284, 3, 2, 2, 2, 280, 281, 7, 59, 2, 2, 281,
	282, 7, 60, 2, 2, 282, 284, 8, 11, 1, 2, 283, 275, 3, 2, 2, 2, 283, 280,
	3, 2, 2, 2, 284, 21, 3, 2, 2, 2, 285, 286, 7, 59, 2, 2, 286, 287, 5, 26,
	14, 2, 287, 288, 7, 60, 2, 2, 288, 289, 8, 12, 1, 2, 289, 294, 3, 2, 2,
	2, 290, 291, 5, 26, 14, 2, 291, 292, 8, 12, 1, 2, 292, 294, 3, 2, 2, 2,
	293, 285, 3, 2, 2, 2, 293, 290, 3, 2, 2, 2, 294, 23, 3, 2, 2, 2, 295, 296,
	8, 13, 1, 2, 296, 297, 7, 46, 2, 2, 297, 298, 7, 51, 2, 2, 298, 299, 5,
	142, 72, 2, 299, 300, 8, 13, 1, 2, 300, 310, 3, 2, 2, 2, 301, 302, 12,
	4, 2, 2, 302, 303, 7, 50, 2, 2, 303, 304, 7, 46, 2, 2, 304, 305, 7, 51,
	2, 2, 305, 306, 5, 142, 72, 2, 306, 307, 8, 13, 1, 2, 307, 309, 3, 2, 2,
	2, 308, 301, 3, 2, 2, 2, 309, 312, 3, 2, 2, 2, 310, 308, 3, 2, 2, 2, 310,
	311, 3, 2, 2, 2, 311, 25, 3, 2, 2, 2, 312, 310, 3, 2, 2, 2, 313, 315, 5,
	28, 15, 2, 314, 313, 3, 2, 2, 2, 315, 318, 3, 2, 2, 2, 316, 314, 3, 2,
	2, 2, 316, 317, 3, 2, 2, 2, 317, 319, 3, 2, 2, 2, 318, 316, 3, 2, 2, 2,
	319, 320, 8, 14, 1, 2, 320, 27, 3, 2, 2, 2, 321, 322, 5, 30, 16, 2, 322,
	323, 8, 15, 1, 2, 323, 361, 3, 2, 2, 2, 324, 325, 5, 34, 18, 2, 325, 326,
	8, 15, 1, 2, 326, 361, 3, 2, 2, 2, 327, 328, 5, 36, 19, 2, 328, 329, 8,
	15, 1, 2, 329, 361, 3, 2, 2, 2, 330, 331, 5, 42, 22, 2, 331, 332, 8, 15,
	1, 2, 332, 361, 3, 2, 2, 2, 333, 334, 5, 58, 30, 2, 334, 335, 8, 15, 1,
	2, 335, 361, 3, 2, 2, 2, 336, 338, 5, 130, 66, 2, 337, 339, 7, 50, 2, 2,
	338, 337, 3, 2, 2, 2, 338, 339, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340,
	341, 8, 15, 1, 2, 341, 361, 3, 2, 2, 2, 342, 343, 5, 138, 70, 2, 343, 344,
	8, 15, 1, 2, 344, 361, 3, 2, 2, 2, 345, 346, 5, 72, 37, 2, 346, 347, 8,
	15, 1, 2, 347, 361, 3, 2, 2, 2, 348, 349, 5, 92, 47, 2, 349, 350, 8, 15,
	1, 2, 350, 361, 3, 2, 2, 2, 351, 352, 5, 100, 51, 2, 352, 353, 8, 15, 1,
	2, 353, 361, 3, 2, 2, 2, 354, 355, 5, 76, 39, 2, 355, 356, 8, 15, 1, 2,
	356, 361, 3, 2, 2, 2, 357, 358, 5, 84, 43, 2, 358, 359, 8, 15, 1, 2, 359,
	361, 3, 2, 2, 2, 360, 321, 3, 2, 2, 2, 360, 324, 3, 2, 2, 2, 360, 327,
	3, 2, 2, 2, 360, 330, 3, 2, 2, 2, 360, 333, 3, 2, 2, 2, 360, 336, 3, 2,
	2, 2, 360, 342, 3, 2, 2, 2, 360, 345, 3, 2, 2, 2, 360, 348, 3, 2, 2, 2,
	360, 351, 3, 2, 2, 2, 360, 354, 3, 2, 2, 2, 360, 357, 3, 2, 2, 2, 361,
	29, 3, 2, 2, 2, 362, 363, 7, 4, 2, 2, 363, 364, 7, 52, 2, 2, 364, 365,
	7, 57, 2, 2, 365, 366, 5, 102, 52, 2, 366, 367, 7, 58, 2, 2, 367, 368,
	9, 2, 2, 2, 368, 369, 8, 16, 1, 2, 369, 399, 3, 2, 2, 2, 370, 371, 7, 4,
	2, 2, 371, 372, 7, 52, 2, 2, 372, 373, 7, 57, 2, 2, 373, 374, 5, 102, 52,
	2, 374, 375, 7, 50, 2, 2, 375, 376, 5, 32, 17, 2, 376, 377, 7, 58, 2, 2,
	377, 378, 9, 2, 2, 2, 378, 379, 8, 16, 1, 2, 379, 399, 3, 2, 2, 2, 380,
	381, 7, 3, 2, 2, 381, 382, 7, 52, 2, 2, 382, 383, 7, 57, 2, 2, 383, 384,
	5, 102, 52, 2, 384, 385, 7, 58, 2, 2, 385, 386, 9, 2, 2, 2, 386, 387, 8,
	16, 1, 2, 387, 399, 3, 2, 2, 2, 388, 389, 7, 3, 2, 2, 389, 390, 7, 52,
	2, 2, 390, 391, 7, 57, 2, 2, 391, 392, 5, 102, 52, 2, 392, 393, 7, 50,
	2, 2, 393, 394, 5, 32, 17, 2, 394, 395, 7, 58, 2, 2, 395, 396, 9, 2, 2,
	2, 396, 397, 8, 16, 1, 2, 397, 399, 3, 2, 2, 2, 398, 362, 3, 2, 2, 2, 398,
	370, 3, 2, 2, 2, 398, 380, 3, 2, 2, 2, 398, 388, 3, 2, 2, 2, 399, 31, 3,
	2, 2, 2, 400, 401, 8, 17, 1, 2, 401, 402, 5, 102, 52, 2, 402, 403, 8, 17,
	1, 2, 403, 411, 3, 2, 2, 2, 404, 405, 12, 4, 2, 2, 405, 406, 7, 50, 2,
	2, 406, 407, 5, 102, 52, 2, 407, 408, 8, 17, 1, 2, 408, 410, 3, 2, 2, 2,
	409, 404, 3, 2, 2, 2, 410, 413, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 411,
	412, 3, 2, 2, 2, 412, 33, 3, 2, 2, 2, 413, 411, 3, 2, 2, 2, 414, 416, 7,
	5, 2, 2, 415, 417, 7, 6, 2, 2, 416, 415, 3, 2, 2, 2, 416, 417, 3, 2, 2,
	2, 417, 418, 3, 2, 2, 2, 418, 419, 5, 38, 20, 2, 419, 420, 7, 47, 2, 2,
	420, 422, 5, 102, 52, 2, 421, 423, 9, 2, 2, 2, 422, 421, 3, 2, 2, 2, 422,
	423, 3, 2, 2, 2, 423, 424, 3, 2, 2, 2, 424, 425, 8, 18, 1, 2, 425, 463,
	3, 2, 2, 2, 426, 428, 7, 5, 2, 2, 427, 429, 7, 6, 2, 2, 428, 427, 3, 2,
	2, 2, 428, 429, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 431, 5, 38, 20,
	2, 431, 432, 7, 51, 2, 2, 432, 433, 5, 142, 72, 2, 433, 434, 7, 47, 2,
	2, 434, 436, 5, 102, 52, 2, 435, 437, 9, 2, 2, 2, 436, 435, 3, 2, 2, 2,
	436, 437, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 439, 8, 18, 1, 2, 439,
	463, 3, 2, 2, 2, 440, 442, 7, 5, 2, 2, 441, 443, 7, 6, 2, 2, 442, 441,
	3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 446, 5, 38,
	20, 2, 445, 447, 9, 2, 2, 2, 446, 445, 3, 2, 2, 2, 446, 447, 3, 2, 2, 2,
	447, 448, 3, 2, 2, 2, 448, 449, 8, 18, 1, 2, 449, 463, 3, 2, 2, 2, 450,
	452, 7, 5, 2, 2, 451, 453, 7, 6, 2, 2, 452, 451, 3, 2, 2, 2, 452, 453,
	3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454, 455, 5, 38, 20, 2, 455, 456, 7,
	51, 2, 2, 456, 458, 5, 142, 72, 2, 457, 459, 9, 2, 2, 2, 458, 457, 3, 2,
	2, 2, 458, 459, 3, 2, 2, 2, 459, 460, 3, 2, 2, 2, 460, 461, 8, 18, 1, 2,
	461, 463, 3, 2, 2, 2, 462, 414, 3, 2, 2, 2, 462, 426, 3, 2, 2, 2, 462,
	440, 3, 2, 2, 2, 462, 450, 3, 2, 2, 2, 463, 35, 3, 2, 2, 2, 464, 465, 5,
	40, 21, 2, 465, 466, 7, 47, 2, 2, 466, 468, 5, 102, 52, 2, 467, 469, 9,
	2, 2, 2, 468, 467, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2, 469, 470, 3, 2, 2,
	2, 470, 471, 8, 19, 1, 2, 471, 488, 3, 2, 2, 2, 472, 473, 7, 46, 2, 2,
	473, 474, 5, 108, 55, 2, 474, 475, 7, 47, 2, 2, 475, 477, 5, 102, 52, 2,
	476, 478, 9, 2, 2, 2, 477, 476, 3, 2, 2, 2, 477, 478, 3, 2, 2, 2, 478,
	479, 3, 2, 2, 2, 479, 480, 8, 19, 1, 2, 480, 488, 3, 2, 2, 2, 481, 482,
	5, 124, 63, 2, 482, 483, 7, 47, 2, 2, 483, 484, 5, 102, 52, 2, 484, 485,
	7, 49, 2, 2, 485, 486, 8, 19, 1, 2, 486, 488, 3, 2, 2, 2, 487, 464, 3,
	2, 2, 2, 487, 472, 3, 2, 2, 2, 487, 481, 3, 2, 2, 2, 488, 37, 3, 2, 2,
	2, 489, 490, 5, 40, 21, 2, 490, 491, 8, 20, 1, 2, 491, 504, 3, 2, 2, 2,
	492, 493, 5, 40, 21, 2, 493, 494, 7, 51, 2, 2, 494, 495, 7, 7, 2, 2, 495,
	496, 8, 20, 1, 2, 496, 504, 3, 2, 2, 2, 497, 498, 5, 40, 21, 2, 498, 499,
	7, 51, 2, 2, 499, 500, 7, 53, 2, 2, 500, 501, 7, 12, 2, 2, 501, 502, 8,
	20, 1, 2, 502, 504, 3, 2, 2, 2, 503, 489, 3, 2, 2, 2, 503, 492, 3, 2, 2,
	2, 503, 497, 3, 2, 2, 2, 504, 39, 3, 2, 2, 2, 505, 506, 8, 21, 1, 2, 506,
	507, 7, 46, 2, 2, 507, 508, 8, 21, 1, 2, 508, 515, 3, 2, 2, 2, 509, 510,
	12, 4, 2, 2, 510, 511, 7, 50, 2, 2, 511, 512, 7, 46, 2, 2, 512, 514, 8,
	21, 1, 2, 513, 509, 3, 2, 2, 2, 514, 517, 3, 2, 2, 2, 515, 513, 3, 2, 2,
	2, 515, 516, 3, 2, 2, 2, 516, 41, 3, 2, 2, 2, 517, 515, 3, 2, 2, 2, 518,
	519, 5, 44, 23, 2, 519, 520, 8, 22, 1, 2, 520, 525, 3, 2, 2, 2, 521, 522,
	5, 50, 26, 2, 522, 523, 8, 22, 1, 2, 523, 525, 3, 2, 2, 2, 524, 518, 3,
	2, 2, 2, 524, 521, 3, 2, 2, 2, 525, 43, 3, 2, 2, 2, 526, 527, 7, 14, 2,
	2, 527, 528, 5, 102, 52, 2, 528, 529, 5, 20, 11, 2, 529, 530, 8, 23, 1,
	2, 530, 546, 3, 2, 2, 2, 531, 532, 7, 14, 2, 2, 532, 533, 5, 102, 52, 2,
	533, 534, 5, 20, 11, 2, 534, 535, 7, 15, 2, 2, 535, 536, 5, 20, 11, 2,
	536, 537, 8, 23, 1, 2, 537, 546, 3, 2, 2, 2, 538, 539, 7, 14, 2, 2, 539,
	540, 5, 102, 52, 2, 540, 541, 5, 20, 11, 2, 541, 542, 7, 15, 2, 2, 542,
	543, 5, 46, 24, 2, 543, 544, 8, 23, 1, 2, 544, 546, 3, 2, 2, 2, 545, 526,
	3, 2, 2, 2, 545, 531, 3, 2, 2, 2, 545, 538, 3, 2, 2, 2, 546, 45, 3, 2,
	2, 2, 547, 548, 5, 44, 23, 2, 548, 549, 8, 24, 1, 2, 549, 47, 3, 2, 2,
	2, 550, 551, 7, 15, 2, 2, 551, 552, 7, 14, 2, 2, 552, 553, 5, 102, 52,
	2, 553, 554, 5, 20, 11, 2, 554, 555, 8, 25, 1, 2, 555, 49, 3, 2, 2, 2,
	556, 557, 7, 16, 2, 2, 557, 558, 5, 102, 52, 2, 558, 559, 7, 59, 2, 2,
	559, 560, 5, 52, 27, 2, 560, 561, 7, 60, 2, 2, 561, 562, 8, 26, 1, 2, 562,
	51, 3, 2, 2, 2, 563, 564, 8, 27, 1, 2, 564, 565, 5, 54, 28, 2, 565, 566,
	8, 27, 1, 2, 566, 573, 3, 2, 2, 2, 567, 568, 12, 4, 2, 2, 568, 569, 5,
	54, 28, 2, 569, 570, 8, 27, 1, 2, 570, 572, 3, 2, 2, 2, 571, 567, 3, 2,
	2, 2, 572, 575, 3, 2, 2, 2, 573, 571, 3, 2, 2, 2, 573, 574, 3, 2, 2, 2,
	574, 53, 3, 2, 2, 2, 575, 573, 3, 2, 2, 2, 576, 577, 5, 56, 29, 2, 577,
	578, 7, 77, 2, 2, 578, 579, 5, 22, 12, 2, 579, 580, 8, 28, 1, 2, 580, 55,
	3, 2, 2, 2, 581, 582, 8, 29, 1, 2, 582, 583, 5, 102, 52, 2, 583, 584, 8,
	29, 1, 2, 584, 592, 3, 2, 2, 2, 585, 586, 12, 4, 2, 2, 586, 587, 7, 76,
	2, 2, 587, 588, 5, 102, 52, 2, 588, 589, 8, 29, 1, 2, 589, 591, 3, 2, 2,
	2, 590, 585, 3, 2, 2, 2, 591, 594, 3, 2, 2, 2, 592, 590, 3, 2, 2, 2, 592,
	593, 3, 2, 2, 2, 593, 57, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2, 595, 596, 5,
	60, 31, 2, 596, 597, 8, 30, 1, 2, 597, 605, 3, 2, 2, 2, 598, 599, 5, 62,
	32, 2, 599, 600, 8, 30, 1, 2, 600, 605, 3, 2, 2, 2, 601, 602, 5, 64, 33,
	2, 602, 603, 8, 30, 1, 2, 603, 605, 3, 2, 2, 2, 604, 595, 3, 2, 2, 2, 604,
	598, 3, 2, 2, 2, 604, 601, 3, 2, 2, 2, 605, 59, 3, 2, 2, 2, 606, 607, 7,
	17, 2, 2, 607, 608, 5, 102, 52, 2, 608, 609, 5, 20, 11, 2, 609, 610, 8,
	31, 1, 2, 610, 61, 3, 2, 2, 2, 611, 612, 7, 18, 2, 2, 612, 613, 5, 20,
	11, 2, 613, 614, 8, 32, 1, 2, 614, 63, 3, 2, 2, 2, 615, 616, 7, 19, 2,
	2, 616, 617, 5, 102, 52, 2, 617, 618, 7, 20, 2, 2, 618, 619, 5, 66, 34,
	2, 619, 620, 5, 20, 11, 2, 620, 621, 8, 33, 1, 2, 621, 630, 3, 2, 2, 2,
	622, 623, 7, 19, 2, 2, 623, 624, 5, 102, 52, 2, 624, 625, 7, 20, 2, 2,
	625, 626, 5, 104, 53, 2, 626, 627, 5, 20, 11, 2, 627, 628, 8, 33, 1, 2,
	628, 630, 3, 2, 2, 2, 629, 615, 3, 2, 2, 2, 629, 622, 3, 2, 2, 2, 630,
	65, 3, 2, 2, 2, 631, 632, 5, 102, 52, 2, 632, 633, 7, 56, 2, 2, 633, 634,
	5, 102, 52, 2, 634, 635, 8, 34, 1, 2, 635, 67, 3, 2, 2, 2, 636, 637, 7,
	46, 2, 2, 637, 638, 7, 57, 2, 2, 638, 639, 7, 58, 2, 2, 639, 647, 8, 35,
	1, 2, 640, 641, 7, 46, 2, 2, 641, 642, 7, 57, 2, 2, 642, 643, 5, 70, 36,
	2, 643, 644, 7, 58, 2, 2, 644, 645, 8, 35, 1, 2, 645, 647, 3, 2, 2, 2,
	646, 636, 3, 2, 2, 2, 646, 640, 3, 2, 2, 2, 647, 69, 3, 2, 2, 2, 648, 649,
	8, 36, 1, 2, 649, 650, 5, 102, 52, 2, 650, 651, 8, 36, 1, 2, 651, 659,
	3, 2, 2, 2, 652, 653, 12, 4, 2, 2, 653, 654, 7, 50, 2, 2, 654, 655, 5,
	102, 52, 2, 655, 656, 8, 36, 1, 2, 656, 658, 3, 2, 2, 2, 657, 652, 3, 2,
	2, 2, 658, 661, 3, 2, 2, 2, 659, 657, 3, 2, 2, 2, 659, 660, 3, 2, 2, 2,
	660, 71, 3, 2, 2, 2, 661, 659, 3, 2, 2, 2, 662, 664, 7, 5, 2, 2, 663, 665,
	7, 6, 2, 2, 664, 663, 3, 2, 2, 2, 664, 665, 3, 2, 2, 2, 665, 666, 3, 2,
	2, 2, 666, 669, 7, 46, 2, 2, 667, 668, 7, 51, 2, 2, 668, 670, 5, 74, 38,
	2, 669, 667, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671,
	672, 7, 47, 2, 2, 672, 673, 5, 102, 52, 2, 673, 674, 9, 2, 2, 2, 674, 675,
	8, 37, 1, 2, 675, 73, 3, 2, 2, 2, 676, 677, 7, 61, 2, 2, 677, 678, 5, 74,
	38, 2, 678, 679, 7, 49, 2, 2, 679, 680, 5, 102, 52, 2, 680, 681, 7, 62,
	2, 2, 681, 682, 8, 38, 1, 2, 682, 691, 3, 2, 2, 2, 683, 684, 7, 61, 2,
	2, 684, 685, 5, 142, 72, 2, 685, 686, 7, 49, 2, 2, 686, 687, 5, 102, 52,
	2, 687, 688, 7, 62, 2, 2, 688, 689, 8, 38, 1, 2, 689, 691, 3, 2, 2, 2,
	690, 676, 3, 2, 2, 2, 690, 683, 3, 2, 2, 2, 691, 75, 3, 2, 2, 2, 692, 693,
	5, 78, 40, 2, 693, 694, 8, 39, 1, 2, 694, 699, 3, 2, 2, 2, 695, 696, 5,
	82, 42, 2, 696, 697, 8, 39, 1, 2, 697, 699, 3, 2, 2, 2, 698, 692, 3, 2,
	2, 2, 698, 695, 3, 2, 2, 2, 699, 77, 3, 2, 2, 2, 700, 702, 7, 5, 2, 2,
	701, 703, 7, 6, 2, 2, 702, 701, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703,
	704, 3, 2, 2, 2, 704, 705, 7, 46, 2, 2, 705, 706, 7, 51, 2, 2, 706, 707,
	7, 32, 2, 2, 707, 708, 7, 66, 2, 2, 708, 709, 5, 142, 72, 2, 709, 710,
	7, 65, 2, 2, 710, 711, 7, 47, 2, 2, 711, 712, 7, 34, 2, 2, 712, 713, 7,
	49, 2, 2, 713, 714, 8, 40, 1, 2, 714, 760, 3, 2, 2, 2, 715, 717, 7, 5,
	2, 2, 716, 718, 7, 6, 2, 2, 717, 716, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2,
	718, 719, 3, 2, 2, 2, 719, 720, 7, 46, 2, 2, 720, 721, 7, 47, 2, 2, 721,
	722, 5, 80, 41, 2, 722, 723, 9, 2, 2, 2, 723, 724, 8, 40, 1, 2, 724, 760,
	3, 2, 2, 2, 725, 727, 7, 5, 2, 2, 726, 728, 7, 6, 2, 2, 727, 726, 3, 2,
	2, 2, 727, 728, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729, 730, 7, 46, 2, 2,
	730, 731, 7, 51, 2, 2, 731, 732, 7, 32, 2, 2, 732, 733, 7, 66, 2, 2, 733,
	734, 5, 142, 72, 2, 734, 735, 7, 65, 2, 2, 735, 736, 7, 47, 2, 2, 736,
	737, 7, 35, 2, 2, 737, 738, 7, 57, 2, 2, 738, 739, 5, 102, 52, 2, 739,
	740, 7, 58, 2, 2, 740, 741, 7, 49, 2, 2, 741, 742, 8, 40, 1, 2, 742, 760,
	3, 2, 2, 2, 743, 745, 7, 5, 2, 2, 744, 746, 7, 6, 2, 2, 745, 744, 3, 2,
	2, 2, 745, 746, 3, 2, 2, 2, 746, 747, 3, 2, 2, 2, 747, 748, 7, 46, 2, 2,
	748, 749, 7, 47, 2, 2, 749, 750, 7, 31, 2, 2, 750, 751, 7, 52, 2, 2, 751,
	752, 7, 61, 2, 2, 752, 753, 5, 102, 52, 2, 753, 754, 7, 49, 2, 2, 754,
	755, 5, 102, 52, 2, 755, 756, 7, 62, 2, 2, 756, 757, 7, 49, 2, 2, 757,
	758, 8, 40, 1, 2, 758, 760, 3, 2, 2, 2, 759, 700, 3, 2, 2, 2, 759, 715,
	3, 2, 2, 2, 759, 725, 3, 2, 2, 2, 759, 743, 3, 2, 2, 2, 760, 79, 3, 2,
	2, 2, 761, 762, 7, 31, 2, 2, 762, 763, 7, 52, 2, 2, 763, 764, 5, 102, 52,
	2, 764, 765, 8, 41, 1, 2, 765, 81, 3, 2, 2, 2, 766, 767, 7, 46, 2, 2, 767,
	768, 7, 48, 2, 2, 768, 769, 7, 46, 2, 2, 769, 770, 7, 57, 2, 2, 770, 771,
	5, 102, 52, 2, 771, 773, 7, 58, 2, 2, 772, 774, 7, 49, 2, 2, 773, 772,
	3, 2, 2, 2, 773, 774, 3, 2, 2, 2, 774, 775, 3, 2, 2, 2, 775, 776, 8, 42,
	1, 2, 776, 812, 3, 2, 2, 2, 777, 778, 7, 46, 2, 2, 778, 779, 7, 48, 2,
	2, 779, 780, 7, 46, 2, 2, 780, 781, 7, 57, 2, 2, 781, 783, 7, 58, 2, 2,
	782, 784, 7, 49, 2, 2, 783, 782, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784,
	785, 3, 2, 2, 2, 785, 812, 8, 42, 1, 2, 786, 787, 7, 46, 2, 2, 787, 788,
	7, 48, 2, 2, 788, 789, 7, 46, 2, 2, 789, 790, 7, 57, 2, 2, 790, 791, 5,
	102, 52, 2, 791, 792, 7, 50, 2, 2, 792, 793, 5, 102, 52, 2, 793, 795, 7,
	58, 2, 2, 794, 796, 7, 49, 2, 2, 795, 794, 3, 2, 2, 2, 795, 796, 3, 2,
	2, 2, 796, 797, 3, 2, 2, 2, 797, 798, 8, 42, 1, 2, 798, 812, 3, 2, 2, 2,
	799, 800, 7, 46, 2, 2, 800, 801, 7, 48, 2, 2, 801, 802, 7, 46, 2, 2, 802,
	803, 7, 57, 2, 2, 803, 804, 7, 53, 2, 2, 804, 805, 5, 102, 52, 2, 805,
	807, 7, 58, 2, 2, 806, 808, 7, 49, 2, 2, 807, 806, 3, 2, 2, 2, 807, 808,
	3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 809, 810, 8, 42, 1, 2, 810, 812, 3, 2,
	2, 2, 811, 766, 3, 2, 2, 2, 811, 777, 3, 2, 2, 2, 811, 786, 3, 2, 2, 2,
	811, 799, 3, 2, 2, 2, 812, 83, 3, 2, 2, 2, 813, 814, 5, 86, 44, 2, 814,
	815, 8, 43, 1, 2, 815, 823, 3, 2, 2, 2, 816, 817, 5, 88, 45, 2, 817, 818,
	8, 43, 1, 2, 818, 823, 3, 2, 2, 2, 819, 820, 5, 90, 46, 2, 820, 821, 8,
	43, 1, 2, 821, 823, 3, 2, 2, 2, 822, 813, 3, 2, 2, 2, 822, 816, 3, 2, 2,
	2, 822, 819, 3, 2, 2, 2, 823, 85, 3, 2, 2, 2, 824, 825, 7, 21, 2, 2, 825,
	826, 7, 49, 2, 2, 826, 833, 8, 44, 1, 2, 827, 828, 7, 21, 2, 2, 828, 829,
	5, 102, 52, 2, 829, 830, 7, 49, 2, 2, 830, 831, 8, 44, 1, 2, 831, 833,
	3, 2, 2, 2, 832, 824, 3, 2, 2, 2, 832, 827, 3, 2, 2, 2, 833, 87, 3, 2,
	2, 2, 834, 835, 7, 22, 2, 2, 835, 836, 7, 49, 2, 2, 836, 837, 8, 45, 1,
	2, 837, 89, 3, 2, 2, 2, 838, 839, 7, 23, 2, 2, 839, 840, 7, 49, 2, 2, 840,
	849, 8, 46, 1, 2, 841, 842, 7, 23, 2, 2, 842, 844, 5, 102, 52, 2, 843,
	845, 7, 49, 2, 2, 844, 843, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 846,
	3, 2, 2, 2, 846, 847, 8, 46, 1, 2, 847, 849, 3, 2, 2, 2, 848, 838, 3, 2,
	2, 2, 848, 841, 3, 2, 2, 2, 849, 91, 3, 2, 2, 2, 850, 851, 7, 36, 2, 2,
	851, 852, 7, 46, 2, 2, 852, 853, 5, 94, 48, 2, 853, 854, 8, 47, 1, 2, 854,
	93, 3, 2, 2, 2, 855, 856, 7, 59, 2, 2, 856, 857, 5, 96, 49, 2, 857, 858,
	7, 60, 2, 2, 858, 859, 8, 48, 1, 2, 859, 95, 3, 2, 2, 2, 860, 861, 8, 49,
	1, 2, 861, 862, 5, 98, 50, 2, 862, 863, 8, 49, 1, 2, 863, 870, 3, 2, 2,
	2, 864, 865, 12, 4, 2, 2, 865, 866, 5, 98, 50, 2, 866, 867, 8, 49, 1, 2,
	867, 869, 3, 2, 2, 2, 868, 864, 3, 2, 2, 2, 869, 872, 3, 2, 2, 2, 870,
	868, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2, 871, 97, 3, 2, 2, 2, 872, 870, 3,
	2, 2, 2, 873, 874, 7, 46, 2, 2, 874, 875, 7, 51, 2, 2, 875, 877, 5, 142,
	72, 2, 876, 878, 7, 50, 2, 2, 877, 876, 3, 2, 2, 2, 877, 878, 3, 2, 2,
	2, 878, 879, 3, 2, 2, 2, 879, 880, 8, 50, 1, 2, 880, 99, 3, 2, 2, 2, 881,
	883, 7, 5, 2, 2, 882, 884, 7, 6, 2, 2, 883, 882, 3, 2, 2, 2, 883, 884,
	3, 2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 886, 7, 46, 2, 2, 886, 887, 7, 47,
	2, 2, 887, 888, 7, 46, 2, 2, 888, 889, 7, 59, 2, 2, 889, 890, 5, 120, 61,
	2, 890, 891, 7, 60, 2, 2, 891, 892, 8, 51, 1, 2, 892, 101, 3, 2, 2, 2,
	893, 894, 5, 42, 22, 2, 894, 895, 8, 52, 1, 2, 895, 918, 3, 2, 2, 2, 896,
	897, 5, 62, 32, 2, 897, 898, 8, 52, 1, 2, 898, 918, 3, 2, 2, 2, 899, 900,
	5, 138, 70, 2, 900, 901, 8, 52, 1, 2, 901, 918, 3, 2, 2, 2, 902, 903, 5,
	130, 66, 2, 903, 904, 8, 52, 1, 2, 904, 918, 3, 2, 2, 2, 905, 906, 5, 104,
	53, 2, 906, 907, 8, 52, 1, 2, 907, 918, 3, 2, 2, 2, 908, 909, 5, 82, 42,
	2, 909, 910, 8, 52, 1, 2, 910, 918, 3, 2, 2, 2, 911, 912, 5, 118, 60, 2,
	912, 913, 8, 52, 1, 2, 913, 918, 3, 2, 2, 2, 914, 915, 5, 124, 63, 2, 915,
	916, 8, 52, 1, 2, 916, 918, 3, 2, 2, 2, 917, 893, 3, 2, 2, 2, 917, 896,
	3, 2, 2, 2, 917, 899, 3, 2, 2, 2, 917, 902, 3, 2, 2, 2, 917, 905, 3, 2,
	2, 2, 917, 908, 3, 2, 2, 2, 917, 911, 3, 2, 2, 2, 917, 914, 3, 2, 2, 2,
	918, 103, 3, 2, 2, 2, 919, 920, 7, 61, 2, 2, 920, 921, 5, 70, 36, 2, 921,
	922, 7, 62, 2, 2, 922, 923, 8, 53, 1, 2, 923, 932, 3, 2, 2, 2, 924, 925,
	7, 61, 2, 2, 925, 926, 5, 102, 52, 2, 926, 927, 7, 49, 2, 2, 927, 928,
	5, 102, 52, 2, 928, 929, 7, 62, 2, 2, 929, 930, 8, 53, 1, 2, 930, 932,
	3, 2, 2, 2, 931, 919, 3, 2, 2, 2, 931, 924, 3, 2, 2, 2, 932, 105, 3, 2,
	2, 2, 933, 934, 7, 46, 2, 2, 934, 935, 5, 108, 55, 2, 935, 936, 8, 54,
	1, 2, 936, 107, 3, 2, 2, 2, 937, 938, 8, 55, 1, 2, 938, 939, 5, 110, 56,
	2, 939, 940, 8, 55, 1, 2, 940, 947, 3, 2, 2, 2, 941, 942, 12, 4, 2, 2,
	942, 943, 5, 110, 56, 2, 943, 944, 8, 55, 1, 2, 944, 946, 3, 2, 2, 2, 945,
	941, 3, 2, 2, 2, 946, 949, 3, 2, 2, 2, 947, 945, 3, 2, 2, 2, 947, 948,
	3, 2, 2, 2, 948, 109, 3, 2, 2, 2, 949, 947, 3, 2, 2, 2, 950, 951, 7, 61,
	2, 2, 951, 952, 5, 102, 52, 2, 952, 953, 7, 62, 2, 2, 953, 954, 8, 56,
	1, 2, 954, 111, 3, 2, 2, 2, 955, 956, 7, 46, 2, 2, 956, 957, 5, 114, 58,
	2, 957, 958, 8, 57, 1, 2, 958, 113, 3, 2, 2, 2, 959, 960, 8, 58, 1, 2,
	960, 961, 5, 116, 59, 2, 961, 962, 8, 58, 1, 2, 962, 969, 3, 2, 2, 2, 963,
	964, 12, 4, 2, 2, 964, 965, 5, 116, 59, 2, 965, 966, 8, 58, 1, 2, 966,
	968, 3, 2, 2, 2, 967, 963, 3, 2, 2, 2, 968, 971, 3, 2, 2, 2, 969, 967,
	3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970, 115, 3, 2, 2, 2, 971, 969, 3, 2,
	2, 2, 972, 973, 7, 61, 2, 2, 973, 974, 5, 102, 52, 2, 974, 975, 7, 62,
	2, 2, 975, 976, 8, 59, 1, 2, 976, 117, 3, 2, 2, 2, 977, 978, 7, 46, 2,
	2, 978, 979, 7, 59, 2, 2, 979, 980, 5, 120, 61, 2, 980, 981, 7, 60, 2,
	2, 981, 982, 7, 49, 2, 2, 982, 983, 8, 60, 1, 2, 983, 119, 3, 2, 2, 2,
	984, 985, 8, 61, 1, 2, 985, 986, 5, 122, 62, 2, 986, 987, 8, 61, 1, 2,
	987, 994, 3, 2, 2, 2, 988, 989, 12, 4, 2, 2, 989, 990, 5, 122, 62, 2, 990,
	991, 8, 61, 1, 2, 991, 993, 3, 2, 2, 2, 992, 988, 3, 2, 2, 2, 993, 996,
	3, 2, 2, 2, 994, 992, 3, 2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 121, 3, 2,
	2, 2, 996, 994, 3, 2, 2, 2, 997, 998, 7, 46, 2, 2, 998, 999, 7, 51, 2,
	2, 999, 1001, 5, 102, 52, 2, 1000, 1002, 7, 50, 2, 2, 1001, 1000, 3, 2,
	2, 2, 1001, 1002, 3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1004, 8, 62,
	1, 2, 1004, 123, 3, 2, 2, 2, 1005, 1006, 5, 126, 64, 2, 1006, 1007, 8,
	63, 1, 2, 1007, 125, 3, 2, 2, 2, 1008, 1009, 8, 64, 1, 2, 1009, 1010, 5,
	128, 65, 2, 1010, 1011, 8, 64, 1, 2, 1011, 1019, 3, 2, 2, 2, 1012, 1013,
	12, 4, 2, 2, 1013, 1014, 7, 48, 2, 2, 1014, 1015, 5, 128, 65, 2, 1015,
	1016, 8, 64, 1, 2, 1016, 1018, 3, 2, 2, 2, 1017, 1012, 3, 2, 2, 2, 1018,
	1021, 3, 2, 2, 2, 1019, 1017, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020,
	127, 3, 2, 2, 2, 1021, 1019, 3, 2, 2, 2, 1022, 1023, 7, 46, 2, 2, 1023,
	1024, 8, 65, 1, 2, 1024, 129, 3, 2, 2, 2, 1025, 1026, 8, 66, 1, 2, 1026,
	1027, 5, 132, 67, 2, 1027, 1028, 8, 66, 1, 2, 1028, 1036, 3, 2, 2, 2, 1029,
	1030, 12, 4, 2, 2, 1030, 1031, 9, 3, 2, 2, 1031, 1032, 5, 130, 66, 5, 1032,
	1033, 8, 66, 1, 2, 1033, 1035, 3, 2, 2, 2, 1034, 1029, 3, 2, 2, 2, 1035,
	1038, 3, 2, 2, 2, 1036, 1034, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037,
	131, 3, 2, 2, 2, 1038, 1036, 3, 2, 2, 2, 1039, 1040, 8, 67, 1, 2, 1040,
	1041, 7, 73, 2, 2, 1041, 1042, 5, 102, 52, 2, 1042, 1043, 8, 67, 1, 2,
	1043, 1061, 3, 2, 2, 2, 1044, 1045, 5, 136, 69, 2, 1045, 1046, 7, 57, 2,
	2, 1046, 1047, 5, 132, 67, 2, 1047, 1048, 7, 50, 2, 2, 1048, 1049, 5, 132,
	67, 2, 1049, 1050, 7, 58, 2, 2, 1050, 1051, 8, 67, 1, 2, 1051, 1061, 3,
	2, 2, 2, 1052, 1053, 5, 134, 68, 2, 1053, 1054, 8, 67, 1, 2, 1054, 1061,
	3, 2, 2, 2, 1055, 1056, 7, 57, 2, 2, 1056, 1057, 5, 102, 52, 2, 1057, 1058,
	7, 58, 2, 2, 1058, 1059, 8, 67, 1, 2, 1059, 1061, 3, 2, 2, 2, 1060, 1039,
	3, 2, 2, 2, 1060, 1044, 3, 2, 2, 2, 1060, 1052, 3, 2, 2, 2, 1060, 1055,
	3, 2, 2, 2, 1061, 1074, 3, 2, 2, 2, 1062, 1063, 12, 6, 2, 2, 1063, 1064,
	9, 4, 2, 2, 1064, 1065, 5, 132, 67, 7, 1065, 1066, 8, 67, 1, 2, 1066, 1073,
	3, 2, 2, 2, 1067, 1068, 12, 5, 2, 2, 1068, 1069, 9, 5, 2, 2, 1069, 1070,
	5, 132, 67, 6, 1070, 1071, 8, 67, 1, 2, 1071, 1073, 3, 2, 2, 2, 1072, 1062,
	3, 2, 2, 2, 1072, 1067, 3, 2, 2, 2, 1073, 1076, 3, 2, 2, 2, 1074, 1072,
	3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 133, 3, 2, 2, 2, 1076, 1074,
	3, 2, 2, 2, 1077, 1079, 5, 68, 35, 2, 1078, 1080, 7, 49, 2, 2, 1079, 1078,
	3, 2, 2, 2, 1079, 1080, 3, 2, 2, 2, 1080, 1081, 3, 2, 2, 2, 1081, 1082,
	8, 68, 1, 2, 1082, 1096, 3, 2, 2, 2, 1083, 1084, 5, 144, 73, 2, 1084, 1085,
	8, 68, 1, 2, 1085, 1096, 3, 2, 2, 2, 1086, 1087, 5, 140, 71, 2, 1087, 1088,
	8, 68, 1, 2, 1088, 1096, 3, 2, 2, 2, 1089, 1090, 5, 106, 54, 2, 1090, 1091,
	8, 68, 1, 2, 1091, 1096, 3, 2, 2, 2, 1092, 1093, 5, 112, 57, 2, 1093, 1094,
	8, 68, 1, 2, 1094, 1096, 3, 2, 2, 2, 1095, 1077, 3, 2, 2, 2, 1095, 1083,
	3, 2, 2, 2, 1095, 1086, 3, 2, 2, 2, 1095, 1089, 3, 2, 2, 2, 1095, 1092,
	3, 2, 2, 2, 1096, 135, 3, 2, 2, 2, 1097, 1098, 7, 8, 2, 2, 1098, 1099,
	7, 54, 2, 2, 1099, 1100, 7, 24, 2, 2, 1100, 1106, 8, 69, 1, 2, 1101, 1102,
	7, 9, 2, 2, 1102, 1103, 7, 54, 2, 2, 1103, 1104, 7, 25, 2, 2, 1104, 1106,
	8, 69, 1, 2, 1105, 1097, 3, 2, 2, 2, 1105, 1101, 3, 2, 2, 2, 1106, 137,
	3, 2, 2, 2, 1107, 1108, 8, 70, 1, 2, 1108, 1109, 7, 52, 2, 2, 1109, 1110,
	5, 102, 52, 2, 1110, 1111, 8, 70, 1, 2, 1111, 1116, 3, 2, 2, 2, 1112, 1113,
	5, 130, 66, 2, 1113, 1114, 8, 70, 1, 2, 1114, 1116, 3, 2, 2, 2, 1115, 1107,
	3, 2, 2, 2, 1115, 1112, 3, 2, 2, 2, 1116, 1124, 3, 2, 2, 2, 1117, 1118,
	12, 4, 2, 2, 1118, 1119, 9, 6, 2, 2, 1119, 1120, 5, 138, 70, 5, 1120, 1121,
	8, 70, 1, 2, 1121, 1123, 3, 2, 2, 2, 1122, 1117, 3, 2, 2, 2, 1123, 1126,
	3, 2, 2, 2, 1124, 1122, 3, 2, 2, 2, 1124, 1125, 3, 2, 2, 2, 1125, 139,
	3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1127, 1128, 7, 57, 2, 2, 1128, 1129,
	5, 102, 52, 2, 1129, 1130, 7, 13, 2, 2, 1130, 1131, 5, 142, 72, 2, 1131,
	1132, 7, 58, 2, 2, 1132, 1133, 8, 71, 1, 2, 1133, 141, 3, 2, 2, 2, 1134,
	1135, 7, 8, 2, 2, 1135, 1147, 8, 72, 1, 2, 1136, 1137, 7, 9, 2, 2, 1137,
	1147, 8, 72, 1, 2, 1138, 1139, 7, 12, 2, 2, 1139, 1147, 8, 72, 1, 2, 1140,
	1141, 7, 7, 2, 2, 1141, 1147, 8, 72, 1, 2, 1142, 1143, 7, 10, 2, 2, 1143,
	1147, 8, 72, 1, 2, 1144, 1145, 7, 11, 2, 2, 1145, 1147, 8, 72, 1, 2, 1146,
	1134, 3, 2, 2, 2, 1146, 1136, 3, 2, 2, 2, 1146, 1138, 3, 2, 2, 2, 1146,
	1140, 3, 2, 2, 2, 1146, 1142, 3, 2, 2, 2, 1146, 1144, 3, 2, 2, 2, 1147,
	143, 3, 2, 2, 2, 1148, 1149, 7, 41, 2, 2, 1149, 1171, 8, 73, 1, 2, 1150,
	1151, 7, 42, 2, 2, 1151, 1171, 8, 73, 1, 2, 1152, 1161, 7, 44, 2, 2, 1153,
	1154, 7, 48, 2, 2, 1154, 1158, 7, 26, 2, 2, 1155, 1156, 7, 48, 2, 2, 1156,
	1158, 7, 27, 2, 2, 1157, 1153, 3, 2, 2, 2, 1157, 1155, 3, 2, 2, 2, 1158,
	1159, 3, 2, 2, 2, 1159, 1160, 7, 57, 2, 2, 1160, 1162, 7, 58, 2, 2, 1161,
	1157, 3, 2, 2, 2, 1161, 1162, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163,
	1171, 8, 73, 1, 2, 1164, 1165, 7, 43, 2, 2, 1165, 1171, 8, 73, 1, 2, 1166,
	1167, 7, 45, 2, 2, 1167, 1171, 8, 73, 1, 2, 1168, 1169, 7, 46, 2, 2, 1169,
	1171, 8, 73, 1, 2, 1170, 1148, 3, 2, 2, 2, 1170, 1150, 3, 2, 2, 2, 1170,
	1152, 3, 2, 2, 2, 1170, 1164, 3, 2, 2, 2, 1170, 1166, 3, 2, 2, 2, 1170,
	1168, 3, 2, 2, 2, 1171, 145, 3, 2, 2, 2, 82, 159, 167, 177, 185, 195, 203,
	216, 220, 266, 283, 293, 310, 316, 338, 360, 398, 411, 416, 422, 428, 436,
	442, 446, 452, 458, 462, 468, 477, 487, 503, 515, 524, 545, 573, 592, 604,
	629, 646, 659, 664, 669, 690, 698, 702, 717, 727, 745, 759, 773, 783, 795,
	807, 811, 822, 832, 844, 848, 870, 877, 883, 917, 931, 947, 969, 994, 1001,
	1019, 1036, 1060, 1072, 1074, 1079, 1095, 1105, 1115, 1124, 1146, 1157,
	1161, 1170,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'println'", "'print'", "'let'", "'mut'", "'String'", "'i64'", "'f64'",
	"'bool'", "'char'", "'&str'", "'as'", "'if'", "'else'", "'match'", "'while'",
	"'loop'", "'for'", "'in'", "'break'", "'continue'", "'return'", "'pow'",
	"'powf'", "'to_string'", "'to_owned'", "'main'", "'fn'", "'vector'", "'vec'",
	"'Vec'", "'new'", "'Vec::new()'", "'Vec::with_capacity'", "'struct'", "'mod'",
	"'pub'", "", "", "", "", "", "", "", "", "'='", "'.'", "';'", "','", "':'",
	"'!'", "'&'", "'::'", "'->'", "'..'", "'('", "')'", "'{'", "'}'", "'['",
	"']'", "'=='", "'!='", "'>'", "'<'", "'>='", "'<='", "'*'", "'/'", "'%'",
	"'+'", "'-'", "'&&'", "'||'", "'|'", "'=>'", "'_'",
}
var symbolicNames = []string{
	"", "PRINTLN", "PRINT", "DECLARAR", "MUT", "RSTRING", "RINTEGER", "RREAL",
	"RBOOLEAN", "RCHAR", "RSTR", "RAS", "RIF", "RELSE", "RMATCH", "RWHILE",
	"RLOOP", "RFOR", "RIN", "RBREAK", "RCONTINUE", "RRETURN", "POWI", "POWF",
	"TOSTRING", "TOOWNED", "RMAIN", "RFN", "RVECTOR", "RVEC", "RVECMayus",
	"RNEW", "REVECTORNEW", "REVECCAPACITY", "RSTRUCT", "RMODULE", "RPUB", "MULTILINE",
	"INLINE", "INTEGER", "FLOAT", "CHAR", "STRING", "BOOLEAN", "ID", "EQUAL",
	"DOT", "SEMICOLON", "COMMA", "COLON", "ADMIRATION", "REFERENCE", "HERITAGE",
	"ARROW", "RANGE", "LEFT_PAR", "RIGHT_PAR", "LEFT_KEY", "RIGHT_KEY", "LEFT_BRACKET",
	"RIGHT_BRACKET", "EQUEAL_EQUAL", "NOTEQUAL", "GREATER_THAN", "LESS_THAN",
	"GREATER_EQUALTHAN", "LESS_EQUEALTHAN", "MUL", "DIV", "MOD", "ADD", "SUB",
	"AND", "OR", "PIPE", "EQUAL_ARROW", "UNDERSCORE", "WHITESPACE",
}

var ruleNames = []string{
	"start", "listInits", "listFuncs", "listArrays", "listStructs", "modules",
	"module", "function", "funcMain", "bloq", "bloq_match", "listParams", "instructions",
	"instruction", "print_prod", "listVars", "declaration_prod", "assign_prod",
	"ids_type", "listIds", "conditional_prod", "if_prod", "list_else_if", "else_if",
	"match_prod", "list_instr_match", "instr_match", "expr_match", "bucle_prod",
	"while_prod", "loop_prod", "forin_prod", "range_prod", "called_func", "listExpressions",
	"dec_arr", "listDim", "vector_instr", "dec_vector", "expr_vector", "natives_vector",
	"transfer_prod", "break_instr", "continue_instr", "return_instr", "dec_struct",
	"bloq_struct", "content_struct", "item_struct", "dec_object", "expression",
	"arraydata", "access_array", "listInArray", "inArray", "access_vector",
	"listInVector", "inVector", "type_struct", "def_items", "item", "access_object",
	"listAccess", "access", "expr_rel", "expr_arit", "expr_valor", "pow_op",
	"expr_logic", "expr_cast", "data_type", "primitive",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ProjectParser struct {
	*antlr.BaseParser
}

func NewProjectParser(input antlr.TokenStream) *ProjectParser {
	this := new(ProjectParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ProjectParser.g4"

	return this
}

type BinaryOperation struct {
	Op1      int
	Operator string
	Op2      int
}

// ProjectParser tokens.
const (
	ProjectParserEOF               = antlr.TokenEOF
	ProjectParserPRINTLN           = 1
	ProjectParserPRINT             = 2
	ProjectParserDECLARAR          = 3
	ProjectParserMUT               = 4
	ProjectParserRSTRING           = 5
	ProjectParserRINTEGER          = 6
	ProjectParserRREAL             = 7
	ProjectParserRBOOLEAN          = 8
	ProjectParserRCHAR             = 9
	ProjectParserRSTR              = 10
	ProjectParserRAS               = 11
	ProjectParserRIF               = 12
	ProjectParserRELSE             = 13
	ProjectParserRMATCH            = 14
	ProjectParserRWHILE            = 15
	ProjectParserRLOOP             = 16
	ProjectParserRFOR              = 17
	ProjectParserRIN               = 18
	ProjectParserRBREAK            = 19
	ProjectParserRCONTINUE         = 20
	ProjectParserRRETURN           = 21
	ProjectParserPOWI              = 22
	ProjectParserPOWF              = 23
	ProjectParserTOSTRING          = 24
	ProjectParserTOOWNED           = 25
	ProjectParserRMAIN             = 26
	ProjectParserRFN               = 27
	ProjectParserRVECTOR           = 28
	ProjectParserRVEC              = 29
	ProjectParserRVECMayus         = 30
	ProjectParserRNEW              = 31
	ProjectParserREVECTORNEW       = 32
	ProjectParserREVECCAPACITY     = 33
	ProjectParserRSTRUCT           = 34
	ProjectParserRMODULE           = 35
	ProjectParserRPUB              = 36
	ProjectParserMULTILINE         = 37
	ProjectParserINLINE            = 38
	ProjectParserINTEGER           = 39
	ProjectParserFLOAT             = 40
	ProjectParserCHAR              = 41
	ProjectParserSTRING            = 42
	ProjectParserBOOLEAN           = 43
	ProjectParserID                = 44
	ProjectParserEQUAL             = 45
	ProjectParserDOT               = 46
	ProjectParserSEMICOLON         = 47
	ProjectParserCOMMA             = 48
	ProjectParserCOLON             = 49
	ProjectParserADMIRATION        = 50
	ProjectParserREFERENCE         = 51
	ProjectParserHERITAGE          = 52
	ProjectParserARROW             = 53
	ProjectParserRANGE             = 54
	ProjectParserLEFT_PAR          = 55
	ProjectParserRIGHT_PAR         = 56
	ProjectParserLEFT_KEY          = 57
	ProjectParserRIGHT_KEY         = 58
	ProjectParserLEFT_BRACKET      = 59
	ProjectParserRIGHT_BRACKET     = 60
	ProjectParserEQUEAL_EQUAL      = 61
	ProjectParserNOTEQUAL          = 62
	ProjectParserGREATER_THAN      = 63
	ProjectParserLESS_THAN         = 64
	ProjectParserGREATER_EQUALTHAN = 65
	ProjectParserLESS_EQUEALTHAN   = 66
	ProjectParserMUL               = 67
	ProjectParserDIV               = 68
	ProjectParserMOD               = 69
	ProjectParserADD               = 70
	ProjectParserSUB               = 71
	ProjectParserAND               = 72
	ProjectParserOR                = 73
	ProjectParserPIPE              = 74
	ProjectParserEQUAL_ARROW       = 75
	ProjectParserUNDERSCORE        = 76
	ProjectParserWHITESPACE        = 77
)

// ProjectParser rules.
const (
	ProjectParserRULE_start            = 0
	ProjectParserRULE_listInits        = 1
	ProjectParserRULE_listFuncs        = 2
	ProjectParserRULE_listArrays       = 3
	ProjectParserRULE_listStructs      = 4
	ProjectParserRULE_modules          = 5
	ProjectParserRULE_module           = 6
	ProjectParserRULE_function         = 7
	ProjectParserRULE_funcMain         = 8
	ProjectParserRULE_bloq             = 9
	ProjectParserRULE_bloq_match       = 10
	ProjectParserRULE_listParams       = 11
	ProjectParserRULE_instructions     = 12
	ProjectParserRULE_instruction      = 13
	ProjectParserRULE_print_prod       = 14
	ProjectParserRULE_listVars         = 15
	ProjectParserRULE_declaration_prod = 16
	ProjectParserRULE_assign_prod      = 17
	ProjectParserRULE_ids_type         = 18
	ProjectParserRULE_listIds          = 19
	ProjectParserRULE_conditional_prod = 20
	ProjectParserRULE_if_prod          = 21
	ProjectParserRULE_list_else_if     = 22
	ProjectParserRULE_else_if          = 23
	ProjectParserRULE_match_prod       = 24
	ProjectParserRULE_list_instr_match = 25
	ProjectParserRULE_instr_match      = 26
	ProjectParserRULE_expr_match       = 27
	ProjectParserRULE_bucle_prod       = 28
	ProjectParserRULE_while_prod       = 29
	ProjectParserRULE_loop_prod        = 30
	ProjectParserRULE_forin_prod       = 31
	ProjectParserRULE_range_prod       = 32
	ProjectParserRULE_called_func      = 33
	ProjectParserRULE_listExpressions  = 34
	ProjectParserRULE_dec_arr          = 35
	ProjectParserRULE_listDim          = 36
	ProjectParserRULE_vector_instr     = 37
	ProjectParserRULE_dec_vector       = 38
	ProjectParserRULE_expr_vector      = 39
	ProjectParserRULE_natives_vector   = 40
	ProjectParserRULE_transfer_prod    = 41
	ProjectParserRULE_break_instr      = 42
	ProjectParserRULE_continue_instr   = 43
	ProjectParserRULE_return_instr     = 44
	ProjectParserRULE_dec_struct       = 45
	ProjectParserRULE_bloq_struct      = 46
	ProjectParserRULE_content_struct   = 47
	ProjectParserRULE_item_struct      = 48
	ProjectParserRULE_dec_object       = 49
	ProjectParserRULE_expression       = 50
	ProjectParserRULE_arraydata        = 51
	ProjectParserRULE_access_array     = 52
	ProjectParserRULE_listInArray      = 53
	ProjectParserRULE_inArray          = 54
	ProjectParserRULE_access_vector    = 55
	ProjectParserRULE_listInVector     = 56
	ProjectParserRULE_inVector         = 57
	ProjectParserRULE_type_struct      = 58
	ProjectParserRULE_def_items        = 59
	ProjectParserRULE_item             = 60
	ProjectParserRULE_access_object    = 61
	ProjectParserRULE_listAccess       = 62
	ProjectParserRULE_access           = 63
	ProjectParserRULE_expr_rel         = 64
	ProjectParserRULE_expr_arit        = 65
	ProjectParserRULE_expr_valor       = 66
	ProjectParserRULE_pow_op           = 67
	ProjectParserRULE_expr_logic       = 68
	ProjectParserRULE_expr_cast        = 69
	ProjectParserRULE_data_type        = 70
	ProjectParserRULE_primitive        = 71
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listInits returns the _listInits rule contexts.
	Get_listInits() IListInitsContext

	// Set_listInits sets the _listInits rule contexts.
	Set_listInits(IListInitsContext)

	// GetTree returns the tree attribute.
	GetTree() AST.Tree

	// SetTree sets the tree attribute.
	SetTree(AST.Tree)

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	tree       AST.Tree
	_listInits IListInitsContext
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Get_listInits() IListInitsContext { return s._listInits }

func (s *StartContext) Set_listInits(v IListInitsContext) { s._listInits = v }

func (s *StartContext) GetTree() AST.Tree { return s.tree }

func (s *StartContext) SetTree(v AST.Tree) { s.tree = v }

func (s *StartContext) ListInits() IListInitsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListInitsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListInitsContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitStart(s)
	}
}

func (p *ProjectParser) Start() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ProjectParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(144)

		var _x = p.ListInits()

		localctx.(*StartContext)._listInits = _x
	}
	localctx.(*StartContext).tree = AST.NewTree(localctx.(*StartContext).Get_listInits().GetL())

	return localctx
}

// IListInitsContext is an interface to support dynamic dispatch.
type IListInitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listFuncs returns the _listFuncs rule contexts.
	Get_listFuncs() IListFuncsContext

	// Set_listFuncs sets the _listFuncs rule contexts.
	Set_listFuncs(IListFuncsContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListInitsContext differentiates from other interfaces.
	IsListInitsContext()
}

type ListInitsContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	l          *arrayList.List
	_listFuncs IListFuncsContext
}

func NewEmptyListInitsContext() *ListInitsContext {
	var p = new(ListInitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listInits
	return p
}

func (*ListInitsContext) IsListInitsContext() {}

func NewListInitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListInitsContext {
	var p = new(ListInitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listInits

	return p
}

func (s *ListInitsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListInitsContext) Get_listFuncs() IListFuncsContext { return s._listFuncs }

func (s *ListInitsContext) Set_listFuncs(v IListFuncsContext) { s._listFuncs = v }

func (s *ListInitsContext) GetL() *arrayList.List { return s.l }

func (s *ListInitsContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListInitsContext) ListFuncs() IListFuncsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListFuncsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListFuncsContext)
}

func (s *ListInitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListInitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListInitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListInits(s)
	}
}

func (s *ListInitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListInits(s)
	}
}

func (p *ProjectParser) ListInits() (localctx IListInitsContext) {
	localctx = NewListInitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ProjectParserRULE_listInits)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(147)

		var _x = p.listFuncs(0)

		localctx.(*ListInitsContext)._listFuncs = _x
	}
	localctx.(*ListInitsContext).l = localctx.(*ListInitsContext).Get_listFuncs().GetL()

	return localctx
}

// IListFuncsContext is an interface to support dynamic dispatch.
type IListFuncsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IListFuncsContext

	// Get_listArrays returns the _listArrays rule contexts.
	Get_listArrays() IListArraysContext

	// Get_function returns the _function rule contexts.
	Get_function() IFunctionContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IListFuncsContext)

	// Set_listArrays sets the _listArrays rule contexts.
	Set_listArrays(IListArraysContext)

	// Set_function sets the _function rule contexts.
	Set_function(IFunctionContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListFuncsContext differentiates from other interfaces.
	IsListFuncsContext()
}

type ListFuncsContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	l           *arrayList.List
	subList     IListFuncsContext
	_listArrays IListArraysContext
	_function   IFunctionContext
}

func NewEmptyListFuncsContext() *ListFuncsContext {
	var p = new(ListFuncsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listFuncs
	return p
}

func (*ListFuncsContext) IsListFuncsContext() {}

func NewListFuncsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListFuncsContext {
	var p = new(ListFuncsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listFuncs

	return p
}

func (s *ListFuncsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListFuncsContext) GetSubList() IListFuncsContext { return s.subList }

func (s *ListFuncsContext) Get_listArrays() IListArraysContext { return s._listArrays }

func (s *ListFuncsContext) Get_function() IFunctionContext { return s._function }

func (s *ListFuncsContext) SetSubList(v IListFuncsContext) { s.subList = v }

func (s *ListFuncsContext) Set_listArrays(v IListArraysContext) { s._listArrays = v }

func (s *ListFuncsContext) Set_function(v IFunctionContext) { s._function = v }

func (s *ListFuncsContext) GetL() *arrayList.List { return s.l }

func (s *ListFuncsContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListFuncsContext) ListArrays() IListArraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListArraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListArraysContext)
}

func (s *ListFuncsContext) Function() IFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *ListFuncsContext) ListFuncs() IListFuncsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListFuncsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListFuncsContext)
}

func (s *ListFuncsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListFuncsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListFuncsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListFuncs(s)
	}
}

func (s *ListFuncsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListFuncs(s)
	}
}

func (p *ProjectParser) ListFuncs() (localctx IListFuncsContext) {
	return p.listFuncs(0)
}

func (p *ProjectParser) listFuncs(_p int) (localctx IListFuncsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListFuncsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListFuncsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 4
	p.EnterRecursionRule(localctx, 4, ProjectParserRULE_listFuncs, _p)

	localctx.(*ListFuncsContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(157)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserDECLARAR, ProjectParserRSTRUCT, ProjectParserRMODULE, ProjectParserRPUB:
		{
			p.SetState(151)

			var _x = p.listArrays(0)

			localctx.(*ListFuncsContext)._listArrays = _x
		}
		localctx.(*ListFuncsContext).l = localctx.(*ListFuncsContext).Get_listArrays().GetL()

	case ProjectParserRFN:
		{
			p.SetState(154)

			var _x = p.Function()

			localctx.(*ListFuncsContext)._function = _x
		}
		localctx.(*ListFuncsContext).l.Add(localctx.(*ListFuncsContext).Get_function().GetInstr())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(165)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListFuncsContext(p, _parentctx, _parentState)
			localctx.(*ListFuncsContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listFuncs)
			p.SetState(159)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(160)

				var _x = p.Function()

				localctx.(*ListFuncsContext)._function = _x
			}

			localctx.(*ListFuncsContext).GetSubList().GetL().Add(localctx.(*ListFuncsContext).Get_function().GetInstr())
			localctx.(*ListFuncsContext).l = localctx.(*ListFuncsContext).GetSubList().GetL()

		}
		p.SetState(167)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}

	return localctx
}

// IListArraysContext is an interface to support dynamic dispatch.
type IListArraysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IListArraysContext

	// Get_listStructs returns the _listStructs rule contexts.
	Get_listStructs() IListStructsContext

	// Get_dec_arr returns the _dec_arr rule contexts.
	Get_dec_arr() IDec_arrContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IListArraysContext)

	// Set_listStructs sets the _listStructs rule contexts.
	Set_listStructs(IListStructsContext)

	// Set_dec_arr sets the _dec_arr rule contexts.
	Set_dec_arr(IDec_arrContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListArraysContext differentiates from other interfaces.
	IsListArraysContext()
}

type ListArraysContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	l            *arrayList.List
	subList      IListArraysContext
	_listStructs IListStructsContext
	_dec_arr     IDec_arrContext
}

func NewEmptyListArraysContext() *ListArraysContext {
	var p = new(ListArraysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listArrays
	return p
}

func (*ListArraysContext) IsListArraysContext() {}

func NewListArraysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListArraysContext {
	var p = new(ListArraysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listArrays

	return p
}

func (s *ListArraysContext) GetParser() antlr.Parser { return s.parser }

func (s *ListArraysContext) GetSubList() IListArraysContext { return s.subList }

func (s *ListArraysContext) Get_listStructs() IListStructsContext { return s._listStructs }

func (s *ListArraysContext) Get_dec_arr() IDec_arrContext { return s._dec_arr }

func (s *ListArraysContext) SetSubList(v IListArraysContext) { s.subList = v }

func (s *ListArraysContext) Set_listStructs(v IListStructsContext) { s._listStructs = v }

func (s *ListArraysContext) Set_dec_arr(v IDec_arrContext) { s._dec_arr = v }

func (s *ListArraysContext) GetL() *arrayList.List { return s.l }

func (s *ListArraysContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListArraysContext) ListStructs() IListStructsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListStructsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListStructsContext)
}

func (s *ListArraysContext) Dec_arr() IDec_arrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDec_arrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDec_arrContext)
}

func (s *ListArraysContext) ListArrays() IListArraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListArraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListArraysContext)
}

func (s *ListArraysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListArraysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListArraysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListArrays(s)
	}
}

func (s *ListArraysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListArrays(s)
	}
}

func (p *ProjectParser) ListArrays() (localctx IListArraysContext) {
	return p.listArrays(0)
}

func (p *ProjectParser) listArrays(_p int) (localctx IListArraysContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListArraysContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListArraysContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 6
	p.EnterRecursionRule(localctx, 6, ProjectParserRULE_listArrays, _p)

	localctx.(*ListArraysContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(175)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRSTRUCT, ProjectParserRMODULE, ProjectParserRPUB:
		{
			p.SetState(169)

			var _x = p.listStructs(0)

			localctx.(*ListArraysContext)._listStructs = _x
		}
		localctx.(*ListArraysContext).l = localctx.(*ListArraysContext).Get_listStructs().GetL()

	case ProjectParserDECLARAR:
		{
			p.SetState(172)

			var _x = p.Dec_arr()

			localctx.(*ListArraysContext)._dec_arr = _x
		}
		localctx.(*ListArraysContext).l.Add(localctx.(*ListArraysContext).Get_dec_arr().GetInstr())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListArraysContext(p, _parentctx, _parentState)
			localctx.(*ListArraysContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listArrays)
			p.SetState(177)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(178)

				var _x = p.Dec_arr()

				localctx.(*ListArraysContext)._dec_arr = _x
			}

			localctx.(*ListArraysContext).GetSubList().GetL().Add(localctx.(*ListArraysContext).Get_dec_arr().GetInstr())
			localctx.(*ListArraysContext).l = localctx.(*ListArraysContext).GetSubList().GetL()

		}
		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}

	return localctx
}

// IListStructsContext is an interface to support dynamic dispatch.
type IListStructsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IListStructsContext

	// Get_modules returns the _modules rule contexts.
	Get_modules() IModulesContext

	// Get_dec_struct returns the _dec_struct rule contexts.
	Get_dec_struct() IDec_structContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IListStructsContext)

	// Set_modules sets the _modules rule contexts.
	Set_modules(IModulesContext)

	// Set_dec_struct sets the _dec_struct rule contexts.
	Set_dec_struct(IDec_structContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListStructsContext differentiates from other interfaces.
	IsListStructsContext()
}

type ListStructsContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	l           *arrayList.List
	subList     IListStructsContext
	_modules    IModulesContext
	_dec_struct IDec_structContext
}

func NewEmptyListStructsContext() *ListStructsContext {
	var p = new(ListStructsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listStructs
	return p
}

func (*ListStructsContext) IsListStructsContext() {}

func NewListStructsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListStructsContext {
	var p = new(ListStructsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listStructs

	return p
}

func (s *ListStructsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListStructsContext) GetSubList() IListStructsContext { return s.subList }

func (s *ListStructsContext) Get_modules() IModulesContext { return s._modules }

func (s *ListStructsContext) Get_dec_struct() IDec_structContext { return s._dec_struct }

func (s *ListStructsContext) SetSubList(v IListStructsContext) { s.subList = v }

func (s *ListStructsContext) Set_modules(v IModulesContext) { s._modules = v }

func (s *ListStructsContext) Set_dec_struct(v IDec_structContext) { s._dec_struct = v }

func (s *ListStructsContext) GetL() *arrayList.List { return s.l }

func (s *ListStructsContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListStructsContext) Modules() IModulesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModulesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModulesContext)
}

func (s *ListStructsContext) Dec_struct() IDec_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDec_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDec_structContext)
}

func (s *ListStructsContext) ListStructs() IListStructsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListStructsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListStructsContext)
}

func (s *ListStructsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListStructsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListStructsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListStructs(s)
	}
}

func (s *ListStructsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListStructs(s)
	}
}

func (p *ProjectParser) ListStructs() (localctx IListStructsContext) {
	return p.listStructs(0)
}

func (p *ProjectParser) listStructs(_p int) (localctx IListStructsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListStructsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListStructsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 8
	p.EnterRecursionRule(localctx, 8, ProjectParserRULE_listStructs, _p)

	localctx.(*ListStructsContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(193)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRMODULE, ProjectParserRPUB:
		{
			p.SetState(187)

			var _x = p.modules(0)

			localctx.(*ListStructsContext)._modules = _x
		}
		localctx.(*ListStructsContext).l = localctx.(*ListStructsContext).Get_modules().GetL()

	case ProjectParserRSTRUCT:
		{
			p.SetState(190)

			var _x = p.Dec_struct()

			localctx.(*ListStructsContext)._dec_struct = _x
		}
		localctx.(*ListStructsContext).l.Add(localctx.(*ListStructsContext).Get_dec_struct().GetInstr())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(201)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListStructsContext(p, _parentctx, _parentState)
			localctx.(*ListStructsContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listStructs)
			p.SetState(195)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(196)

				var _x = p.Dec_struct()

				localctx.(*ListStructsContext)._dec_struct = _x
			}

			localctx.(*ListStructsContext).GetSubList().GetL().Add(localctx.(*ListStructsContext).Get_dec_struct().GetInstr())
			localctx.(*ListStructsContext).l = localctx.(*ListStructsContext).GetSubList().GetL()

		}
		p.SetState(203)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}

	return localctx
}

// IModulesContext is an interface to support dynamic dispatch.
type IModulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IModulesContext

	// Get_module returns the _module rule contexts.
	Get_module() IModuleContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IModulesContext)

	// Set_module sets the _module rule contexts.
	Set_module(IModuleContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsModulesContext differentiates from other interfaces.
	IsModulesContext()
}

type ModulesContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	l       *arrayList.List
	subList IModulesContext
	_module IModuleContext
}

func NewEmptyModulesContext() *ModulesContext {
	var p = new(ModulesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_modules
	return p
}

func (*ModulesContext) IsModulesContext() {}

func NewModulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModulesContext {
	var p = new(ModulesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_modules

	return p
}

func (s *ModulesContext) GetParser() antlr.Parser { return s.parser }

func (s *ModulesContext) GetSubList() IModulesContext { return s.subList }

func (s *ModulesContext) Get_module() IModuleContext { return s._module }

func (s *ModulesContext) SetSubList(v IModulesContext) { s.subList = v }

func (s *ModulesContext) Set_module(v IModuleContext) { s._module = v }

func (s *ModulesContext) GetL() *arrayList.List { return s.l }

func (s *ModulesContext) SetL(v *arrayList.List) { s.l = v }

func (s *ModulesContext) Module() IModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleContext)
}

func (s *ModulesContext) Modules() IModulesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModulesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModulesContext)
}

func (s *ModulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterModules(s)
	}
}

func (s *ModulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitModules(s)
	}
}

func (p *ProjectParser) Modules() (localctx IModulesContext) {
	return p.modules(0)
}

func (p *ProjectParser) modules(_p int) (localctx IModulesContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewModulesContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IModulesContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, ProjectParserRULE_modules, _p)

	localctx.(*ModulesContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(205)

		var _x = p.Module()

		localctx.(*ModulesContext)._module = _x
	}
	localctx.(*ModulesContext).l.Add(localctx.(*ModulesContext).Get_module().GetInstr())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewModulesContext(p, _parentctx, _parentState)
			localctx.(*ModulesContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_modules)
			p.SetState(208)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(209)

				var _x = p.Module()

				localctx.(*ModulesContext)._module = _x
			}

			localctx.(*ModulesContext).GetSubList().GetL().Add(localctx.(*ModulesContext).Get_module().GetInstr())
			localctx.(*ModulesContext).l = localctx.(*ModulesContext).GetSubList().GetL()

		}
		p.SetState(216)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RPUB returns the _RPUB token.
	Get_RPUB() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_RPUB sets the _RPUB token.
	Set_RPUB(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_listFuncs returns the _listFuncs rule contexts.
	Get_listFuncs() IListFuncsContext

	// Set_listFuncs sets the _listFuncs rule contexts.
	Set_listFuncs(IListFuncsContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	instr      Abstract.Instruction
	_RPUB      antlr.Token
	_ID        antlr.Token
	_listFuncs IListFuncsContext
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) Get_RPUB() antlr.Token { return s._RPUB }

func (s *ModuleContext) Get_ID() antlr.Token { return s._ID }

func (s *ModuleContext) Set_RPUB(v antlr.Token) { s._RPUB = v }

func (s *ModuleContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ModuleContext) Get_listFuncs() IListFuncsContext { return s._listFuncs }

func (s *ModuleContext) Set_listFuncs(v IListFuncsContext) { s._listFuncs = v }

func (s *ModuleContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *ModuleContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *ModuleContext) RMODULE() antlr.TerminalNode {
	return s.GetToken(ProjectParserRMODULE, 0)
}

func (s *ModuleContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *ModuleContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *ModuleContext) ListFuncs() IListFuncsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListFuncsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListFuncsContext)
}

func (s *ModuleContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *ModuleContext) RPUB() antlr.TerminalNode {
	return s.GetToken(ProjectParserRPUB, 0)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *ProjectParser) Module() (localctx IModuleContext) {
	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ProjectParserRULE_module)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ProjectParserRPUB {
		{
			p.SetState(217)

			var _m = p.Match(ProjectParserRPUB)

			localctx.(*ModuleContext)._RPUB = _m
		}

	}
	{
		p.SetState(220)
		p.Match(ProjectParserRMODULE)
	}
	{
		p.SetState(221)

		var _m = p.Match(ProjectParserID)

		localctx.(*ModuleContext)._ID = _m
	}
	{
		p.SetState(222)
		p.Match(ProjectParserLEFT_KEY)
	}
	{
		p.SetState(223)

		var _x = p.listFuncs(0)

		localctx.(*ModuleContext)._listFuncs = _x
	}
	{
		p.SetState(224)
		p.Match(ProjectParserRIGHT_KEY)
	}

	if (func() string {
		if localctx.(*ModuleContext).Get_RPUB() == nil {
			return ""
		} else {
			return localctx.(*ModuleContext).Get_RPUB().GetText()
		}
	}()) != "" {
		localctx.(*ModuleContext).instr = Module.NewModule((func() string {
			if localctx.(*ModuleContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*ModuleContext).Get_ID().GetText()
			}
		}()), localctx.(*ModuleContext).Get_listFuncs().GetL(), (func() string {
			if localctx.(*ModuleContext).Get_RPUB() == nil {
				return ""
			} else {
				return localctx.(*ModuleContext).Get_RPUB().GetText()
			}
		}()))
	} else {
		localctx.(*ModuleContext).instr = Module.NewModule((func() string {
			if localctx.(*ModuleContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*ModuleContext).Get_ID().GetText()
			}
		}()), localctx.(*ModuleContext).Get_listFuncs().GetL(), "")
	}

	return localctx
}

// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RFN returns the _RFN token.
	Get_RFN() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_RFN sets the _RFN token.
	Set_RFN(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_funcMain returns the _funcMain rule contexts.
	Get_funcMain() IFuncMainContext

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// Get_listParams returns the _listParams rule contexts.
	Get_listParams() IListParamsContext

	// Set_funcMain sets the _funcMain rule contexts.
	Set_funcMain(IFuncMainContext)

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// Set_listParams sets the _listParams rule contexts.
	Set_listParams(IListParamsContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_funcMain   IFuncMainContext
	_RFN        antlr.Token
	_ID         antlr.Token
	_bloq       IBloqContext
	_data_type  IData_typeContext
	_listParams IListParamsContext
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_function
	return p
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) Get_RFN() antlr.Token { return s._RFN }

func (s *FunctionContext) Get_ID() antlr.Token { return s._ID }

func (s *FunctionContext) Set_RFN(v antlr.Token) { s._RFN = v }

func (s *FunctionContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *FunctionContext) Get_funcMain() IFuncMainContext { return s._funcMain }

func (s *FunctionContext) Get_bloq() IBloqContext { return s._bloq }

func (s *FunctionContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *FunctionContext) Get_listParams() IListParamsContext { return s._listParams }

func (s *FunctionContext) Set_funcMain(v IFuncMainContext) { s._funcMain = v }

func (s *FunctionContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *FunctionContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *FunctionContext) Set_listParams(v IListParamsContext) { s._listParams = v }

func (s *FunctionContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *FunctionContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *FunctionContext) FuncMain() IFuncMainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncMainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncMainContext)
}

func (s *FunctionContext) RFN() antlr.TerminalNode {
	return s.GetToken(ProjectParserRFN, 0)
}

func (s *FunctionContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *FunctionContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *FunctionContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *FunctionContext) Bloq() IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *FunctionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ProjectParserARROW, 0)
}

func (s *FunctionContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *FunctionContext) ListParams() IListParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListParamsContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterFunction(s)
	}
}

func (s *FunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitFunction(s)
	}
}

func (p *ProjectParser) Function() (localctx IFunctionContext) {
	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ProjectParserRULE_function)
	listParams := arrayList.New()

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(227)

			var _x = p.FuncMain()

			localctx.(*FunctionContext)._funcMain = _x
		}
		localctx.(*FunctionContext).instr = localctx.(*FunctionContext).Get_funcMain().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(230)

			var _m = p.Match(ProjectParserRFN)

			localctx.(*FunctionContext)._RFN = _m
		}
		{
			p.SetState(231)

			var _m = p.Match(ProjectParserID)

			localctx.(*FunctionContext)._ID = _m
		}
		{
			p.SetState(232)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(233)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(234)

			var _x = p.Bloq()

			localctx.(*FunctionContext)._bloq = _x
		}

		localctx.(*FunctionContext).instr = Environment.NewFunction((func() int {
			if localctx.(*FunctionContext).Get_RFN() == nil {
				return 0
			} else {
				return localctx.(*FunctionContext).Get_RFN().GetLine()
			}
		}()), localctx.(*FunctionContext).Get_RFN().GetColumn(), (func() string {
			if localctx.(*FunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FunctionContext).Get_ID().GetText()
			}
		}()), listParams, localctx.(*FunctionContext).Get_bloq().GetContent(), "void")

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(237)

			var _m = p.Match(ProjectParserRFN)

			localctx.(*FunctionContext)._RFN = _m
		}
		{
			p.SetState(238)

			var _m = p.Match(ProjectParserID)

			localctx.(*FunctionContext)._ID = _m
		}
		{
			p.SetState(239)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(240)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(241)
			p.Match(ProjectParserARROW)
		}
		{
			p.SetState(242)

			var _x = p.Data_type()

			localctx.(*FunctionContext)._data_type = _x
		}
		{
			p.SetState(243)

			var _x = p.Bloq()

			localctx.(*FunctionContext)._bloq = _x
		}

		localctx.(*FunctionContext).instr = Environment.NewFunction((func() int {
			if localctx.(*FunctionContext).Get_RFN() == nil {
				return 0
			} else {
				return localctx.(*FunctionContext).Get_RFN().GetLine()
			}
		}()), localctx.(*FunctionContext).Get_RFN().GetColumn(), (func() string {
			if localctx.(*FunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FunctionContext).Get_ID().GetText()
			}
		}()), listParams, localctx.(*FunctionContext).Get_bloq().GetContent(), localctx.(*FunctionContext).Get_data_type().GetData())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(246)

			var _m = p.Match(ProjectParserRFN)

			localctx.(*FunctionContext)._RFN = _m
		}
		{
			p.SetState(247)

			var _m = p.Match(ProjectParserID)

			localctx.(*FunctionContext)._ID = _m
		}
		{
			p.SetState(248)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(249)

			var _x = p.listParams(0)

			localctx.(*FunctionContext)._listParams = _x
		}
		{
			p.SetState(250)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(251)

			var _x = p.Bloq()

			localctx.(*FunctionContext)._bloq = _x
		}

		localctx.(*FunctionContext).instr = Environment.NewFunction((func() int {
			if localctx.(*FunctionContext).Get_RFN() == nil {
				return 0
			} else {
				return localctx.(*FunctionContext).Get_RFN().GetLine()
			}
		}()), localctx.(*FunctionContext).Get_RFN().GetColumn(), (func() string {
			if localctx.(*FunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FunctionContext).Get_ID().GetText()
			}
		}()), localctx.(*FunctionContext).Get_listParams().GetL(), localctx.(*FunctionContext).Get_bloq().GetContent(), "void")

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(254)

			var _m = p.Match(ProjectParserRFN)

			localctx.(*FunctionContext)._RFN = _m
		}
		{
			p.SetState(255)

			var _m = p.Match(ProjectParserID)

			localctx.(*FunctionContext)._ID = _m
		}
		{
			p.SetState(256)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(257)

			var _x = p.listParams(0)

			localctx.(*FunctionContext)._listParams = _x
		}
		{
			p.SetState(258)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(259)
			p.Match(ProjectParserARROW)
		}
		{
			p.SetState(260)

			var _x = p.Data_type()

			localctx.(*FunctionContext)._data_type = _x
		}
		{
			p.SetState(261)

			var _x = p.Bloq()

			localctx.(*FunctionContext)._bloq = _x
		}

		localctx.(*FunctionContext).instr = Environment.NewFunction((func() int {
			if localctx.(*FunctionContext).Get_RFN() == nil {
				return 0
			} else {
				return localctx.(*FunctionContext).Get_RFN().GetLine()
			}
		}()), localctx.(*FunctionContext).Get_RFN().GetColumn(), (func() string {
			if localctx.(*FunctionContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*FunctionContext).Get_ID().GetText()
			}
		}()), localctx.(*FunctionContext).Get_listParams().GetL(), localctx.(*FunctionContext).Get_bloq().GetContent(), localctx.(*FunctionContext).Get_data_type().GetData())

	}

	return localctx
}

// IFuncMainContext is an interface to support dynamic dispatch.
type IFuncMainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RFN returns the _RFN token.
	Get_RFN() antlr.Token

	// Set_RFN sets the _RFN token.
	Set_RFN(antlr.Token)

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsFuncMainContext differentiates from other interfaces.
	IsFuncMainContext()
}

type FuncMainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	instr  Abstract.Instruction
	_RFN   antlr.Token
	_bloq  IBloqContext
}

func NewEmptyFuncMainContext() *FuncMainContext {
	var p = new(FuncMainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_funcMain
	return p
}

func (*FuncMainContext) IsFuncMainContext() {}

func NewFuncMainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncMainContext {
	var p = new(FuncMainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_funcMain

	return p
}

func (s *FuncMainContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncMainContext) Get_RFN() antlr.Token { return s._RFN }

func (s *FuncMainContext) Set_RFN(v antlr.Token) { s._RFN = v }

func (s *FuncMainContext) Get_bloq() IBloqContext { return s._bloq }

func (s *FuncMainContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *FuncMainContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *FuncMainContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *FuncMainContext) RFN() antlr.TerminalNode {
	return s.GetToken(ProjectParserRFN, 0)
}

func (s *FuncMainContext) RMAIN() antlr.TerminalNode {
	return s.GetToken(ProjectParserRMAIN, 0)
}

func (s *FuncMainContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *FuncMainContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *FuncMainContext) Bloq() IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *FuncMainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncMainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncMainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterFuncMain(s)
	}
}

func (s *FuncMainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitFuncMain(s)
	}
}

func (p *ProjectParser) FuncMain() (localctx IFuncMainContext) {
	localctx = NewFuncMainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ProjectParserRULE_funcMain)
	listParams := arrayList.New()

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)

		var _m = p.Match(ProjectParserRFN)

		localctx.(*FuncMainContext)._RFN = _m
	}
	{
		p.SetState(267)
		p.Match(ProjectParserRMAIN)
	}
	{
		p.SetState(268)
		p.Match(ProjectParserLEFT_PAR)
	}
	{
		p.SetState(269)
		p.Match(ProjectParserRIGHT_PAR)
	}
	{
		p.SetState(270)

		var _x = p.Bloq()

		localctx.(*FuncMainContext)._bloq = _x
	}
	localctx.(*FuncMainContext).instr = Environment.NewFunction((func() int {
		if localctx.(*FuncMainContext).Get_RFN() == nil {
			return 0
		} else {
			return localctx.(*FuncMainContext).Get_RFN().GetLine()
		}
	}()), localctx.(*FuncMainContext).Get_RFN().GetColumn(), "main", listParams, localctx.(*FuncMainContext).Get_bloq().GetContent(), "void")

	return localctx
}

// IBloqContext is an interface to support dynamic dispatch.
type IBloqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instructions returns the _instructions rule contexts.
	Get_instructions() IInstructionsContext

	// Set_instructions sets the _instructions rule contexts.
	Set_instructions(IInstructionsContext)

	// GetContent returns the content attribute.
	GetContent() *arrayList.List

	// SetContent sets the content attribute.
	SetContent(*arrayList.List)

	// IsBloqContext differentiates from other interfaces.
	IsBloqContext()
}

type BloqContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	content       *arrayList.List
	_instructions IInstructionsContext
}

func NewEmptyBloqContext() *BloqContext {
	var p = new(BloqContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_bloq
	return p
}

func (*BloqContext) IsBloqContext() {}

func NewBloqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BloqContext {
	var p = new(BloqContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_bloq

	return p
}

func (s *BloqContext) GetParser() antlr.Parser { return s.parser }

func (s *BloqContext) Get_instructions() IInstructionsContext { return s._instructions }

func (s *BloqContext) Set_instructions(v IInstructionsContext) { s._instructions = v }

func (s *BloqContext) GetContent() *arrayList.List { return s.content }

func (s *BloqContext) SetContent(v *arrayList.List) { s.content = v }

func (s *BloqContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *BloqContext) Instructions() IInstructionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstructionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstructionsContext)
}

func (s *BloqContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *BloqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BloqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BloqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterBloq(s)
	}
}

func (s *BloqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitBloq(s)
	}
}

func (p *ProjectParser) Bloq() (localctx IBloqContext) {
	localctx = NewBloqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ProjectParserRULE_bloq)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(273)
			p.Match(ProjectParserLEFT_KEY)
		}
		{
			p.SetState(274)

			var _x = p.Instructions()

			localctx.(*BloqContext)._instructions = _x
		}
		{
			p.SetState(275)
			p.Match(ProjectParserRIGHT_KEY)
		}
		localctx.(*BloqContext).content = localctx.(*BloqContext).Get_instructions().GetL()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(278)
			p.Match(ProjectParserLEFT_KEY)
		}
		{
			p.SetState(279)
			p.Match(ProjectParserRIGHT_KEY)
		}
		localctx.(*BloqContext).content = arrayList.New()

	}

	return localctx
}

// IBloq_matchContext is an interface to support dynamic dispatch.
type IBloq_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instructions returns the _instructions rule contexts.
	Get_instructions() IInstructionsContext

	// Set_instructions sets the _instructions rule contexts.
	Set_instructions(IInstructionsContext)

	// GetContent returns the content attribute.
	GetContent() *arrayList.List

	// SetContent sets the content attribute.
	SetContent(*arrayList.List)

	// IsBloq_matchContext differentiates from other interfaces.
	IsBloq_matchContext()
}

type Bloq_matchContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	content       *arrayList.List
	_instructions IInstructionsContext
}

func NewEmptyBloq_matchContext() *Bloq_matchContext {
	var p = new(Bloq_matchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_bloq_match
	return p
}

func (*Bloq_matchContext) IsBloq_matchContext() {}

func NewBloq_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bloq_matchContext {
	var p = new(Bloq_matchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_bloq_match

	return p
}

func (s *Bloq_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *Bloq_matchContext) Get_instructions() IInstructionsContext { return s._instructions }

func (s *Bloq_matchContext) Set_instructions(v IInstructionsContext) { s._instructions = v }

func (s *Bloq_matchContext) GetContent() *arrayList.List { return s.content }

func (s *Bloq_matchContext) SetContent(v *arrayList.List) { s.content = v }

func (s *Bloq_matchContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *Bloq_matchContext) Instructions() IInstructionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstructionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstructionsContext)
}

func (s *Bloq_matchContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *Bloq_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bloq_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bloq_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterBloq_match(s)
	}
}

func (s *Bloq_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitBloq_match(s)
	}
}

func (p *ProjectParser) Bloq_match() (localctx IBloq_matchContext) {
	localctx = NewBloq_matchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ProjectParserRULE_bloq_match)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			p.Match(ProjectParserLEFT_KEY)
		}
		{
			p.SetState(284)

			var _x = p.Instructions()

			localctx.(*Bloq_matchContext)._instructions = _x
		}
		{
			p.SetState(285)
			p.Match(ProjectParserRIGHT_KEY)
		}
		localctx.(*Bloq_matchContext).content = localctx.(*Bloq_matchContext).Get_instructions().GetL()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(288)

			var _x = p.Instructions()

			localctx.(*Bloq_matchContext)._instructions = _x
		}
		localctx.(*Bloq_matchContext).content = localctx.(*Bloq_matchContext).Get_instructions().GetL()

	}

	return localctx
}

// IListParamsContext is an interface to support dynamic dispatch.
type IListParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetList returns the List rule contexts.
	GetList() IListParamsContext

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// SetList sets the List rule contexts.
	SetList(IListParamsContext)

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListParamsContext differentiates from other interfaces.
	IsListParamsContext()
}

type ListParamsContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	l          *arrayList.List
	List       IListParamsContext
	_ID        antlr.Token
	_data_type IData_typeContext
}

func NewEmptyListParamsContext() *ListParamsContext {
	var p = new(ListParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listParams
	return p
}

func (*ListParamsContext) IsListParamsContext() {}

func NewListParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListParamsContext {
	var p = new(ListParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listParams

	return p
}

func (s *ListParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListParamsContext) Get_ID() antlr.Token { return s._ID }

func (s *ListParamsContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ListParamsContext) GetList() IListParamsContext { return s.List }

func (s *ListParamsContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *ListParamsContext) SetList(v IListParamsContext) { s.List = v }

func (s *ListParamsContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *ListParamsContext) GetL() *arrayList.List { return s.l }

func (s *ListParamsContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListParamsContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *ListParamsContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *ListParamsContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *ListParamsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *ListParamsContext) ListParams() IListParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListParamsContext)
}

func (s *ListParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListParams(s)
	}
}

func (s *ListParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListParams(s)
	}
}

func (p *ProjectParser) ListParams() (localctx IListParamsContext) {
	return p.listParams(0)
}

func (p *ProjectParser) listParams(_p int) (localctx IListParamsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListParamsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListParamsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 22
	p.EnterRecursionRule(localctx, 22, ProjectParserRULE_listParams, _p)

	localctx.(*ListParamsContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)

		var _m = p.Match(ProjectParserID)

		localctx.(*ListParamsContext)._ID = _m
	}
	{
		p.SetState(295)
		p.Match(ProjectParserCOLON)
	}
	{
		p.SetState(296)

		var _x = p.Data_type()

		localctx.(*ListParamsContext)._data_type = _x
	}

	listIds := arrayList.New()
	listIds.Add(Expression.NewIdentifier((func() string {
		if localctx.(*ListParamsContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*ListParamsContext).Get_ID().GetText()
		}
	}()), (func() int {
		if localctx.(*ListParamsContext).Get_ID() == nil {
			return 0
		} else {
			return localctx.(*ListParamsContext).Get_ID().GetLine()
		}
	}()), localctx.(*ListParamsContext).Get_ID().GetColumn()))
	newDec := Natives.NewDeclaration(listIds, false, localctx.(*ListParamsContext).Get_data_type().GetData())
	localctx.(*ListParamsContext).l.Add(newDec)

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListParamsContext(p, _parentctx, _parentState)
			localctx.(*ListParamsContext).List = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listParams)
			p.SetState(299)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(300)
				p.Match(ProjectParserCOMMA)
			}
			{
				p.SetState(301)

				var _m = p.Match(ProjectParserID)

				localctx.(*ListParamsContext)._ID = _m
			}
			{
				p.SetState(302)
				p.Match(ProjectParserCOLON)
			}
			{
				p.SetState(303)

				var _x = p.Data_type()

				localctx.(*ListParamsContext)._data_type = _x
			}

			listIds := arrayList.New()
			listIds.Add(Expression.NewIdentifier((func() string {
				if localctx.(*ListParamsContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*ListParamsContext).Get_ID().GetText()
				}
			}()), (func() int {
				if localctx.(*ListParamsContext).Get_ID() == nil {
					return 0
				} else {
					return localctx.(*ListParamsContext).Get_ID().GetLine()
				}
			}()), localctx.(*ListParamsContext).Get_ID().GetColumn()))
			newDec := Natives.NewDeclaration(listIds, false, localctx.(*ListParamsContext).Get_data_type().GetData())
			localctx.(*ListParamsContext).GetList().GetL().Add(newDec)
			localctx.(*ListParamsContext).l = localctx.(*ListParamsContext).GetList().GetL()

		}
		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}

	return localctx
}

// IInstructionsContext is an interface to support dynamic dispatch.
type IInstructionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instruction returns the _instruction rule contexts.
	Get_instruction() IInstructionContext

	// Set_instruction sets the _instruction rule contexts.
	Set_instruction(IInstructionContext)

	// GetE returns the e rule context list.
	GetE() []IInstructionContext

	// SetE sets the e rule context list.
	SetE([]IInstructionContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsInstructionsContext differentiates from other interfaces.
	IsInstructionsContext()
}

type InstructionsContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	l            *arrayList.List
	_instruction IInstructionContext
	e            []IInstructionContext
}

func NewEmptyInstructionsContext() *InstructionsContext {
	var p = new(InstructionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_instructions
	return p
}

func (*InstructionsContext) IsInstructionsContext() {}

func NewInstructionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionsContext {
	var p = new(InstructionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_instructions

	return p
}

func (s *InstructionsContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionsContext) Get_instruction() IInstructionContext { return s._instruction }

func (s *InstructionsContext) Set_instruction(v IInstructionContext) { s._instruction = v }

func (s *InstructionsContext) GetE() []IInstructionContext { return s.e }

func (s *InstructionsContext) SetE(v []IInstructionContext) { s.e = v }

func (s *InstructionsContext) GetL() *arrayList.List { return s.l }

func (s *InstructionsContext) SetL(v *arrayList.List) { s.l = v }

func (s *InstructionsContext) AllInstruction() []IInstructionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstructionContext)(nil)).Elem())
	var tst = make([]IInstructionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstructionContext)
		}
	}

	return tst
}

func (s *InstructionsContext) Instruction(i int) IInstructionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstructionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstructionContext)
}

func (s *InstructionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstructionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterInstructions(s)
	}
}

func (s *InstructionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitInstructions(s)
	}
}

func (p *ProjectParser) Instructions() (localctx IInstructionsContext) {
	localctx = NewInstructionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ProjectParserRULE_instructions)

	localctx.(*InstructionsContext).l = arrayList.New()

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(311)

				var _x = p.Instruction()

				localctx.(*InstructionsContext)._instruction = _x
			}
			localctx.(*InstructionsContext).e = append(localctx.(*InstructionsContext).e, localctx.(*InstructionsContext)._instruction)

		}
		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	listInt := localctx.(*InstructionsContext).GetE()
	for _, e := range listInt {
		localctx.(*InstructionsContext).l.Add(e.GetInstr())
	}
	fmt.Print("tipo %T", localctx.(*InstructionsContext).GetE())

	return localctx
}

// IInstructionContext is an interface to support dynamic dispatch.
type IInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_print_prod returns the _print_prod rule contexts.
	Get_print_prod() IPrint_prodContext

	// Get_declaration_prod returns the _declaration_prod rule contexts.
	Get_declaration_prod() IDeclaration_prodContext

	// Get_assign_prod returns the _assign_prod rule contexts.
	Get_assign_prod() IAssign_prodContext

	// Get_conditional_prod returns the _conditional_prod rule contexts.
	Get_conditional_prod() IConditional_prodContext

	// Get_bucle_prod returns the _bucle_prod rule contexts.
	Get_bucle_prod() IBucle_prodContext

	// Get_expr_rel returns the _expr_rel rule contexts.
	Get_expr_rel() IExpr_relContext

	// Get_expr_logic returns the _expr_logic rule contexts.
	Get_expr_logic() IExpr_logicContext

	// Get_dec_arr returns the _dec_arr rule contexts.
	Get_dec_arr() IDec_arrContext

	// Get_dec_struct returns the _dec_struct rule contexts.
	Get_dec_struct() IDec_structContext

	// Get_dec_object returns the _dec_object rule contexts.
	Get_dec_object() IDec_objectContext

	// Get_vector_instr returns the _vector_instr rule contexts.
	Get_vector_instr() IVector_instrContext

	// Get_transfer_prod returns the _transfer_prod rule contexts.
	Get_transfer_prod() ITransfer_prodContext

	// Set_print_prod sets the _print_prod rule contexts.
	Set_print_prod(IPrint_prodContext)

	// Set_declaration_prod sets the _declaration_prod rule contexts.
	Set_declaration_prod(IDeclaration_prodContext)

	// Set_assign_prod sets the _assign_prod rule contexts.
	Set_assign_prod(IAssign_prodContext)

	// Set_conditional_prod sets the _conditional_prod rule contexts.
	Set_conditional_prod(IConditional_prodContext)

	// Set_bucle_prod sets the _bucle_prod rule contexts.
	Set_bucle_prod(IBucle_prodContext)

	// Set_expr_rel sets the _expr_rel rule contexts.
	Set_expr_rel(IExpr_relContext)

	// Set_expr_logic sets the _expr_logic rule contexts.
	Set_expr_logic(IExpr_logicContext)

	// Set_dec_arr sets the _dec_arr rule contexts.
	Set_dec_arr(IDec_arrContext)

	// Set_dec_struct sets the _dec_struct rule contexts.
	Set_dec_struct(IDec_structContext)

	// Set_dec_object sets the _dec_object rule contexts.
	Set_dec_object(IDec_objectContext)

	// Set_vector_instr sets the _vector_instr rule contexts.
	Set_vector_instr(IVector_instrContext)

	// Set_transfer_prod sets the _transfer_prod rule contexts.
	Set_transfer_prod(ITransfer_prodContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsInstructionContext differentiates from other interfaces.
	IsInstructionContext()
}

type InstructionContext struct {
	*antlr.BaseParserRuleContext
	parser            antlr.Parser
	instr             Abstract.Instruction
	_print_prod       IPrint_prodContext
	_declaration_prod IDeclaration_prodContext
	_assign_prod      IAssign_prodContext
	_conditional_prod IConditional_prodContext
	_bucle_prod       IBucle_prodContext
	_expr_rel         IExpr_relContext
	_expr_logic       IExpr_logicContext
	_dec_arr          IDec_arrContext
	_dec_struct       IDec_structContext
	_dec_object       IDec_objectContext
	_vector_instr     IVector_instrContext
	_transfer_prod    ITransfer_prodContext
}

func NewEmptyInstructionContext() *InstructionContext {
	var p = new(InstructionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_instruction
	return p
}

func (*InstructionContext) IsInstructionContext() {}

func NewInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionContext {
	var p = new(InstructionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_instruction

	return p
}

func (s *InstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionContext) Get_print_prod() IPrint_prodContext { return s._print_prod }

func (s *InstructionContext) Get_declaration_prod() IDeclaration_prodContext {
	return s._declaration_prod
}

func (s *InstructionContext) Get_assign_prod() IAssign_prodContext { return s._assign_prod }

func (s *InstructionContext) Get_conditional_prod() IConditional_prodContext {
	return s._conditional_prod
}

func (s *InstructionContext) Get_bucle_prod() IBucle_prodContext { return s._bucle_prod }

func (s *InstructionContext) Get_expr_rel() IExpr_relContext { return s._expr_rel }

func (s *InstructionContext) Get_expr_logic() IExpr_logicContext { return s._expr_logic }

func (s *InstructionContext) Get_dec_arr() IDec_arrContext { return s._dec_arr }

func (s *InstructionContext) Get_dec_struct() IDec_structContext { return s._dec_struct }

func (s *InstructionContext) Get_dec_object() IDec_objectContext { return s._dec_object }

func (s *InstructionContext) Get_vector_instr() IVector_instrContext { return s._vector_instr }

func (s *InstructionContext) Get_transfer_prod() ITransfer_prodContext { return s._transfer_prod }

func (s *InstructionContext) Set_print_prod(v IPrint_prodContext) { s._print_prod = v }

func (s *InstructionContext) Set_declaration_prod(v IDeclaration_prodContext) {
	s._declaration_prod = v
}

func (s *InstructionContext) Set_assign_prod(v IAssign_prodContext) { s._assign_prod = v }

func (s *InstructionContext) Set_conditional_prod(v IConditional_prodContext) {
	s._conditional_prod = v
}

func (s *InstructionContext) Set_bucle_prod(v IBucle_prodContext) { s._bucle_prod = v }

func (s *InstructionContext) Set_expr_rel(v IExpr_relContext) { s._expr_rel = v }

func (s *InstructionContext) Set_expr_logic(v IExpr_logicContext) { s._expr_logic = v }

func (s *InstructionContext) Set_dec_arr(v IDec_arrContext) { s._dec_arr = v }

func (s *InstructionContext) Set_dec_struct(v IDec_structContext) { s._dec_struct = v }

func (s *InstructionContext) Set_dec_object(v IDec_objectContext) { s._dec_object = v }

func (s *InstructionContext) Set_vector_instr(v IVector_instrContext) { s._vector_instr = v }

func (s *InstructionContext) Set_transfer_prod(v ITransfer_prodContext) { s._transfer_prod = v }

func (s *InstructionContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *InstructionContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *InstructionContext) Print_prod() IPrint_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrint_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrint_prodContext)
}

func (s *InstructionContext) Declaration_prod() IDeclaration_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_prodContext)
}

func (s *InstructionContext) Assign_prod() IAssign_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssign_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssign_prodContext)
}

func (s *InstructionContext) Conditional_prod() IConditional_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_prodContext)
}

func (s *InstructionContext) Bucle_prod() IBucle_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBucle_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBucle_prodContext)
}

func (s *InstructionContext) Expr_rel() IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *InstructionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *InstructionContext) Expr_logic() IExpr_logicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_logicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_logicContext)
}

func (s *InstructionContext) Dec_arr() IDec_arrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDec_arrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDec_arrContext)
}

func (s *InstructionContext) Dec_struct() IDec_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDec_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDec_structContext)
}

func (s *InstructionContext) Dec_object() IDec_objectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDec_objectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDec_objectContext)
}

func (s *InstructionContext) Vector_instr() IVector_instrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVector_instrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVector_instrContext)
}

func (s *InstructionContext) Transfer_prod() ITransfer_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransfer_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransfer_prodContext)
}

func (s *InstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstructionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterInstruction(s)
	}
}

func (s *InstructionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitInstruction(s)
	}
}

func (p *ProjectParser) Instruction() (localctx IInstructionContext) {
	localctx = NewInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ProjectParserRULE_instruction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(319)

			var _x = p.Print_prod()

			localctx.(*InstructionContext)._print_prod = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_print_prod().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(322)

			var _x = p.Declaration_prod()

			localctx.(*InstructionContext)._declaration_prod = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_declaration_prod().GetInstr()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(325)

			var _x = p.Assign_prod()

			localctx.(*InstructionContext)._assign_prod = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_assign_prod().GetInstr()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(328)

			var _x = p.Conditional_prod()

			localctx.(*InstructionContext)._conditional_prod = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_conditional_prod().GetInstr()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(331)

			var _x = p.Bucle_prod()

			localctx.(*InstructionContext)._bucle_prod = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_bucle_prod().GetInstr()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(334)

			var _x = p.expr_rel(0)

			localctx.(*InstructionContext)._expr_rel = _x
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(335)
				p.Match(ProjectParserCOMMA)
			}

		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_expr_rel().GetInstr()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(340)

			var _x = p.expr_logic(0)

			localctx.(*InstructionContext)._expr_logic = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_expr_logic().GetInstr()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(343)

			var _x = p.Dec_arr()

			localctx.(*InstructionContext)._dec_arr = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_dec_arr().GetInstr()

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(346)

			var _x = p.Dec_struct()

			localctx.(*InstructionContext)._dec_struct = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_dec_struct().GetInstr()

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(349)

			var _x = p.Dec_object()

			localctx.(*InstructionContext)._dec_object = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_dec_object().GetInstr()

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(352)

			var _x = p.Vector_instr()

			localctx.(*InstructionContext)._vector_instr = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_vector_instr().GetInstr()

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(355)

			var _x = p.Transfer_prod()

			localctx.(*InstructionContext)._transfer_prod = _x
		}
		localctx.(*InstructionContext).instr = localctx.(*InstructionContext).Get_transfer_prod().GetInstr()

	}

	return localctx
}

// IPrint_prodContext is an interface to support dynamic dispatch.
type IPrint_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_LEFT_PAR returns the _LEFT_PAR token.
	Get_LEFT_PAR() antlr.Token

	// Set_LEFT_PAR sets the _LEFT_PAR token.
	Set_LEFT_PAR(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetOpBefore returns the opBefore rule contexts.
	GetOpBefore() IExpressionContext

	// Get_listVars returns the _listVars rule contexts.
	Get_listVars() IListVarsContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetOpBefore sets the opBefore rule contexts.
	SetOpBefore(IExpressionContext)

	// Set_listVars sets the _listVars rule contexts.
	Set_listVars(IListVarsContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsPrint_prodContext differentiates from other interfaces.
	IsPrint_prodContext()
}

type Print_prodContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_LEFT_PAR   antlr.Token
	_expression IExpressionContext
	opBefore    IExpressionContext
	_listVars   IListVarsContext
}

func NewEmptyPrint_prodContext() *Print_prodContext {
	var p = new(Print_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_print_prod
	return p
}

func (*Print_prodContext) IsPrint_prodContext() {}

func NewPrint_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Print_prodContext {
	var p = new(Print_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_print_prod

	return p
}

func (s *Print_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Print_prodContext) Get_LEFT_PAR() antlr.Token { return s._LEFT_PAR }

func (s *Print_prodContext) Set_LEFT_PAR(v antlr.Token) { s._LEFT_PAR = v }

func (s *Print_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *Print_prodContext) GetOpBefore() IExpressionContext { return s.opBefore }

func (s *Print_prodContext) Get_listVars() IListVarsContext { return s._listVars }

func (s *Print_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Print_prodContext) SetOpBefore(v IExpressionContext) { s.opBefore = v }

func (s *Print_prodContext) Set_listVars(v IListVarsContext) { s._listVars = v }

func (s *Print_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Print_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Print_prodContext) PRINT() antlr.TerminalNode {
	return s.GetToken(ProjectParserPRINT, 0)
}

func (s *Print_prodContext) ADMIRATION() antlr.TerminalNode {
	return s.GetToken(ProjectParserADMIRATION, 0)
}

func (s *Print_prodContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *Print_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Print_prodContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *Print_prodContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Print_prodContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ProjectParserCOMMA)
}

func (s *Print_prodContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, i)
}

func (s *Print_prodContext) ListVars() IListVarsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListVarsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListVarsContext)
}

func (s *Print_prodContext) PRINTLN() antlr.TerminalNode {
	return s.GetToken(ProjectParserPRINTLN, 0)
}

func (s *Print_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Print_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterPrint_prod(s)
	}
}

func (s *Print_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitPrint_prod(s)
	}
}

func (p *ProjectParser) Print_prod() (localctx IPrint_prodContext) {
	localctx = NewPrint_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ProjectParserRULE_print_prod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(360)
			p.Match(ProjectParserPRINT)
		}
		{
			p.SetState(361)
			p.Match(ProjectParserADMIRATION)
		}
		{
			p.SetState(362)

			var _m = p.Match(ProjectParserLEFT_PAR)

			localctx.(*Print_prodContext)._LEFT_PAR = _m
		}
		{
			p.SetState(363)

			var _x = p.Expression()

			localctx.(*Print_prodContext)._expression = _x
		}
		{
			p.SetState(364)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(365)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		localctx.(*Print_prodContext).instr = Natives.NewPrint(localctx.(*Print_prodContext).Get_expression().GetP(), false, (func() int {
			if localctx.(*Print_prodContext).Get_LEFT_PAR() == nil {
				return 0
			} else {
				return localctx.(*Print_prodContext).Get_LEFT_PAR().GetLine()
			}
		}()), localctx.(*Print_prodContext).Get_LEFT_PAR().GetColumn())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(368)
			p.Match(ProjectParserPRINT)
		}
		{
			p.SetState(369)
			p.Match(ProjectParserADMIRATION)
		}
		{
			p.SetState(370)

			var _m = p.Match(ProjectParserLEFT_PAR)

			localctx.(*Print_prodContext)._LEFT_PAR = _m
		}
		{
			p.SetState(371)

			var _x = p.Expression()

			localctx.(*Print_prodContext).opBefore = _x
		}
		{
			p.SetState(372)
			p.Match(ProjectParserCOMMA)
		}
		{
			p.SetState(373)

			var _x = p.listVars(0)

			localctx.(*Print_prodContext)._listVars = _x
		}
		{
			p.SetState(374)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(375)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		localctx.(*Print_prodContext).instr = Natives.NewPrintWithAfter(localctx.(*Print_prodContext).GetOpBefore().GetP(), localctx.(*Print_prodContext).Get_listVars().GetList(), false, (func() int {
			if localctx.(*Print_prodContext).Get_LEFT_PAR() == nil {
				return 0
			} else {
				return localctx.(*Print_prodContext).Get_LEFT_PAR().GetLine()
			}
		}()), localctx.(*Print_prodContext).Get_LEFT_PAR().GetColumn())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(378)
			p.Match(ProjectParserPRINTLN)
		}
		{
			p.SetState(379)
			p.Match(ProjectParserADMIRATION)
		}
		{
			p.SetState(380)

			var _m = p.Match(ProjectParserLEFT_PAR)

			localctx.(*Print_prodContext)._LEFT_PAR = _m
		}
		{
			p.SetState(381)

			var _x = p.Expression()

			localctx.(*Print_prodContext)._expression = _x
		}
		{
			p.SetState(382)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(383)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		localctx.(*Print_prodContext).instr = Natives.NewPrint(localctx.(*Print_prodContext).Get_expression().GetP(), true, (func() int {
			if localctx.(*Print_prodContext).Get_LEFT_PAR() == nil {
				return 0
			} else {
				return localctx.(*Print_prodContext).Get_LEFT_PAR().GetLine()
			}
		}()), localctx.(*Print_prodContext).Get_LEFT_PAR().GetColumn())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(386)
			p.Match(ProjectParserPRINTLN)
		}
		{
			p.SetState(387)
			p.Match(ProjectParserADMIRATION)
		}
		{
			p.SetState(388)

			var _m = p.Match(ProjectParserLEFT_PAR)

			localctx.(*Print_prodContext)._LEFT_PAR = _m
		}
		{
			p.SetState(389)

			var _x = p.Expression()

			localctx.(*Print_prodContext).opBefore = _x
		}
		{
			p.SetState(390)
			p.Match(ProjectParserCOMMA)
		}
		{
			p.SetState(391)

			var _x = p.listVars(0)

			localctx.(*Print_prodContext)._listVars = _x
		}
		{
			p.SetState(392)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(393)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		localctx.(*Print_prodContext).instr = Natives.NewPrintWithAfter(localctx.(*Print_prodContext).GetOpBefore().GetP(), localctx.(*Print_prodContext).Get_listVars().GetList(), true, (func() int {
			if localctx.(*Print_prodContext).Get_LEFT_PAR() == nil {
				return 0
			} else {
				return localctx.(*Print_prodContext).Get_LEFT_PAR().GetLine()
			}
		}()), localctx.(*Print_prodContext).Get_LEFT_PAR().GetColumn())

	}

	return localctx
}

// IListVarsContext is an interface to support dynamic dispatch.
type IListVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSub returns the sub rule contexts.
	GetSub() IListVarsContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetSub sets the sub rule contexts.
	SetSub(IListVarsContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetList returns the list attribute.
	GetList() *arrayList.List

	// SetList sets the list attribute.
	SetList(*arrayList.List)

	// IsListVarsContext differentiates from other interfaces.
	IsListVarsContext()
}

type ListVarsContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	list        *arrayList.List
	sub         IListVarsContext
	_expression IExpressionContext
}

func NewEmptyListVarsContext() *ListVarsContext {
	var p = new(ListVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listVars
	return p
}

func (*ListVarsContext) IsListVarsContext() {}

func NewListVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListVarsContext {
	var p = new(ListVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listVars

	return p
}

func (s *ListVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListVarsContext) GetSub() IListVarsContext { return s.sub }

func (s *ListVarsContext) Get_expression() IExpressionContext { return s._expression }

func (s *ListVarsContext) SetSub(v IListVarsContext) { s.sub = v }

func (s *ListVarsContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ListVarsContext) GetList() *arrayList.List { return s.list }

func (s *ListVarsContext) SetList(v *arrayList.List) { s.list = v }

func (s *ListVarsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListVarsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *ListVarsContext) ListVars() IListVarsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListVarsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListVarsContext)
}

func (s *ListVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListVarsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListVars(s)
	}
}

func (s *ListVarsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListVars(s)
	}
}

func (p *ProjectParser) ListVars() (localctx IListVarsContext) {
	return p.listVars(0)
}

func (p *ProjectParser) listVars(_p int) (localctx IListVarsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListVarsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListVarsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 30
	p.EnterRecursionRule(localctx, 30, ProjectParserRULE_listVars, _p)

	localctx.(*ListVarsContext).list = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)

		var _x = p.Expression()

		localctx.(*ListVarsContext)._expression = _x
	}

	localctx.(*ListVarsContext).list.Add(localctx.(*ListVarsContext).Get_expression().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListVarsContext(p, _parentctx, _parentState)
			localctx.(*ListVarsContext).sub = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listVars)
			p.SetState(402)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(403)
				p.Match(ProjectParserCOMMA)
			}
			{
				p.SetState(404)

				var _x = p.Expression()

				localctx.(*ListVarsContext)._expression = _x
			}

			localctx.(*ListVarsContext).GetSub().GetList().Add(localctx.(*ListVarsContext).Get_expression().GetP())
			localctx.(*ListVarsContext).list = localctx.(*ListVarsContext).GetSub().GetList()

		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclaration_prodContext is an interface to support dynamic dispatch.
type IDeclaration_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_MUT returns the _MUT token.
	Get_MUT() antlr.Token

	// Set_MUT sets the _MUT token.
	Set_MUT(antlr.Token)

	// Get_ids_type returns the _ids_type rule contexts.
	Get_ids_type() IIds_typeContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// Set_ids_type sets the _ids_type rule contexts.
	Set_ids_type(IIds_typeContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsDeclaration_prodContext differentiates from other interfaces.
	IsDeclaration_prodContext()
}

type Declaration_prodContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_MUT        antlr.Token
	_ids_type   IIds_typeContext
	_expression IExpressionContext
	_data_type  IData_typeContext
}

func NewEmptyDeclaration_prodContext() *Declaration_prodContext {
	var p = new(Declaration_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_declaration_prod
	return p
}

func (*Declaration_prodContext) IsDeclaration_prodContext() {}

func NewDeclaration_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_prodContext {
	var p = new(Declaration_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_declaration_prod

	return p
}

func (s *Declaration_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_prodContext) Get_MUT() antlr.Token { return s._MUT }

func (s *Declaration_prodContext) Set_MUT(v antlr.Token) { s._MUT = v }

func (s *Declaration_prodContext) Get_ids_type() IIds_typeContext { return s._ids_type }

func (s *Declaration_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *Declaration_prodContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *Declaration_prodContext) Set_ids_type(v IIds_typeContext) { s._ids_type = v }

func (s *Declaration_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Declaration_prodContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *Declaration_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Declaration_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Declaration_prodContext) DECLARAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserDECLARAR, 0)
}

func (s *Declaration_prodContext) Ids_type() IIds_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIds_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIds_typeContext)
}

func (s *Declaration_prodContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUAL, 0)
}

func (s *Declaration_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Declaration_prodContext) MUT() antlr.TerminalNode {
	return s.GetToken(ProjectParserMUT, 0)
}

func (s *Declaration_prodContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Declaration_prodContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Declaration_prodContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *Declaration_prodContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Declaration_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterDeclaration_prod(s)
	}
}

func (s *Declaration_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitDeclaration_prod(s)
	}
}

func (p *ProjectParser) Declaration_prod() (localctx IDeclaration_prodContext) {
	localctx = NewDeclaration_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ProjectParserRULE_declaration_prod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(412)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(413)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Declaration_prodContext)._MUT = _m
			}

		}
		{
			p.SetState(416)

			var _x = p.Ids_type()

			localctx.(*Declaration_prodContext)._ids_type = _x
		}
		{
			p.SetState(417)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(418)

			var _x = p.Expression()

			localctx.(*Declaration_prodContext)._expression = _x
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(419)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		if (func() string {
			if localctx.(*Declaration_prodContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Declaration_prodContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclarationInit(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), localctx.(*Declaration_prodContext).Get_expression().GetP(), true, "")
		} else {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclarationInit(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), localctx.(*Declaration_prodContext).Get_expression().GetP(), false, "")
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(424)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(425)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Declaration_prodContext)._MUT = _m
			}

		}
		{
			p.SetState(428)

			var _x = p.Ids_type()

			localctx.(*Declaration_prodContext)._ids_type = _x
		}
		{
			p.SetState(429)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(430)

			var _x = p.Data_type()

			localctx.(*Declaration_prodContext)._data_type = _x
		}
		{
			p.SetState(431)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(432)

			var _x = p.Expression()

			localctx.(*Declaration_prodContext)._expression = _x
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(433)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		if (func() string {
			if localctx.(*Declaration_prodContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Declaration_prodContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclarationInit(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), localctx.(*Declaration_prodContext).Get_expression().GetP(), true, localctx.(*Declaration_prodContext).Get_data_type().GetData())
		} else {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclarationInit(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), localctx.(*Declaration_prodContext).Get_expression().GetP(), false, localctx.(*Declaration_prodContext).Get_data_type().GetData())
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(438)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(439)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Declaration_prodContext)._MUT = _m
			}

		}
		{
			p.SetState(442)

			var _x = p.Ids_type()

			localctx.(*Declaration_prodContext)._ids_type = _x
		}
		p.SetState(444)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(443)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		if (func() string {
			if localctx.(*Declaration_prodContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Declaration_prodContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclaration(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), true, "")
		} else {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclaration(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), false, "")
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(448)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(449)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Declaration_prodContext)._MUT = _m
			}

		}
		{
			p.SetState(452)

			var _x = p.Ids_type()

			localctx.(*Declaration_prodContext)._ids_type = _x
		}
		{
			p.SetState(453)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(454)

			var _x = p.Data_type()

			localctx.(*Declaration_prodContext)._data_type = _x
		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(455)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		if (func() string {
			if localctx.(*Declaration_prodContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Declaration_prodContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclaration(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), true, localctx.(*Declaration_prodContext).Get_data_type().GetData())
		} else {
			localctx.(*Declaration_prodContext).instr = Natives.NewDeclaration(localctx.(*Declaration_prodContext).Get_ids_type().GetList(), false, localctx.(*Declaration_prodContext).Get_data_type().GetData())
		}

	}

	return localctx
}

// IAssign_prodContext is an interface to support dynamic dispatch.
type IAssign_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Get_EQUAL returns the _EQUAL token.
	Get_EQUAL() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Set_EQUAL sets the _EQUAL token.
	Set_EQUAL(antlr.Token)

	// Get_listIds returns the _listIds rule contexts.
	Get_listIds() IListIdsContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_listInArray returns the _listInArray rule contexts.
	Get_listInArray() IListInArrayContext

	// Get_access_object returns the _access_object rule contexts.
	Get_access_object() IAccess_objectContext

	// Set_listIds sets the _listIds rule contexts.
	Set_listIds(IListIdsContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_listInArray sets the _listInArray rule contexts.
	Set_listInArray(IListInArrayContext)

	// Set_access_object sets the _access_object rule contexts.
	Set_access_object(IAccess_objectContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsAssign_prodContext differentiates from other interfaces.
	IsAssign_prodContext()
}

type Assign_prodContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	instr          Abstract.Instruction
	_listIds       IListIdsContext
	_expression    IExpressionContext
	_ID            antlr.Token
	_listInArray   IListInArrayContext
	_EQUAL         antlr.Token
	_access_object IAccess_objectContext
}

func NewEmptyAssign_prodContext() *Assign_prodContext {
	var p = new(Assign_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_assign_prod
	return p
}

func (*Assign_prodContext) IsAssign_prodContext() {}

func NewAssign_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assign_prodContext {
	var p = new(Assign_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_assign_prod

	return p
}

func (s *Assign_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Assign_prodContext) Get_ID() antlr.Token { return s._ID }

func (s *Assign_prodContext) Get_EQUAL() antlr.Token { return s._EQUAL }

func (s *Assign_prodContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Assign_prodContext) Set_EQUAL(v antlr.Token) { s._EQUAL = v }

func (s *Assign_prodContext) Get_listIds() IListIdsContext { return s._listIds }

func (s *Assign_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *Assign_prodContext) Get_listInArray() IListInArrayContext { return s._listInArray }

func (s *Assign_prodContext) Get_access_object() IAccess_objectContext { return s._access_object }

func (s *Assign_prodContext) Set_listIds(v IListIdsContext) { s._listIds = v }

func (s *Assign_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Assign_prodContext) Set_listInArray(v IListInArrayContext) { s._listInArray = v }

func (s *Assign_prodContext) Set_access_object(v IAccess_objectContext) { s._access_object = v }

func (s *Assign_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Assign_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Assign_prodContext) ListIds() IListIdsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListIdsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListIdsContext)
}

func (s *Assign_prodContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUAL, 0)
}

func (s *Assign_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Assign_prodContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Assign_prodContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Assign_prodContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Assign_prodContext) ListInArray() IListInArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListInArrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListInArrayContext)
}

func (s *Assign_prodContext) Access_object() IAccess_objectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_objectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_objectContext)
}

func (s *Assign_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assign_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assign_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterAssign_prod(s)
	}
}

func (s *Assign_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitAssign_prod(s)
	}
}

func (p *ProjectParser) Assign_prod() (localctx IAssign_prodContext) {
	localctx = NewAssign_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ProjectParserRULE_assign_prod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(462)

			var _x = p.listIds(0)

			localctx.(*Assign_prodContext)._listIds = _x
		}
		{
			p.SetState(463)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(464)

			var _x = p.Expression()

			localctx.(*Assign_prodContext)._expression = _x
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(465)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		localctx.(*Assign_prodContext).instr = Natives.NewAssign(localctx.(*Assign_prodContext).Get_listIds().GetList(), localctx.(*Assign_prodContext).Get_expression().GetP())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(470)

			var _m = p.Match(ProjectParserID)

			localctx.(*Assign_prodContext)._ID = _m
		}
		{
			p.SetState(471)

			var _x = p.listInArray(0)

			localctx.(*Assign_prodContext)._listInArray = _x
		}
		{
			p.SetState(472)

			var _m = p.Match(ProjectParserEQUAL)

			localctx.(*Assign_prodContext)._EQUAL = _m
		}
		{
			p.SetState(473)

			var _x = p.Expression()

			localctx.(*Assign_prodContext)._expression = _x
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(474)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		localctx.(*Assign_prodContext).instr = DecArrays.NewAssignArray((func() string {
			if localctx.(*Assign_prodContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Assign_prodContext).Get_ID().GetText()
			}
		}()), localctx.(*Assign_prodContext).Get_listInArray().GetL(), localctx.(*Assign_prodContext).Get_expression().GetP(), (func() int {
			if localctx.(*Assign_prodContext).Get_EQUAL() == nil {
				return 0
			} else {
				return localctx.(*Assign_prodContext).Get_EQUAL().GetLine()
			}
		}()), localctx.(*Assign_prodContext).Get_EQUAL().GetColumn())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(479)

			var _x = p.Access_object()

			localctx.(*Assign_prodContext)._access_object = _x
		}
		{
			p.SetState(480)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(481)

			var _x = p.Expression()

			localctx.(*Assign_prodContext)._expression = _x
		}
		{
			p.SetState(482)
			p.Match(ProjectParserSEMICOLON)
		}

		localctx.(*Assign_prodContext).instr = DecObjects.NewAssignObject(localctx.(*Assign_prodContext).Get_access_object().GetP(), localctx.(*Assign_prodContext).Get_expression().GetP())

	}

	return localctx
}

// IIds_typeContext is an interface to support dynamic dispatch.
type IIds_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listIds returns the _listIds rule contexts.
	Get_listIds() IListIdsContext

	// Set_listIds sets the _listIds rule contexts.
	Set_listIds(IListIdsContext)

	// GetList returns the list attribute.
	GetList() *arrayList.List

	// SetList sets the list attribute.
	SetList(*arrayList.List)

	// IsIds_typeContext differentiates from other interfaces.
	IsIds_typeContext()
}

type Ids_typeContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	list     *arrayList.List
	_listIds IListIdsContext
}

func NewEmptyIds_typeContext() *Ids_typeContext {
	var p = new(Ids_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_ids_type
	return p
}

func (*Ids_typeContext) IsIds_typeContext() {}

func NewIds_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ids_typeContext {
	var p = new(Ids_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_ids_type

	return p
}

func (s *Ids_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Ids_typeContext) Get_listIds() IListIdsContext { return s._listIds }

func (s *Ids_typeContext) Set_listIds(v IListIdsContext) { s._listIds = v }

func (s *Ids_typeContext) GetList() *arrayList.List { return s.list }

func (s *Ids_typeContext) SetList(v *arrayList.List) { s.list = v }

func (s *Ids_typeContext) ListIds() IListIdsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListIdsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListIdsContext)
}

func (s *Ids_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *Ids_typeContext) RSTRING() antlr.TerminalNode {
	return s.GetToken(ProjectParserRSTRING, 0)
}

func (s *Ids_typeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(ProjectParserREFERENCE, 0)
}

func (s *Ids_typeContext) RSTR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRSTR, 0)
}

func (s *Ids_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ids_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ids_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterIds_type(s)
	}
}

func (s *Ids_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitIds_type(s)
	}
}

func (p *ProjectParser) Ids_type() (localctx IIds_typeContext) {
	localctx = NewIds_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ProjectParserRULE_ids_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)

			var _x = p.listIds(0)

			localctx.(*Ids_typeContext)._listIds = _x
		}
		localctx.(*Ids_typeContext).list = localctx.(*Ids_typeContext).Get_listIds().GetList()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(490)

			var _x = p.listIds(0)

			localctx.(*Ids_typeContext)._listIds = _x
		}
		{
			p.SetState(491)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(492)
			p.Match(ProjectParserRSTRING)
		}
		localctx.(*Ids_typeContext).list = localctx.(*Ids_typeContext).Get_listIds().GetList()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(495)

			var _x = p.listIds(0)

			localctx.(*Ids_typeContext)._listIds = _x
		}
		{
			p.SetState(496)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(497)
			p.Match(ProjectParserREFERENCE)
		}
		{
			p.SetState(498)
			p.Match(ProjectParserRSTR)
		}
		localctx.(*Ids_typeContext).list = localctx.(*Ids_typeContext).Get_listIds().GetList()

	}

	return localctx
}

// IListIdsContext is an interface to support dynamic dispatch.
type IListIdsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetSub returns the sub rule contexts.
	GetSub() IListIdsContext

	// SetSub sets the sub rule contexts.
	SetSub(IListIdsContext)

	// GetList returns the list attribute.
	GetList() *arrayList.List

	// SetList sets the list attribute.
	SetList(*arrayList.List)

	// IsListIdsContext differentiates from other interfaces.
	IsListIdsContext()
}

type ListIdsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	list   *arrayList.List
	sub    IListIdsContext
	_ID    antlr.Token
}

func NewEmptyListIdsContext() *ListIdsContext {
	var p = new(ListIdsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listIds
	return p
}

func (*ListIdsContext) IsListIdsContext() {}

func NewListIdsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListIdsContext {
	var p = new(ListIdsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listIds

	return p
}

func (s *ListIdsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListIdsContext) Get_ID() antlr.Token { return s._ID }

func (s *ListIdsContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ListIdsContext) GetSub() IListIdsContext { return s.sub }

func (s *ListIdsContext) SetSub(v IListIdsContext) { s.sub = v }

func (s *ListIdsContext) GetList() *arrayList.List { return s.list }

func (s *ListIdsContext) SetList(v *arrayList.List) { s.list = v }

func (s *ListIdsContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *ListIdsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *ListIdsContext) ListIds() IListIdsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListIdsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListIdsContext)
}

func (s *ListIdsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListIdsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListIdsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListIds(s)
	}
}

func (s *ListIdsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListIds(s)
	}
}

func (p *ProjectParser) ListIds() (localctx IListIdsContext) {
	return p.listIds(0)
}

func (p *ProjectParser) listIds(_p int) (localctx IListIdsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListIdsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListIdsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 38
	p.EnterRecursionRule(localctx, 38, ProjectParserRULE_listIds, _p)

	localctx.(*ListIdsContext).list = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)

		var _m = p.Match(ProjectParserID)

		localctx.(*ListIdsContext)._ID = _m
	}
	localctx.(*ListIdsContext).list.Add(Expression.NewIdentifier((func() string {
		if localctx.(*ListIdsContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*ListIdsContext).Get_ID().GetText()
		}
	}()), (func() int {
		if localctx.(*ListIdsContext).Get_ID() == nil {
			return 0
		} else {
			return localctx.(*ListIdsContext).Get_ID().GetLine()
		}
	}()), localctx.(*ListIdsContext).Get_ID().GetColumn()))

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListIdsContext(p, _parentctx, _parentState)
			localctx.(*ListIdsContext).sub = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listIds)
			p.SetState(507)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(508)
				p.Match(ProjectParserCOMMA)
			}
			{
				p.SetState(509)

				var _m = p.Match(ProjectParserID)

				localctx.(*ListIdsContext)._ID = _m
			}

			localctx.(*ListIdsContext).GetSub().GetList().Add(Expression.NewIdentifier((func() string {
				if localctx.(*ListIdsContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*ListIdsContext).Get_ID().GetText()
				}
			}()), (func() int {
				if localctx.(*ListIdsContext).Get_ID() == nil {
					return 0
				} else {
					return localctx.(*ListIdsContext).Get_ID().GetLine()
				}
			}()), localctx.(*ListIdsContext).Get_ID().GetColumn()))
			localctx.(*ListIdsContext).list = localctx.(*ListIdsContext).GetSub().GetList()

		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// IConditional_prodContext is an interface to support dynamic dispatch.
type IConditional_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_if_prod returns the _if_prod rule contexts.
	Get_if_prod() IIf_prodContext

	// Get_match_prod returns the _match_prod rule contexts.
	Get_match_prod() IMatch_prodContext

	// Set_if_prod sets the _if_prod rule contexts.
	Set_if_prod(IIf_prodContext)

	// Set_match_prod sets the _match_prod rule contexts.
	Set_match_prod(IMatch_prodContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsConditional_prodContext differentiates from other interfaces.
	IsConditional_prodContext()
}

type Conditional_prodContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	p           Abstract.Expression
	_if_prod    IIf_prodContext
	_match_prod IMatch_prodContext
}

func NewEmptyConditional_prodContext() *Conditional_prodContext {
	var p = new(Conditional_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_conditional_prod
	return p
}

func (*Conditional_prodContext) IsConditional_prodContext() {}

func NewConditional_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_prodContext {
	var p = new(Conditional_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_conditional_prod

	return p
}

func (s *Conditional_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_prodContext) Get_if_prod() IIf_prodContext { return s._if_prod }

func (s *Conditional_prodContext) Get_match_prod() IMatch_prodContext { return s._match_prod }

func (s *Conditional_prodContext) Set_if_prod(v IIf_prodContext) { s._if_prod = v }

func (s *Conditional_prodContext) Set_match_prod(v IMatch_prodContext) { s._match_prod = v }

func (s *Conditional_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Conditional_prodContext) GetP() Abstract.Expression { return s.p }

func (s *Conditional_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Conditional_prodContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Conditional_prodContext) If_prod() IIf_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_prodContext)
}

func (s *Conditional_prodContext) Match_prod() IMatch_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatch_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatch_prodContext)
}

func (s *Conditional_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterConditional_prod(s)
	}
}

func (s *Conditional_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitConditional_prod(s)
	}
}

func (p *ProjectParser) Conditional_prod() (localctx IConditional_prodContext) {
	localctx = NewConditional_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ProjectParserRULE_conditional_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(516)

			var _x = p.If_prod()

			localctx.(*Conditional_prodContext)._if_prod = _x
		}

		localctx.(*Conditional_prodContext).instr = localctx.(*Conditional_prodContext).Get_if_prod().GetInstr()
		localctx.(*Conditional_prodContext).p = localctx.(*Conditional_prodContext).Get_if_prod().GetP()

	case ProjectParserRMATCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(519)

			var _x = p.Match_prod()

			localctx.(*Conditional_prodContext)._match_prod = _x
		}

		localctx.(*Conditional_prodContext).instr = localctx.(*Conditional_prodContext).Get_match_prod().GetInstr()
		localctx.(*Conditional_prodContext).p = localctx.(*Conditional_prodContext).Get_match_prod().GetP()

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIf_prodContext is an interface to support dynamic dispatch.
type IIf_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RIF returns the _RIF token.
	Get_RIF() antlr.Token

	// Set_RIF sets the _RIF token.
	Set_RIF(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// GetBif returns the bif rule contexts.
	GetBif() IBloqContext

	// GetBelse returns the belse rule contexts.
	GetBelse() IBloqContext

	// Get_list_else_if returns the _list_else_if rule contexts.
	Get_list_else_if() IList_else_ifContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// SetBif sets the bif rule contexts.
	SetBif(IBloqContext)

	// SetBelse sets the belse rule contexts.
	SetBelse(IBloqContext)

	// Set_list_else_if sets the _list_else_if rule contexts.
	Set_list_else_if(IList_else_ifContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsIf_prodContext differentiates from other interfaces.
	IsIf_prodContext()
}

type If_prodContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	instr         Abstract.Instruction
	p             Abstract.Expression
	_RIF          antlr.Token
	_expression   IExpressionContext
	_bloq         IBloqContext
	bif           IBloqContext
	belse         IBloqContext
	_list_else_if IList_else_ifContext
}

func NewEmptyIf_prodContext() *If_prodContext {
	var p = new(If_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_if_prod
	return p
}

func (*If_prodContext) IsIf_prodContext() {}

func NewIf_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_prodContext {
	var p = new(If_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_if_prod

	return p
}

func (s *If_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *If_prodContext) Get_RIF() antlr.Token { return s._RIF }

func (s *If_prodContext) Set_RIF(v antlr.Token) { s._RIF = v }

func (s *If_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *If_prodContext) Get_bloq() IBloqContext { return s._bloq }

func (s *If_prodContext) GetBif() IBloqContext { return s.bif }

func (s *If_prodContext) GetBelse() IBloqContext { return s.belse }

func (s *If_prodContext) Get_list_else_if() IList_else_ifContext { return s._list_else_if }

func (s *If_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *If_prodContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *If_prodContext) SetBif(v IBloqContext) { s.bif = v }

func (s *If_prodContext) SetBelse(v IBloqContext) { s.belse = v }

func (s *If_prodContext) Set_list_else_if(v IList_else_ifContext) { s._list_else_if = v }

func (s *If_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *If_prodContext) GetP() Abstract.Expression { return s.p }

func (s *If_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *If_prodContext) SetP(v Abstract.Expression) { s.p = v }

func (s *If_prodContext) RIF() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIF, 0)
}

func (s *If_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_prodContext) AllBloq() []IBloqContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBloqContext)(nil)).Elem())
	var tst = make([]IBloqContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBloqContext)
		}
	}

	return tst
}

func (s *If_prodContext) Bloq(i int) IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *If_prodContext) RELSE() antlr.TerminalNode {
	return s.GetToken(ProjectParserRELSE, 0)
}

func (s *If_prodContext) List_else_if() IList_else_ifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_else_ifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_else_ifContext)
}

func (s *If_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterIf_prod(s)
	}
}

func (s *If_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitIf_prod(s)
	}
}

func (p *ProjectParser) If_prod() (localctx IIf_prodContext) {
	localctx = NewIf_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ProjectParserRULE_if_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(524)

			var _m = p.Match(ProjectParserRIF)

			localctx.(*If_prodContext)._RIF = _m
		}
		{
			p.SetState(525)

			var _x = p.Expression()

			localctx.(*If_prodContext)._expression = _x
		}
		{
			p.SetState(526)

			var _x = p.Bloq()

			localctx.(*If_prodContext)._bloq = _x
		}

		localctx.(*If_prodContext).instr = Natives.NewIf(localctx.(*If_prodContext).Get_expression().GetP(), localctx.(*If_prodContext).Get_bloq().GetContent(), nil, nil, (func() int {
			if localctx.(*If_prodContext).Get_RIF() == nil {
				return 0
			} else {
				return localctx.(*If_prodContext).Get_RIF().GetLine()
			}
		}()), localctx.(*If_prodContext).Get_RIF().GetColumn())
		localctx.(*If_prodContext).p = Natives.NewIf(localctx.(*If_prodContext).Get_expression().GetP(), localctx.(*If_prodContext).Get_bloq().GetContent(), nil, nil, (func() int {
			if localctx.(*If_prodContext).Get_RIF() == nil {
				return 0
			} else {
				return localctx.(*If_prodContext).Get_RIF().GetLine()
			}
		}()), localctx.(*If_prodContext).Get_RIF().GetColumn())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(529)

			var _m = p.Match(ProjectParserRIF)

			localctx.(*If_prodContext)._RIF = _m
		}
		{
			p.SetState(530)

			var _x = p.Expression()

			localctx.(*If_prodContext)._expression = _x
		}
		{
			p.SetState(531)

			var _x = p.Bloq()

			localctx.(*If_prodContext).bif = _x
		}
		{
			p.SetState(532)
			p.Match(ProjectParserRELSE)
		}
		{
			p.SetState(533)

			var _x = p.Bloq()

			localctx.(*If_prodContext).belse = _x
		}

		localctx.(*If_prodContext).instr = Natives.NewIf(localctx.(*If_prodContext).Get_expression().GetP(), localctx.(*If_prodContext).GetBif().GetContent(), nil, localctx.(*If_prodContext).GetBelse().GetContent(), (func() int {
			if localctx.(*If_prodContext).Get_RIF() == nil {
				return 0
			} else {
				return localctx.(*If_prodContext).Get_RIF().GetLine()
			}
		}()), localctx.(*If_prodContext).Get_RIF().GetColumn())
		localctx.(*If_prodContext).p = Natives.NewIf(localctx.(*If_prodContext).Get_expression().GetP(), localctx.(*If_prodContext).GetBif().GetContent(), nil, localctx.(*If_prodContext).GetBelse().GetContent(), (func() int {
			if localctx.(*If_prodContext).Get_RIF() == nil {
				return 0
			} else {
				return localctx.(*If_prodContext).Get_RIF().GetLine()
			}
		}()), localctx.(*If_prodContext).Get_RIF().GetColumn())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(536)

			var _m = p.Match(ProjectParserRIF)

			localctx.(*If_prodContext)._RIF = _m
		}
		{
			p.SetState(537)

			var _x = p.Expression()

			localctx.(*If_prodContext)._expression = _x
		}
		{
			p.SetState(538)

			var _x = p.Bloq()

			localctx.(*If_prodContext).bif = _x
		}
		{
			p.SetState(539)
			p.Match(ProjectParserRELSE)
		}
		{
			p.SetState(540)

			var _x = p.List_else_if()

			localctx.(*If_prodContext)._list_else_if = _x
		}

		localctx.(*If_prodContext).instr = Natives.NewIf(localctx.(*If_prodContext).Get_expression().GetP(), localctx.(*If_prodContext).GetBif().GetContent(), localctx.(*If_prodContext).Get_list_else_if().GetList(), nil, (func() int {
			if localctx.(*If_prodContext).Get_RIF() == nil {
				return 0
			} else {
				return localctx.(*If_prodContext).Get_RIF().GetLine()
			}
		}()), localctx.(*If_prodContext).Get_RIF().GetColumn())
		localctx.(*If_prodContext).p = Natives.NewIf(localctx.(*If_prodContext).Get_expression().GetP(), localctx.(*If_prodContext).GetBif().GetContent(), localctx.(*If_prodContext).Get_list_else_if().GetList(), nil, (func() int {
			if localctx.(*If_prodContext).Get_RIF() == nil {
				return 0
			} else {
				return localctx.(*If_prodContext).Get_RIF().GetLine()
			}
		}()), localctx.(*If_prodContext).Get_RIF().GetColumn())

	}

	return localctx
}

// IList_else_ifContext is an interface to support dynamic dispatch.
type IList_else_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_if_prod returns the _if_prod rule contexts.
	Get_if_prod() IIf_prodContext

	// Set_if_prod sets the _if_prod rule contexts.
	Set_if_prod(IIf_prodContext)

	// GetList returns the list attribute.
	GetList() *arrayList.List

	// SetList sets the list attribute.
	SetList(*arrayList.List)

	// IsList_else_ifContext differentiates from other interfaces.
	IsList_else_ifContext()
}

type List_else_ifContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	list     *arrayList.List
	_if_prod IIf_prodContext
}

func NewEmptyList_else_ifContext() *List_else_ifContext {
	var p = new(List_else_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_list_else_if
	return p
}

func (*List_else_ifContext) IsList_else_ifContext() {}

func NewList_else_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_else_ifContext {
	var p = new(List_else_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_list_else_if

	return p
}

func (s *List_else_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *List_else_ifContext) Get_if_prod() IIf_prodContext { return s._if_prod }

func (s *List_else_ifContext) Set_if_prod(v IIf_prodContext) { s._if_prod = v }

func (s *List_else_ifContext) GetList() *arrayList.List { return s.list }

func (s *List_else_ifContext) SetList(v *arrayList.List) { s.list = v }

func (s *List_else_ifContext) If_prod() IIf_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_prodContext)
}

func (s *List_else_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_else_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_else_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterList_else_if(s)
	}
}

func (s *List_else_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitList_else_if(s)
	}
}

func (p *ProjectParser) List_else_if() (localctx IList_else_ifContext) {
	localctx = NewList_else_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ProjectParserRULE_list_else_if)

	localctx.(*List_else_ifContext).list = arrayList.New()

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)

		var _x = p.If_prod()

		localctx.(*List_else_ifContext)._if_prod = _x
	}

	localctx.(*List_else_ifContext).list.Add(localctx.(*List_else_ifContext).Get_if_prod().GetInstr())

	return localctx
}

// IElse_ifContext is an interface to support dynamic dispatch.
type IElse_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RIF returns the _RIF token.
	Get_RIF() antlr.Token

	// Set_RIF sets the _RIF token.
	Set_RIF(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsElse_ifContext differentiates from other interfaces.
	IsElse_ifContext()
}

type Else_ifContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_RIF        antlr.Token
	_expression IExpressionContext
	_bloq       IBloqContext
}

func NewEmptyElse_ifContext() *Else_ifContext {
	var p = new(Else_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_else_if
	return p
}

func (*Else_ifContext) IsElse_ifContext() {}

func NewElse_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_ifContext {
	var p = new(Else_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_else_if

	return p
}

func (s *Else_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_ifContext) Get_RIF() antlr.Token { return s._RIF }

func (s *Else_ifContext) Set_RIF(v antlr.Token) { s._RIF = v }

func (s *Else_ifContext) Get_expression() IExpressionContext { return s._expression }

func (s *Else_ifContext) Get_bloq() IBloqContext { return s._bloq }

func (s *Else_ifContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Else_ifContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *Else_ifContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Else_ifContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Else_ifContext) RELSE() antlr.TerminalNode {
	return s.GetToken(ProjectParserRELSE, 0)
}

func (s *Else_ifContext) RIF() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIF, 0)
}

func (s *Else_ifContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Else_ifContext) Bloq() IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *Else_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterElse_if(s)
	}
}

func (s *Else_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitElse_if(s)
	}
}

func (p *ProjectParser) Else_if() (localctx IElse_ifContext) {
	localctx = NewElse_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ProjectParserRULE_else_if)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Match(ProjectParserRELSE)
	}
	{
		p.SetState(549)

		var _m = p.Match(ProjectParserRIF)

		localctx.(*Else_ifContext)._RIF = _m
	}
	{
		p.SetState(550)

		var _x = p.Expression()

		localctx.(*Else_ifContext)._expression = _x
	}
	{
		p.SetState(551)

		var _x = p.Bloq()

		localctx.(*Else_ifContext)._bloq = _x
	}
	localctx.(*Else_ifContext).instr = Natives.NewIf(localctx.(*Else_ifContext).Get_expression().GetP(), localctx.(*Else_ifContext).Get_bloq().GetContent(), nil, nil, (func() int {
		if localctx.(*Else_ifContext).Get_RIF() == nil {
			return 0
		} else {
			return localctx.(*Else_ifContext).Get_RIF().GetLine()
		}
	}()), localctx.(*Else_ifContext).Get_RIF().GetColumn())

	return localctx
}

// IMatch_prodContext is an interface to support dynamic dispatch.
type IMatch_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_list_instr_match returns the _list_instr_match rule contexts.
	Get_list_instr_match() IList_instr_matchContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_list_instr_match sets the _list_instr_match rule contexts.
	Set_list_instr_match(IList_instr_matchContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsMatch_prodContext differentiates from other interfaces.
	IsMatch_prodContext()
}

type Match_prodContext struct {
	*antlr.BaseParserRuleContext
	parser            antlr.Parser
	instr             Abstract.Instruction
	p                 Abstract.Expression
	_expression       IExpressionContext
	_list_instr_match IList_instr_matchContext
}

func NewEmptyMatch_prodContext() *Match_prodContext {
	var p = new(Match_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_match_prod
	return p
}

func (*Match_prodContext) IsMatch_prodContext() {}

func NewMatch_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_prodContext {
	var p = new(Match_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_match_prod

	return p
}

func (s *Match_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *Match_prodContext) Get_list_instr_match() IList_instr_matchContext {
	return s._list_instr_match
}

func (s *Match_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Match_prodContext) Set_list_instr_match(v IList_instr_matchContext) { s._list_instr_match = v }

func (s *Match_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Match_prodContext) GetP() Abstract.Expression { return s.p }

func (s *Match_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Match_prodContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Match_prodContext) RMATCH() antlr.TerminalNode {
	return s.GetToken(ProjectParserRMATCH, 0)
}

func (s *Match_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Match_prodContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *Match_prodContext) List_instr_match() IList_instr_matchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_instr_matchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_instr_matchContext)
}

func (s *Match_prodContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *Match_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterMatch_prod(s)
	}
}

func (s *Match_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitMatch_prod(s)
	}
}

func (p *ProjectParser) Match_prod() (localctx IMatch_prodContext) {
	localctx = NewMatch_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ProjectParserRULE_match_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(ProjectParserRMATCH)
	}
	{
		p.SetState(555)

		var _x = p.Expression()

		localctx.(*Match_prodContext)._expression = _x
	}
	{
		p.SetState(556)
		p.Match(ProjectParserLEFT_KEY)
	}
	{
		p.SetState(557)

		var _x = p.list_instr_match(0)

		localctx.(*Match_prodContext)._list_instr_match = _x
	}
	{
		p.SetState(558)
		p.Match(ProjectParserRIGHT_KEY)
	}

	localctx.(*Match_prodContext).instr = Natives.NewMatch(localctx.(*Match_prodContext).Get_expression().GetP(), localctx.(*Match_prodContext).Get_list_instr_match().GetList())
	localctx.(*Match_prodContext).p = Natives.NewMatch(localctx.(*Match_prodContext).Get_expression().GetP(), localctx.(*Match_prodContext).Get_list_instr_match().GetList())

	return localctx
}

// IList_instr_matchContext is an interface to support dynamic dispatch.
type IList_instr_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSub returns the sub rule contexts.
	GetSub() IList_instr_matchContext

	// Get_instr_match returns the _instr_match rule contexts.
	Get_instr_match() IInstr_matchContext

	// SetSub sets the sub rule contexts.
	SetSub(IList_instr_matchContext)

	// Set_instr_match sets the _instr_match rule contexts.
	Set_instr_match(IInstr_matchContext)

	// GetList returns the list attribute.
	GetList() *arrayList.List

	// SetList sets the list attribute.
	SetList(*arrayList.List)

	// IsList_instr_matchContext differentiates from other interfaces.
	IsList_instr_matchContext()
}

type List_instr_matchContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	list         *arrayList.List
	sub          IList_instr_matchContext
	_instr_match IInstr_matchContext
}

func NewEmptyList_instr_matchContext() *List_instr_matchContext {
	var p = new(List_instr_matchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_list_instr_match
	return p
}

func (*List_instr_matchContext) IsList_instr_matchContext() {}

func NewList_instr_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_instr_matchContext {
	var p = new(List_instr_matchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_list_instr_match

	return p
}

func (s *List_instr_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *List_instr_matchContext) GetSub() IList_instr_matchContext { return s.sub }

func (s *List_instr_matchContext) Get_instr_match() IInstr_matchContext { return s._instr_match }

func (s *List_instr_matchContext) SetSub(v IList_instr_matchContext) { s.sub = v }

func (s *List_instr_matchContext) Set_instr_match(v IInstr_matchContext) { s._instr_match = v }

func (s *List_instr_matchContext) GetList() *arrayList.List { return s.list }

func (s *List_instr_matchContext) SetList(v *arrayList.List) { s.list = v }

func (s *List_instr_matchContext) Instr_match() IInstr_matchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstr_matchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstr_matchContext)
}

func (s *List_instr_matchContext) List_instr_match() IList_instr_matchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_instr_matchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_instr_matchContext)
}

func (s *List_instr_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_instr_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_instr_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterList_instr_match(s)
	}
}

func (s *List_instr_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitList_instr_match(s)
	}
}

func (p *ProjectParser) List_instr_match() (localctx IList_instr_matchContext) {
	return p.list_instr_match(0)
}

func (p *ProjectParser) list_instr_match(_p int) (localctx IList_instr_matchContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewList_instr_matchContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IList_instr_matchContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, ProjectParserRULE_list_instr_match, _p)

	localctx.(*List_instr_matchContext).list = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)

		var _x = p.Instr_match()

		localctx.(*List_instr_matchContext)._instr_match = _x
	}
	localctx.(*List_instr_matchContext).list.Add(localctx.(*List_instr_matchContext).Get_instr_match().GetInstr())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewList_instr_matchContext(p, _parentctx, _parentState)
			localctx.(*List_instr_matchContext).sub = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_list_instr_match)
			p.SetState(565)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(566)

				var _x = p.Instr_match()

				localctx.(*List_instr_matchContext)._instr_match = _x
			}

			localctx.(*List_instr_matchContext).GetSub().GetList().Add(localctx.(*List_instr_matchContext).Get_instr_match().GetInstr())
			localctx.(*List_instr_matchContext).list = localctx.(*List_instr_matchContext).GetSub().GetList()

		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}

	return localctx
}

// IInstr_matchContext is an interface to support dynamic dispatch.
type IInstr_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_EQUAL_ARROW returns the _EQUAL_ARROW token.
	Get_EQUAL_ARROW() antlr.Token

	// Set_EQUAL_ARROW sets the _EQUAL_ARROW token.
	Set_EQUAL_ARROW(antlr.Token)

	// Get_expr_match returns the _expr_match rule contexts.
	Get_expr_match() IExpr_matchContext

	// Get_bloq_match returns the _bloq_match rule contexts.
	Get_bloq_match() IBloq_matchContext

	// Set_expr_match sets the _expr_match rule contexts.
	Set_expr_match(IExpr_matchContext)

	// Set_bloq_match sets the _bloq_match rule contexts.
	Set_bloq_match(IBloq_matchContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsInstr_matchContext differentiates from other interfaces.
	IsInstr_matchContext()
}

type Instr_matchContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	instr        Abstract.Instruction
	_expr_match  IExpr_matchContext
	_EQUAL_ARROW antlr.Token
	_bloq_match  IBloq_matchContext
}

func NewEmptyInstr_matchContext() *Instr_matchContext {
	var p = new(Instr_matchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_instr_match
	return p
}

func (*Instr_matchContext) IsInstr_matchContext() {}

func NewInstr_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instr_matchContext {
	var p = new(Instr_matchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_instr_match

	return p
}

func (s *Instr_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *Instr_matchContext) Get_EQUAL_ARROW() antlr.Token { return s._EQUAL_ARROW }

func (s *Instr_matchContext) Set_EQUAL_ARROW(v antlr.Token) { s._EQUAL_ARROW = v }

func (s *Instr_matchContext) Get_expr_match() IExpr_matchContext { return s._expr_match }

func (s *Instr_matchContext) Get_bloq_match() IBloq_matchContext { return s._bloq_match }

func (s *Instr_matchContext) Set_expr_match(v IExpr_matchContext) { s._expr_match = v }

func (s *Instr_matchContext) Set_bloq_match(v IBloq_matchContext) { s._bloq_match = v }

func (s *Instr_matchContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Instr_matchContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Instr_matchContext) Expr_match() IExpr_matchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchContext)
}

func (s *Instr_matchContext) EQUAL_ARROW() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUAL_ARROW, 0)
}

func (s *Instr_matchContext) Bloq_match() IBloq_matchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloq_matchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloq_matchContext)
}

func (s *Instr_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instr_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instr_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterInstr_match(s)
	}
}

func (s *Instr_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitInstr_match(s)
	}
}

func (p *ProjectParser) Instr_match() (localctx IInstr_matchContext) {
	localctx = NewInstr_matchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ProjectParserRULE_instr_match)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)

		var _x = p.expr_match(0)

		localctx.(*Instr_matchContext)._expr_match = _x
	}
	{
		p.SetState(575)

		var _m = p.Match(ProjectParserEQUAL_ARROW)

		localctx.(*Instr_matchContext)._EQUAL_ARROW = _m
	}
	{
		p.SetState(576)

		var _x = p.Bloq_match()

		localctx.(*Instr_matchContext)._bloq_match = _x
	}

	localctx.(*Instr_matchContext).instr = Natives.NewCase(localctx.(*Instr_matchContext).Get_expr_match().GetList(), localctx.(*Instr_matchContext).Get_bloq_match().GetContent(), (func() int {
		if localctx.(*Instr_matchContext).Get_EQUAL_ARROW() == nil {
			return 0
		} else {
			return localctx.(*Instr_matchContext).Get_EQUAL_ARROW().GetLine()
		}
	}()), localctx.(*Instr_matchContext).Get_EQUAL_ARROW().GetColumn())

	return localctx
}

// IExpr_matchContext is an interface to support dynamic dispatch.
type IExpr_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSub returns the sub rule contexts.
	GetSub() IExpr_matchContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetSub sets the sub rule contexts.
	SetSub(IExpr_matchContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetList returns the list attribute.
	GetList() *arrayList.List

	// SetList sets the list attribute.
	SetList(*arrayList.List)

	// IsExpr_matchContext differentiates from other interfaces.
	IsExpr_matchContext()
}

type Expr_matchContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	list        *arrayList.List
	sub         IExpr_matchContext
	_expression IExpressionContext
}

func NewEmptyExpr_matchContext() *Expr_matchContext {
	var p = new(Expr_matchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_match
	return p
}

func (*Expr_matchContext) IsExpr_matchContext() {}

func NewExpr_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_matchContext {
	var p = new(Expr_matchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_match

	return p
}

func (s *Expr_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_matchContext) GetSub() IExpr_matchContext { return s.sub }

func (s *Expr_matchContext) Get_expression() IExpressionContext { return s._expression }

func (s *Expr_matchContext) SetSub(v IExpr_matchContext) { s.sub = v }

func (s *Expr_matchContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Expr_matchContext) GetList() *arrayList.List { return s.list }

func (s *Expr_matchContext) SetList(v *arrayList.List) { s.list = v }

func (s *Expr_matchContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_matchContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ProjectParserPIPE, 0)
}

func (s *Expr_matchContext) Expr_match() IExpr_matchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchContext)
}

func (s *Expr_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_match(s)
	}
}

func (s *Expr_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_match(s)
	}
}

func (p *ProjectParser) Expr_match() (localctx IExpr_matchContext) {
	return p.expr_match(0)
}

func (p *ProjectParser) expr_match(_p int) (localctx IExpr_matchContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpr_matchContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpr_matchContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 54
	p.EnterRecursionRule(localctx, 54, ProjectParserRULE_expr_match, _p)

	localctx.(*Expr_matchContext).list = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)

		var _x = p.Expression()

		localctx.(*Expr_matchContext)._expression = _x
	}

	localctx.(*Expr_matchContext).list.Add(localctx.(*Expr_matchContext).Get_expression().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpr_matchContext(p, _parentctx, _parentState)
			localctx.(*Expr_matchContext).sub = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_expr_match)
			p.SetState(583)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(584)
				p.Match(ProjectParserPIPE)
			}
			{
				p.SetState(585)

				var _x = p.Expression()

				localctx.(*Expr_matchContext)._expression = _x
			}

			localctx.(*Expr_matchContext).GetSub().GetList().Add(localctx.(*Expr_matchContext).Get_expression().GetP())
			localctx.(*Expr_matchContext).list = localctx.(*Expr_matchContext).GetSub().GetList()

		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}

	return localctx
}

// IBucle_prodContext is an interface to support dynamic dispatch.
type IBucle_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_while_prod returns the _while_prod rule contexts.
	Get_while_prod() IWhile_prodContext

	// Get_loop_prod returns the _loop_prod rule contexts.
	Get_loop_prod() ILoop_prodContext

	// Get_forin_prod returns the _forin_prod rule contexts.
	Get_forin_prod() IForin_prodContext

	// Set_while_prod sets the _while_prod rule contexts.
	Set_while_prod(IWhile_prodContext)

	// Set_loop_prod sets the _loop_prod rule contexts.
	Set_loop_prod(ILoop_prodContext)

	// Set_forin_prod sets the _forin_prod rule contexts.
	Set_forin_prod(IForin_prodContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsBucle_prodContext differentiates from other interfaces.
	IsBucle_prodContext()
}

type Bucle_prodContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_while_prod IWhile_prodContext
	_loop_prod  ILoop_prodContext
	_forin_prod IForin_prodContext
}

func NewEmptyBucle_prodContext() *Bucle_prodContext {
	var p = new(Bucle_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_bucle_prod
	return p
}

func (*Bucle_prodContext) IsBucle_prodContext() {}

func NewBucle_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bucle_prodContext {
	var p = new(Bucle_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_bucle_prod

	return p
}

func (s *Bucle_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Bucle_prodContext) Get_while_prod() IWhile_prodContext { return s._while_prod }

func (s *Bucle_prodContext) Get_loop_prod() ILoop_prodContext { return s._loop_prod }

func (s *Bucle_prodContext) Get_forin_prod() IForin_prodContext { return s._forin_prod }

func (s *Bucle_prodContext) Set_while_prod(v IWhile_prodContext) { s._while_prod = v }

func (s *Bucle_prodContext) Set_loop_prod(v ILoop_prodContext) { s._loop_prod = v }

func (s *Bucle_prodContext) Set_forin_prod(v IForin_prodContext) { s._forin_prod = v }

func (s *Bucle_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Bucle_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Bucle_prodContext) While_prod() IWhile_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_prodContext)
}

func (s *Bucle_prodContext) Loop_prod() ILoop_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_prodContext)
}

func (s *Bucle_prodContext) Forin_prod() IForin_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForin_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForin_prodContext)
}

func (s *Bucle_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bucle_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bucle_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterBucle_prod(s)
	}
}

func (s *Bucle_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitBucle_prod(s)
	}
}

func (p *ProjectParser) Bucle_prod() (localctx IBucle_prodContext) {
	localctx = NewBucle_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ProjectParserRULE_bucle_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(602)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(593)

			var _x = p.While_prod()

			localctx.(*Bucle_prodContext)._while_prod = _x
		}
		localctx.(*Bucle_prodContext).instr = localctx.(*Bucle_prodContext).Get_while_prod().GetInstr()

	case ProjectParserRLOOP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(596)

			var _x = p.Loop_prod()

			localctx.(*Bucle_prodContext)._loop_prod = _x
		}
		localctx.(*Bucle_prodContext).instr = localctx.(*Bucle_prodContext).Get_loop_prod().GetInstr()

	case ProjectParserRFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(599)

			var _x = p.Forin_prod()

			localctx.(*Bucle_prodContext)._forin_prod = _x
		}
		localctx.(*Bucle_prodContext).instr = localctx.(*Bucle_prodContext).Get_forin_prod().GetInstr()

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhile_prodContext is an interface to support dynamic dispatch.
type IWhile_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RWHILE returns the _RWHILE token.
	Get_RWHILE() antlr.Token

	// Set_RWHILE sets the _RWHILE token.
	Set_RWHILE(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsWhile_prodContext differentiates from other interfaces.
	IsWhile_prodContext()
}

type While_prodContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_RWHILE     antlr.Token
	_expression IExpressionContext
	_bloq       IBloqContext
}

func NewEmptyWhile_prodContext() *While_prodContext {
	var p = new(While_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_while_prod
	return p
}

func (*While_prodContext) IsWhile_prodContext() {}

func NewWhile_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_prodContext {
	var p = new(While_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_while_prod

	return p
}

func (s *While_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *While_prodContext) Get_RWHILE() antlr.Token { return s._RWHILE }

func (s *While_prodContext) Set_RWHILE(v antlr.Token) { s._RWHILE = v }

func (s *While_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *While_prodContext) Get_bloq() IBloqContext { return s._bloq }

func (s *While_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *While_prodContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *While_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *While_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *While_prodContext) RWHILE() antlr.TerminalNode {
	return s.GetToken(ProjectParserRWHILE, 0)
}

func (s *While_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *While_prodContext) Bloq() IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *While_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterWhile_prod(s)
	}
}

func (s *While_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitWhile_prod(s)
	}
}

func (p *ProjectParser) While_prod() (localctx IWhile_prodContext) {
	localctx = NewWhile_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ProjectParserRULE_while_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)

		var _m = p.Match(ProjectParserRWHILE)

		localctx.(*While_prodContext)._RWHILE = _m
	}
	{
		p.SetState(605)

		var _x = p.Expression()

		localctx.(*While_prodContext)._expression = _x
	}
	{
		p.SetState(606)

		var _x = p.Bloq()

		localctx.(*While_prodContext)._bloq = _x
	}
	localctx.(*While_prodContext).instr = Natives.NewWhile(localctx.(*While_prodContext).Get_expression().GetP(), localctx.(*While_prodContext).Get_bloq().GetContent(), (func() int {
		if localctx.(*While_prodContext).Get_RWHILE() == nil {
			return 0
		} else {
			return localctx.(*While_prodContext).Get_RWHILE().GetLine()
		}
	}()), localctx.(*While_prodContext).Get_RWHILE().GetColumn())

	return localctx
}

// ILoop_prodContext is an interface to support dynamic dispatch.
type ILoop_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsLoop_prodContext differentiates from other interfaces.
	IsLoop_prodContext()
}

type Loop_prodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	instr  Abstract.Instruction
	p      Abstract.Expression
	_bloq  IBloqContext
}

func NewEmptyLoop_prodContext() *Loop_prodContext {
	var p = new(Loop_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_loop_prod
	return p
}

func (*Loop_prodContext) IsLoop_prodContext() {}

func NewLoop_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_prodContext {
	var p = new(Loop_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_loop_prod

	return p
}

func (s *Loop_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_prodContext) Get_bloq() IBloqContext { return s._bloq }

func (s *Loop_prodContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *Loop_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Loop_prodContext) GetP() Abstract.Expression { return s.p }

func (s *Loop_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Loop_prodContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Loop_prodContext) RLOOP() antlr.TerminalNode {
	return s.GetToken(ProjectParserRLOOP, 0)
}

func (s *Loop_prodContext) Bloq() IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *Loop_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterLoop_prod(s)
	}
}

func (s *Loop_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitLoop_prod(s)
	}
}

func (p *ProjectParser) Loop_prod() (localctx ILoop_prodContext) {
	localctx = NewLoop_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ProjectParserRULE_loop_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		p.Match(ProjectParserRLOOP)
	}
	{
		p.SetState(610)

		var _x = p.Bloq()

		localctx.(*Loop_prodContext)._bloq = _x
	}

	localctx.(*Loop_prodContext).instr = Natives.NewLoop(localctx.(*Loop_prodContext).Get_bloq().GetContent())
	localctx.(*Loop_prodContext).p = Natives.NewLoop(localctx.(*Loop_prodContext).Get_bloq().GetContent())

	return localctx
}

// IForin_prodContext is an interface to support dynamic dispatch.
type IForin_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_range_prod returns the _range_prod rule contexts.
	Get_range_prod() IRange_prodContext

	// Get_bloq returns the _bloq rule contexts.
	Get_bloq() IBloqContext

	// Get_arraydata returns the _arraydata rule contexts.
	Get_arraydata() IArraydataContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_range_prod sets the _range_prod rule contexts.
	Set_range_prod(IRange_prodContext)

	// Set_bloq sets the _bloq rule contexts.
	Set_bloq(IBloqContext)

	// Set_arraydata sets the _arraydata rule contexts.
	Set_arraydata(IArraydataContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsForin_prodContext differentiates from other interfaces.
	IsForin_prodContext()
}

type Forin_prodContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_expression IExpressionContext
	_range_prod IRange_prodContext
	_bloq       IBloqContext
	_arraydata  IArraydataContext
}

func NewEmptyForin_prodContext() *Forin_prodContext {
	var p = new(Forin_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_forin_prod
	return p
}

func (*Forin_prodContext) IsForin_prodContext() {}

func NewForin_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forin_prodContext {
	var p = new(Forin_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_forin_prod

	return p
}

func (s *Forin_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Forin_prodContext) Get_expression() IExpressionContext { return s._expression }

func (s *Forin_prodContext) Get_range_prod() IRange_prodContext { return s._range_prod }

func (s *Forin_prodContext) Get_bloq() IBloqContext { return s._bloq }

func (s *Forin_prodContext) Get_arraydata() IArraydataContext { return s._arraydata }

func (s *Forin_prodContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Forin_prodContext) Set_range_prod(v IRange_prodContext) { s._range_prod = v }

func (s *Forin_prodContext) Set_bloq(v IBloqContext) { s._bloq = v }

func (s *Forin_prodContext) Set_arraydata(v IArraydataContext) { s._arraydata = v }

func (s *Forin_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Forin_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Forin_prodContext) RFOR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRFOR, 0)
}

func (s *Forin_prodContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Forin_prodContext) RIN() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIN, 0)
}

func (s *Forin_prodContext) Range_prod() IRange_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_prodContext)
}

func (s *Forin_prodContext) Bloq() IBloqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloqContext)
}

func (s *Forin_prodContext) Arraydata() IArraydataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArraydataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArraydataContext)
}

func (s *Forin_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forin_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forin_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterForin_prod(s)
	}
}

func (s *Forin_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitForin_prod(s)
	}
}

func (p *ProjectParser) Forin_prod() (localctx IForin_prodContext) {
	localctx = NewForin_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ProjectParserRULE_forin_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(613)
			p.Match(ProjectParserRFOR)
		}
		{
			p.SetState(614)

			var _x = p.Expression()

			localctx.(*Forin_prodContext)._expression = _x
		}
		{
			p.SetState(615)
			p.Match(ProjectParserRIN)
		}
		{
			p.SetState(616)

			var _x = p.Range_prod()

			localctx.(*Forin_prodContext)._range_prod = _x
		}
		{
			p.SetState(617)

			var _x = p.Bloq()

			localctx.(*Forin_prodContext)._bloq = _x
		}
		localctx.(*Forin_prodContext).instr = BucleForIn.NewForIn(localctx.(*Forin_prodContext).Get_expression().GetP(), localctx.(*Forin_prodContext).Get_range_prod().GetP(), localctx.(*Forin_prodContext).Get_bloq().GetContent())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)
			p.Match(ProjectParserRFOR)
		}
		{
			p.SetState(621)

			var _x = p.Expression()

			localctx.(*Forin_prodContext)._expression = _x
		}
		{
			p.SetState(622)
			p.Match(ProjectParserRIN)
		}
		{
			p.SetState(623)

			var _x = p.Arraydata()

			localctx.(*Forin_prodContext)._arraydata = _x
		}
		{
			p.SetState(624)

			var _x = p.Bloq()

			localctx.(*Forin_prodContext)._bloq = _x
		}
		localctx.(*Forin_prodContext).instr = BucleForIn.NewForIn(localctx.(*Forin_prodContext).Get_expression().GetP(), localctx.(*Forin_prodContext).Get_arraydata().GetP(), localctx.(*Forin_prodContext).Get_bloq().GetContent())

	}

	return localctx
}

// IRange_prodContext is an interface to support dynamic dispatch.
type IRange_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RANGE returns the _RANGE token.
	Get_RANGE() antlr.Token

	// Set_RANGE sets the _RANGE token.
	Set_RANGE(antlr.Token)

	// GetE1 returns the e1 rule contexts.
	GetE1() IExpressionContext

	// GetE2 returns the e2 rule contexts.
	GetE2() IExpressionContext

	// SetE1 sets the e1 rule contexts.
	SetE1(IExpressionContext)

	// SetE2 sets the e2 rule contexts.
	SetE2(IExpressionContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsRange_prodContext differentiates from other interfaces.
	IsRange_prodContext()
}

type Range_prodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	p      Abstract.Expression
	e1     IExpressionContext
	_RANGE antlr.Token
	e2     IExpressionContext
}

func NewEmptyRange_prodContext() *Range_prodContext {
	var p = new(Range_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_range_prod
	return p
}

func (*Range_prodContext) IsRange_prodContext() {}

func NewRange_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_prodContext {
	var p = new(Range_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_range_prod

	return p
}

func (s *Range_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_prodContext) Get_RANGE() antlr.Token { return s._RANGE }

func (s *Range_prodContext) Set_RANGE(v antlr.Token) { s._RANGE = v }

func (s *Range_prodContext) GetE1() IExpressionContext { return s.e1 }

func (s *Range_prodContext) GetE2() IExpressionContext { return s.e2 }

func (s *Range_prodContext) SetE1(v IExpressionContext) { s.e1 = v }

func (s *Range_prodContext) SetE2(v IExpressionContext) { s.e2 = v }

func (s *Range_prodContext) GetP() Abstract.Expression { return s.p }

func (s *Range_prodContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Range_prodContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ProjectParserRANGE, 0)
}

func (s *Range_prodContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Range_prodContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Range_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterRange_prod(s)
	}
}

func (s *Range_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitRange_prod(s)
	}
}

func (p *ProjectParser) Range_prod() (localctx IRange_prodContext) {
	localctx = NewRange_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ProjectParserRULE_range_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)

		var _x = p.Expression()

		localctx.(*Range_prodContext).e1 = _x
	}
	{
		p.SetState(630)

		var _m = p.Match(ProjectParserRANGE)

		localctx.(*Range_prodContext)._RANGE = _m
	}
	{
		p.SetState(631)

		var _x = p.Expression()

		localctx.(*Range_prodContext).e2 = _x
	}

	localctx.(*Range_prodContext).p = Expression.NewRange((func() int {
		if localctx.(*Range_prodContext).Get_RANGE() == nil {
			return 0
		} else {
			return localctx.(*Range_prodContext).Get_RANGE().GetLine()
		}
	}()), localctx.(*Range_prodContext).Get_RANGE().GetColumn(), localctx.(*Range_prodContext).GetE1().GetP(), localctx.(*Range_prodContext).GetE2().GetP())

	return localctx
}

// ICalled_funcContext is an interface to support dynamic dispatch.
type ICalled_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_listExpressions returns the _listExpressions rule contexts.
	Get_listExpressions() IListExpressionsContext

	// Set_listExpressions sets the _listExpressions rule contexts.
	Set_listExpressions(IListExpressionsContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsCalled_funcContext differentiates from other interfaces.
	IsCalled_funcContext()
}

type Called_funcContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	instr            Abstract.Instruction
	p                Abstract.Expression
	_ID              antlr.Token
	_listExpressions IListExpressionsContext
}

func NewEmptyCalled_funcContext() *Called_funcContext {
	var p = new(Called_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_called_func
	return p
}

func (*Called_funcContext) IsCalled_funcContext() {}

func NewCalled_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Called_funcContext {
	var p = new(Called_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_called_func

	return p
}

func (s *Called_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Called_funcContext) Get_ID() antlr.Token { return s._ID }

func (s *Called_funcContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Called_funcContext) Get_listExpressions() IListExpressionsContext { return s._listExpressions }

func (s *Called_funcContext) Set_listExpressions(v IListExpressionsContext) { s._listExpressions = v }

func (s *Called_funcContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Called_funcContext) GetP() Abstract.Expression { return s.p }

func (s *Called_funcContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Called_funcContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Called_funcContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Called_funcContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *Called_funcContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *Called_funcContext) ListExpressions() IListExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListExpressionsContext)
}

func (s *Called_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Called_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Called_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterCalled_func(s)
	}
}

func (s *Called_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitCalled_func(s)
	}
}

func (p *ProjectParser) Called_func() (localctx ICalled_funcContext) {
	localctx = NewCalled_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ProjectParserRULE_called_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)

			var _m = p.Match(ProjectParserID)

			localctx.(*Called_funcContext)._ID = _m
		}
		{
			p.SetState(635)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(636)
			p.Match(ProjectParserRIGHT_PAR)
		}

		localctx.(*Called_funcContext).instr = ExpressionSpecial.NewCallFunction((func() string {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetText()
			}
		}()), arrayList.New(), (func() int {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetLine()
			}
		}()), localctx.(*Called_funcContext).Get_ID().GetColumn())
		localctx.(*Called_funcContext).p = ExpressionSpecial.NewCallFunction((func() string {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetText()
			}
		}()), arrayList.New(), (func() int {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetLine()
			}
		}()), localctx.(*Called_funcContext).Get_ID().GetColumn())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)

			var _m = p.Match(ProjectParserID)

			localctx.(*Called_funcContext)._ID = _m
		}
		{
			p.SetState(639)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(640)

			var _x = p.listExpressions(0)

			localctx.(*Called_funcContext)._listExpressions = _x
		}
		{
			p.SetState(641)
			p.Match(ProjectParserRIGHT_PAR)
		}

		localctx.(*Called_funcContext).instr = ExpressionSpecial.NewCallFunction((func() string {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetText()
			}
		}()), localctx.(*Called_funcContext).Get_listExpressions().GetL(), (func() int {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetLine()
			}
		}()), localctx.(*Called_funcContext).Get_ID().GetColumn())
		localctx.(*Called_funcContext).p = ExpressionSpecial.NewCallFunction((func() string {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetText()
			}
		}()), localctx.(*Called_funcContext).Get_listExpressions().GetL(), (func() int {
			if localctx.(*Called_funcContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Called_funcContext).Get_ID().GetLine()
			}
		}()), localctx.(*Called_funcContext).Get_ID().GetColumn())

	}

	return localctx
}

// IListExpressionsContext is an interface to support dynamic dispatch.
type IListExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetList returns the List rule contexts.
	GetList() IListExpressionsContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// SetList sets the List rule contexts.
	SetList(IListExpressionsContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListExpressionsContext differentiates from other interfaces.
	IsListExpressionsContext()
}

type ListExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	l           *arrayList.List
	List        IListExpressionsContext
	_expression IExpressionContext
}

func NewEmptyListExpressionsContext() *ListExpressionsContext {
	var p = new(ListExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listExpressions
	return p
}

func (*ListExpressionsContext) IsListExpressionsContext() {}

func NewListExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListExpressionsContext {
	var p = new(ListExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listExpressions

	return p
}

func (s *ListExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListExpressionsContext) GetList() IListExpressionsContext { return s.List }

func (s *ListExpressionsContext) Get_expression() IExpressionContext { return s._expression }

func (s *ListExpressionsContext) SetList(v IListExpressionsContext) { s.List = v }

func (s *ListExpressionsContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ListExpressionsContext) GetL() *arrayList.List { return s.l }

func (s *ListExpressionsContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListExpressionsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListExpressionsContext) ListExpressions() IListExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListExpressionsContext)
}

func (s *ListExpressionsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *ListExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListExpressions(s)
	}
}

func (s *ListExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListExpressions(s)
	}
}

func (p *ProjectParser) ListExpressions() (localctx IListExpressionsContext) {
	return p.listExpressions(0)
}

func (p *ProjectParser) listExpressions(_p int) (localctx IListExpressionsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListExpressionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListExpressionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, ProjectParserRULE_listExpressions, _p)

	localctx.(*ListExpressionsContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)

		var _x = p.Expression()

		localctx.(*ListExpressionsContext)._expression = _x
	}
	localctx.(*ListExpressionsContext).l.Add(localctx.(*ListExpressionsContext).Get_expression().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListExpressionsContext(p, _parentctx, _parentState)
			localctx.(*ListExpressionsContext).List = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listExpressions)
			p.SetState(650)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}

			{
				p.SetState(651)
				p.Match(ProjectParserCOMMA)
			}

			{
				p.SetState(652)

				var _x = p.Expression()

				localctx.(*ListExpressionsContext)._expression = _x
			}

			localctx.(*ListExpressionsContext).GetList().GetL().Add(localctx.(*ListExpressionsContext).Get_expression().GetP())
			localctx.(*ListExpressionsContext).l = localctx.(*ListExpressionsContext).GetList().GetL()

		}
		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())
	}

	return localctx
}

// IDec_arrContext is an interface to support dynamic dispatch.
type IDec_arrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_MUT returns the _MUT token.
	Get_MUT() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_MUT sets the _MUT token.
	Set_MUT(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_listDim returns the _listDim rule contexts.
	Get_listDim() IListDimContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_listDim sets the _listDim rule contexts.
	Set_listDim(IListDimContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsDec_arrContext differentiates from other interfaces.
	IsDec_arrContext()
}

type Dec_arrContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_MUT        antlr.Token
	_ID         antlr.Token
	_listDim    IListDimContext
	_expression IExpressionContext
}

func NewEmptyDec_arrContext() *Dec_arrContext {
	var p = new(Dec_arrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_dec_arr
	return p
}

func (*Dec_arrContext) IsDec_arrContext() {}

func NewDec_arrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_arrContext {
	var p = new(Dec_arrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_dec_arr

	return p
}

func (s *Dec_arrContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_arrContext) Get_MUT() antlr.Token { return s._MUT }

func (s *Dec_arrContext) Get_ID() antlr.Token { return s._ID }

func (s *Dec_arrContext) Set_MUT(v antlr.Token) { s._MUT = v }

func (s *Dec_arrContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Dec_arrContext) Get_listDim() IListDimContext { return s._listDim }

func (s *Dec_arrContext) Get_expression() IExpressionContext { return s._expression }

func (s *Dec_arrContext) Set_listDim(v IListDimContext) { s._listDim = v }

func (s *Dec_arrContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Dec_arrContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Dec_arrContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Dec_arrContext) DECLARAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserDECLARAR, 0)
}

func (s *Dec_arrContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Dec_arrContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUAL, 0)
}

func (s *Dec_arrContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Dec_arrContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Dec_arrContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Dec_arrContext) MUT() antlr.TerminalNode {
	return s.GetToken(ProjectParserMUT, 0)
}

func (s *Dec_arrContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *Dec_arrContext) ListDim() IListDimContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListDimContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListDimContext)
}

func (s *Dec_arrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_arrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dec_arrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterDec_arr(s)
	}
}

func (s *Dec_arrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitDec_arr(s)
	}
}

func (p *ProjectParser) Dec_arr() (localctx IDec_arrContext) {
	localctx = NewDec_arrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ProjectParserRULE_dec_arr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(ProjectParserDECLARAR)
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ProjectParserMUT {
		{
			p.SetState(661)

			var _m = p.Match(ProjectParserMUT)

			localctx.(*Dec_arrContext)._MUT = _m
		}

	}
	{
		p.SetState(664)

		var _m = p.Match(ProjectParserID)

		localctx.(*Dec_arrContext)._ID = _m
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ProjectParserCOLON {
		{
			p.SetState(665)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(666)

			var _x = p.ListDim()

			localctx.(*Dec_arrContext)._listDim = _x
		}

	}
	{
		p.SetState(669)
		p.Match(ProjectParserEQUAL)
	}
	{
		p.SetState(670)

		var _x = p.Expression()

		localctx.(*Dec_arrContext)._expression = _x
	}
	{
		p.SetState(671)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	if (func() string {
		if localctx.(*Dec_arrContext).Get_MUT() == nil {
			return ""
		} else {
			return localctx.(*Dec_arrContext).Get_MUT().GetText()
		}
	}()) != "" {
		localctx.(*Dec_arrContext).instr = DecArrays.NewDecArray(localctx.(*Dec_arrContext).Get_listDim().GetLength(), (func() string {
			if localctx.(*Dec_arrContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Dec_arrContext).Get_ID().GetText()
			}
		}()), localctx.(*Dec_arrContext).Get_expression().GetP(), localctx.(*Dec_arrContext).Get_listDim().GetData(), true, localctx.(*Dec_arrContext).Get_listDim().GetPos(), (func() int {
			if localctx.(*Dec_arrContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Dec_arrContext).Get_ID().GetLine()
			}
		}()), localctx.(*Dec_arrContext).Get_ID().GetColumn())
	} else {
		localctx.(*Dec_arrContext).instr = DecArrays.NewDecArray(localctx.(*Dec_arrContext).Get_listDim().GetLength(), (func() string {
			if localctx.(*Dec_arrContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Dec_arrContext).Get_ID().GetText()
			}
		}()), localctx.(*Dec_arrContext).Get_expression().GetP(), localctx.(*Dec_arrContext).Get_listDim().GetData(), false, localctx.(*Dec_arrContext).Get_listDim().GetPos(), (func() int {
			if localctx.(*Dec_arrContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*Dec_arrContext).Get_ID().GetLine()
			}
		}()), localctx.(*Dec_arrContext).Get_ID().GetColumn())
	}

	return localctx
}

// IListDimContext is an interface to support dynamic dispatch.
type IListDimContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IListDimContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// SetL sets the l rule contexts.
	SetL(IListDimContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// GetLength returns the length attribute.
	GetLength() int

	// GetData returns the data attribute.
	GetData() SymbolTable.DataType

	// GetPos returns the pos attribute.
	GetPos() Abstract.Expression

	// SetLength sets the length attribute.
	SetLength(int)

	// SetData sets the data attribute.
	SetData(SymbolTable.DataType)

	// SetPos sets the pos attribute.
	SetPos(Abstract.Expression)

	// IsListDimContext differentiates from other interfaces.
	IsListDimContext()
}

type ListDimContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	length      int
	data        SymbolTable.DataType
	pos         Abstract.Expression
	l           IListDimContext
	_expression IExpressionContext
	_data_type  IData_typeContext
}

func NewEmptyListDimContext() *ListDimContext {
	var p = new(ListDimContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listDim
	return p
}

func (*ListDimContext) IsListDimContext() {}

func NewListDimContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListDimContext {
	var p = new(ListDimContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listDim

	return p
}

func (s *ListDimContext) GetParser() antlr.Parser { return s.parser }

func (s *ListDimContext) GetL() IListDimContext { return s.l }

func (s *ListDimContext) Get_expression() IExpressionContext { return s._expression }

func (s *ListDimContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *ListDimContext) SetL(v IListDimContext) { s.l = v }

func (s *ListDimContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ListDimContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *ListDimContext) GetLength() int { return s.length }

func (s *ListDimContext) GetData() SymbolTable.DataType { return s.data }

func (s *ListDimContext) GetPos() Abstract.Expression { return s.pos }

func (s *ListDimContext) SetLength(v int) { s.length = v }

func (s *ListDimContext) SetData(v SymbolTable.DataType) { s.data = v }

func (s *ListDimContext) SetPos(v Abstract.Expression) { s.pos = v }

func (s *ListDimContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_BRACKET, 0)
}

func (s *ListDimContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *ListDimContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListDimContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_BRACKET, 0)
}

func (s *ListDimContext) ListDim() IListDimContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListDimContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListDimContext)
}

func (s *ListDimContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *ListDimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListDimContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListDimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListDim(s)
	}
}

func (s *ListDimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListDim(s)
	}
}

func (p *ProjectParser) ListDim() (localctx IListDimContext) {
	localctx = NewListDimContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ProjectParserRULE_listDim)
	localctx.(*ListDimContext).length = 0

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(674)
			p.Match(ProjectParserLEFT_BRACKET)
		}
		{
			p.SetState(675)

			var _x = p.ListDim()

			localctx.(*ListDimContext).l = _x
		}
		{
			p.SetState(676)
			p.Match(ProjectParserSEMICOLON)
		}
		{
			p.SetState(677)

			var _x = p.Expression()

			localctx.(*ListDimContext)._expression = _x
		}
		{
			p.SetState(678)
			p.Match(ProjectParserRIGHT_BRACKET)
		}
		localctx.(*ListDimContext).length = localctx.(*ListDimContext).GetL().GetLength() + 1
		localctx.(*ListDimContext).data = localctx.(*ListDimContext).GetL().GetData()
		localctx.(*ListDimContext).pos = localctx.(*ListDimContext).Get_expression().GetP()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Match(ProjectParserLEFT_BRACKET)
		}
		{
			p.SetState(682)

			var _x = p.Data_type()

			localctx.(*ListDimContext)._data_type = _x
		}
		{
			p.SetState(683)
			p.Match(ProjectParserSEMICOLON)
		}
		{
			p.SetState(684)

			var _x = p.Expression()

			localctx.(*ListDimContext)._expression = _x
		}
		{
			p.SetState(685)
			p.Match(ProjectParserRIGHT_BRACKET)
		}

		localctx.(*ListDimContext).length = 1
		localctx.(*ListDimContext).pos = localctx.(*ListDimContext).Get_expression().GetP()
		switch localctx.(*ListDimContext).Get_data_type().GetData() {
		case "i64":
			localctx.(*ListDimContext).data = SymbolTable.INTEGER
		case "f64":
			localctx.(*ListDimContext).data = SymbolTable.FLOAT
		case "&str":
			localctx.(*ListDimContext).data = SymbolTable.STR
		case "String":
			localctx.(*ListDimContext).data = SymbolTable.STRING
		case "bool":
			localctx.(*ListDimContext).data = SymbolTable.BOOLEAN
		case "char":
			localctx.(*ListDimContext).data = SymbolTable.CHAR
		}

	}

	return localctx
}

// IVector_instrContext is an interface to support dynamic dispatch.
type IVector_instrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_dec_vector returns the _dec_vector rule contexts.
	Get_dec_vector() IDec_vectorContext

	// Get_natives_vector returns the _natives_vector rule contexts.
	Get_natives_vector() INatives_vectorContext

	// Set_dec_vector sets the _dec_vector rule contexts.
	Set_dec_vector(IDec_vectorContext)

	// Set_natives_vector sets the _natives_vector rule contexts.
	Set_natives_vector(INatives_vectorContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsVector_instrContext differentiates from other interfaces.
	IsVector_instrContext()
}

type Vector_instrContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	instr           Abstract.Instruction
	p               Abstract.Expression
	_dec_vector     IDec_vectorContext
	_natives_vector INatives_vectorContext
}

func NewEmptyVector_instrContext() *Vector_instrContext {
	var p = new(Vector_instrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_vector_instr
	return p
}

func (*Vector_instrContext) IsVector_instrContext() {}

func NewVector_instrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vector_instrContext {
	var p = new(Vector_instrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_vector_instr

	return p
}

func (s *Vector_instrContext) GetParser() antlr.Parser { return s.parser }

func (s *Vector_instrContext) Get_dec_vector() IDec_vectorContext { return s._dec_vector }

func (s *Vector_instrContext) Get_natives_vector() INatives_vectorContext { return s._natives_vector }

func (s *Vector_instrContext) Set_dec_vector(v IDec_vectorContext) { s._dec_vector = v }

func (s *Vector_instrContext) Set_natives_vector(v INatives_vectorContext) { s._natives_vector = v }

func (s *Vector_instrContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Vector_instrContext) GetP() Abstract.Expression { return s.p }

func (s *Vector_instrContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Vector_instrContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Vector_instrContext) Dec_vector() IDec_vectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDec_vectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDec_vectorContext)
}

func (s *Vector_instrContext) Natives_vector() INatives_vectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INatives_vectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INatives_vectorContext)
}

func (s *Vector_instrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vector_instrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vector_instrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterVector_instr(s)
	}
}

func (s *Vector_instrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitVector_instr(s)
	}
}

func (p *ProjectParser) Vector_instr() (localctx IVector_instrContext) {
	localctx = NewVector_instrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ProjectParserRULE_vector_instr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserDECLARAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(690)

			var _x = p.Dec_vector()

			localctx.(*Vector_instrContext)._dec_vector = _x
		}

		localctx.(*Vector_instrContext).instr = localctx.(*Vector_instrContext).Get_dec_vector().GetInstr()

	case ProjectParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(693)

			var _x = p.Natives_vector()

			localctx.(*Vector_instrContext)._natives_vector = _x
		}

		localctx.(*Vector_instrContext).instr = localctx.(*Vector_instrContext).Get_natives_vector().GetInstr()
		localctx.(*Vector_instrContext).p = localctx.(*Vector_instrContext).Get_natives_vector().GetP()

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDec_vectorContext is an interface to support dynamic dispatch.
type IDec_vectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_MUT returns the _MUT token.
	Get_MUT() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_MUT sets the _MUT token.
	Set_MUT(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// Get_expr_vector returns the _expr_vector rule contexts.
	Get_expr_vector() IExpr_vectorContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetE1 returns the e1 rule contexts.
	GetE1() IExpressionContext

	// GetE2 returns the e2 rule contexts.
	GetE2() IExpressionContext

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// Set_expr_vector sets the _expr_vector rule contexts.
	Set_expr_vector(IExpr_vectorContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetE1 sets the e1 rule contexts.
	SetE1(IExpressionContext)

	// SetE2 sets the e2 rule contexts.
	SetE2(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsDec_vectorContext differentiates from other interfaces.
	IsDec_vectorContext()
}

type Dec_vectorContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	instr        Abstract.Instruction
	_MUT         antlr.Token
	_ID          antlr.Token
	_data_type   IData_typeContext
	_expr_vector IExpr_vectorContext
	_expression  IExpressionContext
	e1           IExpressionContext
	e2           IExpressionContext
}

func NewEmptyDec_vectorContext() *Dec_vectorContext {
	var p = new(Dec_vectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_dec_vector
	return p
}

func (*Dec_vectorContext) IsDec_vectorContext() {}

func NewDec_vectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_vectorContext {
	var p = new(Dec_vectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_dec_vector

	return p
}

func (s *Dec_vectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_vectorContext) Get_MUT() antlr.Token { return s._MUT }

func (s *Dec_vectorContext) Get_ID() antlr.Token { return s._ID }

func (s *Dec_vectorContext) Set_MUT(v antlr.Token) { s._MUT = v }

func (s *Dec_vectorContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Dec_vectorContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *Dec_vectorContext) Get_expr_vector() IExpr_vectorContext { return s._expr_vector }

func (s *Dec_vectorContext) Get_expression() IExpressionContext { return s._expression }

func (s *Dec_vectorContext) GetE1() IExpressionContext { return s.e1 }

func (s *Dec_vectorContext) GetE2() IExpressionContext { return s.e2 }

func (s *Dec_vectorContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *Dec_vectorContext) Set_expr_vector(v IExpr_vectorContext) { s._expr_vector = v }

func (s *Dec_vectorContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Dec_vectorContext) SetE1(v IExpressionContext) { s.e1 = v }

func (s *Dec_vectorContext) SetE2(v IExpressionContext) { s.e2 = v }

func (s *Dec_vectorContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Dec_vectorContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Dec_vectorContext) DECLARAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserDECLARAR, 0)
}

func (s *Dec_vectorContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Dec_vectorContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *Dec_vectorContext) RVECMayus() antlr.TerminalNode {
	return s.GetToken(ProjectParserRVECMayus, 0)
}

func (s *Dec_vectorContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserLESS_THAN, 0)
}

func (s *Dec_vectorContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Dec_vectorContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserGREATER_THAN, 0)
}

func (s *Dec_vectorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUAL, 0)
}

func (s *Dec_vectorContext) REVECTORNEW() antlr.TerminalNode {
	return s.GetToken(ProjectParserREVECTORNEW, 0)
}

func (s *Dec_vectorContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ProjectParserSEMICOLON)
}

func (s *Dec_vectorContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, i)
}

func (s *Dec_vectorContext) MUT() antlr.TerminalNode {
	return s.GetToken(ProjectParserMUT, 0)
}

func (s *Dec_vectorContext) Expr_vector() IExpr_vectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_vectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_vectorContext)
}

func (s *Dec_vectorContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Dec_vectorContext) REVECCAPACITY() antlr.TerminalNode {
	return s.GetToken(ProjectParserREVECCAPACITY, 0)
}

func (s *Dec_vectorContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *Dec_vectorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Dec_vectorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Dec_vectorContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *Dec_vectorContext) RVEC() antlr.TerminalNode {
	return s.GetToken(ProjectParserRVEC, 0)
}

func (s *Dec_vectorContext) ADMIRATION() antlr.TerminalNode {
	return s.GetToken(ProjectParserADMIRATION, 0)
}

func (s *Dec_vectorContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_BRACKET, 0)
}

func (s *Dec_vectorContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_BRACKET, 0)
}

func (s *Dec_vectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_vectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dec_vectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterDec_vector(s)
	}
}

func (s *Dec_vectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitDec_vector(s)
	}
}

func (p *ProjectParser) Dec_vector() (localctx IDec_vectorContext) {
	localctx = NewDec_vectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ProjectParserRULE_dec_vector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(699)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Dec_vectorContext)._MUT = _m
			}

		}
		{
			p.SetState(702)

			var _m = p.Match(ProjectParserID)

			localctx.(*Dec_vectorContext)._ID = _m
		}
		{
			p.SetState(703)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(704)
			p.Match(ProjectParserRVECMayus)
		}
		{
			p.SetState(705)
			p.Match(ProjectParserLESS_THAN)
		}
		{
			p.SetState(706)

			var _x = p.Data_type()

			localctx.(*Dec_vectorContext)._data_type = _x
		}
		{
			p.SetState(707)
			p.Match(ProjectParserGREATER_THAN)
		}
		{
			p.SetState(708)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(709)
			p.Match(ProjectParserREVECTORNEW)
		}
		{
			p.SetState(710)
			p.Match(ProjectParserSEMICOLON)
		}

		var data SymbolTable.DataType
		switch localctx.(*Dec_vectorContext).Get_data_type().GetData() {
		case "i64":
			data = SymbolTable.INTEGER
		case "f64":
			data = SymbolTable.FLOAT
		case "&str":
			data = SymbolTable.STR
		case "String":
			data = SymbolTable.STRING
		case "bool":
			data = SymbolTable.BOOLEAN
		}

		if (func() string {
			if localctx.(*Dec_vectorContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Dec_vectorContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(1, nil, (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), nil, data, true, false)
		} else {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(1, nil, (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), nil, data, false, false)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(713)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(714)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Dec_vectorContext)._MUT = _m
			}

		}
		{
			p.SetState(717)

			var _m = p.Match(ProjectParserID)

			localctx.(*Dec_vectorContext)._ID = _m
		}
		{
			p.SetState(718)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(719)

			var _x = p.Expr_vector()

			localctx.(*Dec_vectorContext)._expr_vector = _x
		}
		{
			p.SetState(720)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ProjectParserSEMICOLON || _la == ProjectParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		if (func() string {
			if localctx.(*Dec_vectorContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Dec_vectorContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(1, nil, (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), localctx.(*Dec_vectorContext).Get_expr_vector().GetP(), SymbolTable.NULL, true, false)
		} else {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(1, nil, (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), localctx.(*Dec_vectorContext).Get_expr_vector().GetP(), SymbolTable.NULL, false, false)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(723)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(724)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Dec_vectorContext)._MUT = _m
			}

		}
		{
			p.SetState(727)

			var _m = p.Match(ProjectParserID)

			localctx.(*Dec_vectorContext)._ID = _m
		}
		{
			p.SetState(728)
			p.Match(ProjectParserCOLON)
		}
		{
			p.SetState(729)
			p.Match(ProjectParserRVECMayus)
		}
		{
			p.SetState(730)
			p.Match(ProjectParserLESS_THAN)
		}
		{
			p.SetState(731)

			var _x = p.Data_type()

			localctx.(*Dec_vectorContext)._data_type = _x
		}
		{
			p.SetState(732)
			p.Match(ProjectParserGREATER_THAN)
		}
		{
			p.SetState(733)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(734)
			p.Match(ProjectParserREVECCAPACITY)
		}
		{
			p.SetState(735)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(736)

			var _x = p.Expression()

			localctx.(*Dec_vectorContext)._expression = _x
		}
		{
			p.SetState(737)
			p.Match(ProjectParserRIGHT_PAR)
		}
		{
			p.SetState(738)
			p.Match(ProjectParserSEMICOLON)
		}

		var data SymbolTable.DataType
		switch localctx.(*Dec_vectorContext).Get_data_type().GetData() {
		case "i64":
			data = SymbolTable.INTEGER
		case "f64":
			data = SymbolTable.FLOAT
		case "&str":
			data = SymbolTable.STR
		case "String":
			data = SymbolTable.STRING
		case "bool":
			data = SymbolTable.BOOLEAN
		}

		if (func() string {
			if localctx.(*Dec_vectorContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Dec_vectorContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(0, localctx.(*Dec_vectorContext).Get_expression().GetP(), (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), nil, data, true, true)
		} else {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(0, localctx.(*Dec_vectorContext).Get_expression().GetP(), (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), nil, data, false, true)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(741)
			p.Match(ProjectParserDECLARAR)
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ProjectParserMUT {
			{
				p.SetState(742)

				var _m = p.Match(ProjectParserMUT)

				localctx.(*Dec_vectorContext)._MUT = _m
			}

		}
		{
			p.SetState(745)

			var _m = p.Match(ProjectParserID)

			localctx.(*Dec_vectorContext)._ID = _m
		}
		{
			p.SetState(746)
			p.Match(ProjectParserEQUAL)
		}
		{
			p.SetState(747)
			p.Match(ProjectParserRVEC)
		}
		{
			p.SetState(748)
			p.Match(ProjectParserADMIRATION)
		}
		{
			p.SetState(749)
			p.Match(ProjectParserLEFT_BRACKET)
		}
		{
			p.SetState(750)

			var _x = p.Expression()

			localctx.(*Dec_vectorContext).e1 = _x
		}
		{
			p.SetState(751)
			p.Match(ProjectParserSEMICOLON)
		}
		{
			p.SetState(752)

			var _x = p.Expression()

			localctx.(*Dec_vectorContext).e2 = _x
		}
		{
			p.SetState(753)
			p.Match(ProjectParserRIGHT_BRACKET)
		}
		{
			p.SetState(754)
			p.Match(ProjectParserSEMICOLON)
		}

		if (func() string {
			if localctx.(*Dec_vectorContext).Get_MUT() == nil {
				return ""
			} else {
				return localctx.(*Dec_vectorContext).Get_MUT().GetText()
			}
		}()) != "" {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(0, localctx.(*Dec_vectorContext).GetE2().GetP(), (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), localctx.(*Dec_vectorContext).GetE1().GetP(), SymbolTable.NULL, true, false)
		} else {
			localctx.(*Dec_vectorContext).instr = DecVectors.NewDecVector(0, localctx.(*Dec_vectorContext).GetE2().GetP(), (func() string {
				if localctx.(*Dec_vectorContext).Get_ID() == nil {
					return ""
				} else {
					return localctx.(*Dec_vectorContext).Get_ID().GetText()
				}
			}()), localctx.(*Dec_vectorContext).GetE1().GetP(), SymbolTable.NULL, false, false)
		}

	}

	return localctx
}

// IExpr_vectorContext is an interface to support dynamic dispatch.
type IExpr_vectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsExpr_vectorContext differentiates from other interfaces.
	IsExpr_vectorContext()
}

type Expr_vectorContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	_expression IExpressionContext
}

func NewEmptyExpr_vectorContext() *Expr_vectorContext {
	var p = new(Expr_vectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_vector
	return p
}

func (*Expr_vectorContext) IsExpr_vectorContext() {}

func NewExpr_vectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_vectorContext {
	var p = new(Expr_vectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_vector

	return p
}

func (s *Expr_vectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_vectorContext) Get_expression() IExpressionContext { return s._expression }

func (s *Expr_vectorContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Expr_vectorContext) GetP() Abstract.Expression { return s.p }

func (s *Expr_vectorContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Expr_vectorContext) RVEC() antlr.TerminalNode {
	return s.GetToken(ProjectParserRVEC, 0)
}

func (s *Expr_vectorContext) ADMIRATION() antlr.TerminalNode {
	return s.GetToken(ProjectParserADMIRATION, 0)
}

func (s *Expr_vectorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_vectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_vectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_vectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_vector(s)
	}
}

func (s *Expr_vectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_vector(s)
	}
}

func (p *ProjectParser) Expr_vector() (localctx IExpr_vectorContext) {
	localctx = NewExpr_vectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ProjectParserRULE_expr_vector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(ProjectParserRVEC)
	}
	{
		p.SetState(760)
		p.Match(ProjectParserADMIRATION)
	}
	{
		p.SetState(761)

		var _x = p.Expression()

		localctx.(*Expr_vectorContext)._expression = _x
	}

	localctx.(*Expr_vectorContext).p = localctx.(*Expr_vectorContext).Get_expression().GetP()

	return localctx
}

// INatives_vectorContext is an interface to support dynamic dispatch.
type INatives_vectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// GetOp returns the op token.
	GetOp() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// GetE1 returns the e1 rule contexts.
	GetE1() IExpressionContext

	// GetE2 returns the e2 rule contexts.
	GetE2() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// SetE1 sets the e1 rule contexts.
	SetE1(IExpressionContext)

	// SetE2 sets the e2 rule contexts.
	SetE2(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsNatives_vectorContext differentiates from other interfaces.
	IsNatives_vectorContext()
}

type Natives_vectorContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	p           Abstract.Expression
	_ID         antlr.Token
	op          antlr.Token
	_expression IExpressionContext
	e1          IExpressionContext
	e2          IExpressionContext
}

func NewEmptyNatives_vectorContext() *Natives_vectorContext {
	var p = new(Natives_vectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_natives_vector
	return p
}

func (*Natives_vectorContext) IsNatives_vectorContext() {}

func NewNatives_vectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Natives_vectorContext {
	var p = new(Natives_vectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_natives_vector

	return p
}

func (s *Natives_vectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Natives_vectorContext) Get_ID() antlr.Token { return s._ID }

func (s *Natives_vectorContext) GetOp() antlr.Token { return s.op }

func (s *Natives_vectorContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Natives_vectorContext) SetOp(v antlr.Token) { s.op = v }

func (s *Natives_vectorContext) Get_expression() IExpressionContext { return s._expression }

func (s *Natives_vectorContext) GetE1() IExpressionContext { return s.e1 }

func (s *Natives_vectorContext) GetE2() IExpressionContext { return s.e2 }

func (s *Natives_vectorContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Natives_vectorContext) SetE1(v IExpressionContext) { s.e1 = v }

func (s *Natives_vectorContext) SetE2(v IExpressionContext) { s.e2 = v }

func (s *Natives_vectorContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Natives_vectorContext) GetP() Abstract.Expression { return s.p }

func (s *Natives_vectorContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Natives_vectorContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Natives_vectorContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ProjectParserID)
}

func (s *Natives_vectorContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ProjectParserID, i)
}

func (s *Natives_vectorContext) DOT() antlr.TerminalNode {
	return s.GetToken(ProjectParserDOT, 0)
}

func (s *Natives_vectorContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *Natives_vectorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Natives_vectorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Natives_vectorContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *Natives_vectorContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Natives_vectorContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Natives_vectorContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(ProjectParserREFERENCE, 0)
}

func (s *Natives_vectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Natives_vectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Natives_vectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterNatives_vector(s)
	}
}

func (s *Natives_vectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitNatives_vector(s)
	}
}

func (p *ProjectParser) Natives_vector() (localctx INatives_vectorContext) {
	localctx = NewNatives_vectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ProjectParserRULE_natives_vector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(764)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext)._ID = _m
		}
		{
			p.SetState(765)
			p.Match(ProjectParserDOT)
		}
		{
			p.SetState(766)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext).op = _m
		}
		{
			p.SetState(767)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(768)

			var _x = p.Expression()

			localctx.(*Natives_vectorContext)._expression = _x
		}
		{
			p.SetState(769)
			p.Match(ProjectParserRIGHT_PAR)
		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(770)
				p.Match(ProjectParserSEMICOLON)
			}

		}

		localctx.(*Natives_vectorContext).instr = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), localctx.(*Natives_vectorContext).Get_expression().GetP(), (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), nil)
		localctx.(*Natives_vectorContext).p = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), localctx.(*Natives_vectorContext).Get_expression().GetP(), (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), nil)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(775)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext)._ID = _m
		}
		{
			p.SetState(776)
			p.Match(ProjectParserDOT)
		}
		{
			p.SetState(777)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext).op = _m
		}
		{
			p.SetState(778)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(779)
			p.Match(ProjectParserRIGHT_PAR)
		}
		p.SetState(781)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(780)
				p.Match(ProjectParserSEMICOLON)
			}

		}

		localctx.(*Natives_vectorContext).instr = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), nil, (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), nil)
		localctx.(*Natives_vectorContext).p = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), nil, (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), nil)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(784)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext)._ID = _m
		}
		{
			p.SetState(785)
			p.Match(ProjectParserDOT)
		}
		{
			p.SetState(786)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext).op = _m
		}
		{
			p.SetState(787)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(788)

			var _x = p.Expression()

			localctx.(*Natives_vectorContext).e1 = _x
		}
		{
			p.SetState(789)
			p.Match(ProjectParserCOMMA)
		}
		{
			p.SetState(790)

			var _x = p.Expression()

			localctx.(*Natives_vectorContext).e2 = _x
		}
		{
			p.SetState(791)
			p.Match(ProjectParserRIGHT_PAR)
		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(792)
				p.Match(ProjectParserSEMICOLON)
			}

		}

		localctx.(*Natives_vectorContext).instr = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), localctx.(*Natives_vectorContext).GetE2().GetP(), (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), localctx.(*Natives_vectorContext).GetE1().GetP())
		localctx.(*Natives_vectorContext).p = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), localctx.(*Natives_vectorContext).GetE2().GetP(), (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), localctx.(*Natives_vectorContext).GetE1().GetP())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(797)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext)._ID = _m
		}
		{
			p.SetState(798)
			p.Match(ProjectParserDOT)
		}
		{
			p.SetState(799)

			var _m = p.Match(ProjectParserID)

			localctx.(*Natives_vectorContext).op = _m
		}
		{
			p.SetState(800)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(801)
			p.Match(ProjectParserREFERENCE)
		}
		{
			p.SetState(802)

			var _x = p.Expression()

			localctx.(*Natives_vectorContext)._expression = _x
		}
		{
			p.SetState(803)
			p.Match(ProjectParserRIGHT_PAR)
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(804)
				p.Match(ProjectParserSEMICOLON)
			}

		}

		localctx.(*Natives_vectorContext).instr = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), localctx.(*Natives_vectorContext).Get_expression().GetP(), (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), nil)
		localctx.(*Natives_vectorContext).p = DecVectors.NewOperation((func() string {
			if localctx.(*Natives_vectorContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).Get_ID().GetText()
			}
		}()), localctx.(*Natives_vectorContext).Get_expression().GetP(), (func() string {
			if localctx.(*Natives_vectorContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*Natives_vectorContext).GetOp().GetText()
			}
		}()), nil)

	}

	return localctx
}

// ITransfer_prodContext is an interface to support dynamic dispatch.
type ITransfer_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_break_instr returns the _break_instr rule contexts.
	Get_break_instr() IBreak_instrContext

	// Get_continue_instr returns the _continue_instr rule contexts.
	Get_continue_instr() IContinue_instrContext

	// Get_return_instr returns the _return_instr rule contexts.
	Get_return_instr() IReturn_instrContext

	// Set_break_instr sets the _break_instr rule contexts.
	Set_break_instr(IBreak_instrContext)

	// Set_continue_instr sets the _continue_instr rule contexts.
	Set_continue_instr(IContinue_instrContext)

	// Set_return_instr sets the _return_instr rule contexts.
	Set_return_instr(IReturn_instrContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsTransfer_prodContext differentiates from other interfaces.
	IsTransfer_prodContext()
}

type Transfer_prodContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	instr           Abstract.Instruction
	_break_instr    IBreak_instrContext
	_continue_instr IContinue_instrContext
	_return_instr   IReturn_instrContext
}

func NewEmptyTransfer_prodContext() *Transfer_prodContext {
	var p = new(Transfer_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_transfer_prod
	return p
}

func (*Transfer_prodContext) IsTransfer_prodContext() {}

func NewTransfer_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transfer_prodContext {
	var p = new(Transfer_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_transfer_prod

	return p
}

func (s *Transfer_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Transfer_prodContext) Get_break_instr() IBreak_instrContext { return s._break_instr }

func (s *Transfer_prodContext) Get_continue_instr() IContinue_instrContext { return s._continue_instr }

func (s *Transfer_prodContext) Get_return_instr() IReturn_instrContext { return s._return_instr }

func (s *Transfer_prodContext) Set_break_instr(v IBreak_instrContext) { s._break_instr = v }

func (s *Transfer_prodContext) Set_continue_instr(v IContinue_instrContext) { s._continue_instr = v }

func (s *Transfer_prodContext) Set_return_instr(v IReturn_instrContext) { s._return_instr = v }

func (s *Transfer_prodContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Transfer_prodContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Transfer_prodContext) Break_instr() IBreak_instrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_instrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_instrContext)
}

func (s *Transfer_prodContext) Continue_instr() IContinue_instrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_instrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_instrContext)
}

func (s *Transfer_prodContext) Return_instr() IReturn_instrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_instrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_instrContext)
}

func (s *Transfer_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transfer_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transfer_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterTransfer_prod(s)
	}
}

func (s *Transfer_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitTransfer_prod(s)
	}
}

func (p *ProjectParser) Transfer_prod() (localctx ITransfer_prodContext) {
	localctx = NewTransfer_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ProjectParserRULE_transfer_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(820)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRBREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)

			var _x = p.Break_instr()

			localctx.(*Transfer_prodContext)._break_instr = _x
		}
		localctx.(*Transfer_prodContext).instr = localctx.(*Transfer_prodContext).Get_break_instr().GetInstr()

	case ProjectParserRCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(814)

			var _x = p.Continue_instr()

			localctx.(*Transfer_prodContext)._continue_instr = _x
		}
		localctx.(*Transfer_prodContext).instr = localctx.(*Transfer_prodContext).Get_continue_instr().GetInstr()

	case ProjectParserRRETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(817)

			var _x = p.Return_instr()

			localctx.(*Transfer_prodContext)._return_instr = _x
		}
		localctx.(*Transfer_prodContext).instr = localctx.(*Transfer_prodContext).Get_return_instr().GetInstr()

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBreak_instrContext is an interface to support dynamic dispatch.
type IBreak_instrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RBREAK returns the _RBREAK token.
	Get_RBREAK() antlr.Token

	// Set_RBREAK sets the _RBREAK token.
	Set_RBREAK(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsBreak_instrContext differentiates from other interfaces.
	IsBreak_instrContext()
}

type Break_instrContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_RBREAK     antlr.Token
	_expression IExpressionContext
}

func NewEmptyBreak_instrContext() *Break_instrContext {
	var p = new(Break_instrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_break_instr
	return p
}

func (*Break_instrContext) IsBreak_instrContext() {}

func NewBreak_instrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_instrContext {
	var p = new(Break_instrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_break_instr

	return p
}

func (s *Break_instrContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_instrContext) Get_RBREAK() antlr.Token { return s._RBREAK }

func (s *Break_instrContext) Set_RBREAK(v antlr.Token) { s._RBREAK = v }

func (s *Break_instrContext) Get_expression() IExpressionContext { return s._expression }

func (s *Break_instrContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Break_instrContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Break_instrContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Break_instrContext) RBREAK() antlr.TerminalNode {
	return s.GetToken(ProjectParserRBREAK, 0)
}

func (s *Break_instrContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Break_instrContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Break_instrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_instrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_instrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterBreak_instr(s)
	}
}

func (s *Break_instrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitBreak_instr(s)
	}
}

func (p *ProjectParser) Break_instr() (localctx IBreak_instrContext) {
	localctx = NewBreak_instrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ProjectParserRULE_break_instr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(822)

			var _m = p.Match(ProjectParserRBREAK)

			localctx.(*Break_instrContext)._RBREAK = _m
		}
		{
			p.SetState(823)
			p.Match(ProjectParserSEMICOLON)
		}
		localctx.(*Break_instrContext).instr = Natives.NewBreak((func() int {
			if localctx.(*Break_instrContext).Get_RBREAK() == nil {
				return 0
			} else {
				return localctx.(*Break_instrContext).Get_RBREAK().GetLine()
			}
		}()), localctx.(*Break_instrContext).Get_RBREAK().GetColumn(), nil)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)

			var _m = p.Match(ProjectParserRBREAK)

			localctx.(*Break_instrContext)._RBREAK = _m
		}
		{
			p.SetState(826)

			var _x = p.Expression()

			localctx.(*Break_instrContext)._expression = _x
		}
		{
			p.SetState(827)
			p.Match(ProjectParserSEMICOLON)
		}
		localctx.(*Break_instrContext).instr = Natives.NewBreak((func() int {
			if localctx.(*Break_instrContext).Get_RBREAK() == nil {
				return 0
			} else {
				return localctx.(*Break_instrContext).Get_RBREAK().GetLine()
			}
		}()), localctx.(*Break_instrContext).Get_RBREAK().GetColumn(), localctx.(*Break_instrContext).Get_expression().GetP())

	}

	return localctx
}

// IContinue_instrContext is an interface to support dynamic dispatch.
type IContinue_instrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RCONTINUE returns the _RCONTINUE token.
	Get_RCONTINUE() antlr.Token

	// Set_RCONTINUE sets the _RCONTINUE token.
	Set_RCONTINUE(antlr.Token)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsContinue_instrContext differentiates from other interfaces.
	IsContinue_instrContext()
}

type Continue_instrContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	instr      Abstract.Instruction
	_RCONTINUE antlr.Token
}

func NewEmptyContinue_instrContext() *Continue_instrContext {
	var p = new(Continue_instrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_continue_instr
	return p
}

func (*Continue_instrContext) IsContinue_instrContext() {}

func NewContinue_instrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_instrContext {
	var p = new(Continue_instrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_continue_instr

	return p
}

func (s *Continue_instrContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_instrContext) Get_RCONTINUE() antlr.Token { return s._RCONTINUE }

func (s *Continue_instrContext) Set_RCONTINUE(v antlr.Token) { s._RCONTINUE = v }

func (s *Continue_instrContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Continue_instrContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Continue_instrContext) RCONTINUE() antlr.TerminalNode {
	return s.GetToken(ProjectParserRCONTINUE, 0)
}

func (s *Continue_instrContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Continue_instrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_instrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_instrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterContinue_instr(s)
	}
}

func (s *Continue_instrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitContinue_instr(s)
	}
}

func (p *ProjectParser) Continue_instr() (localctx IContinue_instrContext) {
	localctx = NewContinue_instrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ProjectParserRULE_continue_instr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)

		var _m = p.Match(ProjectParserRCONTINUE)

		localctx.(*Continue_instrContext)._RCONTINUE = _m
	}
	{
		p.SetState(833)
		p.Match(ProjectParserSEMICOLON)
	}
	localctx.(*Continue_instrContext).instr = Natives.NewContinue((func() int {
		if localctx.(*Continue_instrContext).Get_RCONTINUE() == nil {
			return 0
		} else {
			return localctx.(*Continue_instrContext).Get_RCONTINUE().GetLine()
		}
	}()), localctx.(*Continue_instrContext).Get_RCONTINUE().GetColumn())

	return localctx
}

// IReturn_instrContext is an interface to support dynamic dispatch.
type IReturn_instrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RRETURN returns the _RRETURN token.
	Get_RRETURN() antlr.Token

	// Set_RRETURN sets the _RRETURN token.
	Set_RRETURN(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsReturn_instrContext differentiates from other interfaces.
	IsReturn_instrContext()
}

type Return_instrContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	instr       Abstract.Instruction
	_RRETURN    antlr.Token
	_expression IExpressionContext
}

func NewEmptyReturn_instrContext() *Return_instrContext {
	var p = new(Return_instrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_return_instr
	return p
}

func (*Return_instrContext) IsReturn_instrContext() {}

func NewReturn_instrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_instrContext {
	var p = new(Return_instrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_return_instr

	return p
}

func (s *Return_instrContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_instrContext) Get_RRETURN() antlr.Token { return s._RRETURN }

func (s *Return_instrContext) Set_RRETURN(v antlr.Token) { s._RRETURN = v }

func (s *Return_instrContext) Get_expression() IExpressionContext { return s._expression }

func (s *Return_instrContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Return_instrContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Return_instrContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Return_instrContext) RRETURN() antlr.TerminalNode {
	return s.GetToken(ProjectParserRRETURN, 0)
}

func (s *Return_instrContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Return_instrContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_instrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_instrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_instrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterReturn_instr(s)
	}
}

func (s *Return_instrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitReturn_instr(s)
	}
}

func (p *ProjectParser) Return_instr() (localctx IReturn_instrContext) {
	localctx = NewReturn_instrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ProjectParserRULE_return_instr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)

			var _m = p.Match(ProjectParserRRETURN)

			localctx.(*Return_instrContext)._RRETURN = _m
		}
		{
			p.SetState(837)
			p.Match(ProjectParserSEMICOLON)
		}
		localctx.(*Return_instrContext).instr = Natives.NewReturn((func() int {
			if localctx.(*Return_instrContext).Get_RRETURN() == nil {
				return 0
			} else {
				return localctx.(*Return_instrContext).Get_RRETURN().GetLine()
			}
		}()), localctx.(*Return_instrContext).Get_RRETURN().GetColumn(), nil)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(839)

			var _m = p.Match(ProjectParserRRETURN)

			localctx.(*Return_instrContext)._RRETURN = _m
		}
		{
			p.SetState(840)

			var _x = p.Expression()

			localctx.(*Return_instrContext)._expression = _x
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(841)
				p.Match(ProjectParserSEMICOLON)
			}

		}
		localctx.(*Return_instrContext).instr = Natives.NewReturn((func() int {
			if localctx.(*Return_instrContext).Get_RRETURN() == nil {
				return 0
			} else {
				return localctx.(*Return_instrContext).Get_RRETURN().GetLine()
			}
		}()), localctx.(*Return_instrContext).Get_RRETURN().GetColumn(), localctx.(*Return_instrContext).Get_expression().GetP())

	}

	return localctx
}

// IDec_structContext is an interface to support dynamic dispatch.
type IDec_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_bloq_struct returns the _bloq_struct rule contexts.
	Get_bloq_struct() IBloq_structContext

	// Set_bloq_struct sets the _bloq_struct rule contexts.
	Set_bloq_struct(IBloq_structContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsDec_structContext differentiates from other interfaces.
	IsDec_structContext()
}

type Dec_structContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	instr        Abstract.Instruction
	_ID          antlr.Token
	_bloq_struct IBloq_structContext
}

func NewEmptyDec_structContext() *Dec_structContext {
	var p = new(Dec_structContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_dec_struct
	return p
}

func (*Dec_structContext) IsDec_structContext() {}

func NewDec_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_structContext {
	var p = new(Dec_structContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_dec_struct

	return p
}

func (s *Dec_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_structContext) Get_ID() antlr.Token { return s._ID }

func (s *Dec_structContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Dec_structContext) Get_bloq_struct() IBloq_structContext { return s._bloq_struct }

func (s *Dec_structContext) Set_bloq_struct(v IBloq_structContext) { s._bloq_struct = v }

func (s *Dec_structContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Dec_structContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Dec_structContext) RSTRUCT() antlr.TerminalNode {
	return s.GetToken(ProjectParserRSTRUCT, 0)
}

func (s *Dec_structContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Dec_structContext) Bloq_struct() IBloq_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBloq_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBloq_structContext)
}

func (s *Dec_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dec_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterDec_struct(s)
	}
}

func (s *Dec_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitDec_struct(s)
	}
}

func (p *ProjectParser) Dec_struct() (localctx IDec_structContext) {
	localctx = NewDec_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ProjectParserRULE_dec_struct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(ProjectParserRSTRUCT)
	}
	{
		p.SetState(849)

		var _m = p.Match(ProjectParserID)

		localctx.(*Dec_structContext)._ID = _m
	}
	{
		p.SetState(850)

		var _x = p.Bloq_struct()

		localctx.(*Dec_structContext)._bloq_struct = _x
	}

	localctx.(*Dec_structContext).instr = DecStructs.NewDecStruct((func() string {
		if localctx.(*Dec_structContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Dec_structContext).Get_ID().GetText()
		}
	}()), localctx.(*Dec_structContext).Get_bloq_struct().GetL())

	return localctx
}

// IBloq_structContext is an interface to support dynamic dispatch.
type IBloq_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_content_struct returns the _content_struct rule contexts.
	Get_content_struct() IContent_structContext

	// Set_content_struct sets the _content_struct rule contexts.
	Set_content_struct(IContent_structContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsBloq_structContext differentiates from other interfaces.
	IsBloq_structContext()
}

type Bloq_structContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	l               *arrayList.List
	_content_struct IContent_structContext
}

func NewEmptyBloq_structContext() *Bloq_structContext {
	var p = new(Bloq_structContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_bloq_struct
	return p
}

func (*Bloq_structContext) IsBloq_structContext() {}

func NewBloq_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bloq_structContext {
	var p = new(Bloq_structContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_bloq_struct

	return p
}

func (s *Bloq_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Bloq_structContext) Get_content_struct() IContent_structContext { return s._content_struct }

func (s *Bloq_structContext) Set_content_struct(v IContent_structContext) { s._content_struct = v }

func (s *Bloq_structContext) GetL() *arrayList.List { return s.l }

func (s *Bloq_structContext) SetL(v *arrayList.List) { s.l = v }

func (s *Bloq_structContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *Bloq_structContext) Content_struct() IContent_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContent_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContent_structContext)
}

func (s *Bloq_structContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *Bloq_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bloq_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bloq_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterBloq_struct(s)
	}
}

func (s *Bloq_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitBloq_struct(s)
	}
}

func (p *ProjectParser) Bloq_struct() (localctx IBloq_structContext) {
	localctx = NewBloq_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ProjectParserRULE_bloq_struct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(ProjectParserLEFT_KEY)
	}
	{
		p.SetState(854)

		var _x = p.content_struct(0)

		localctx.(*Bloq_structContext)._content_struct = _x
	}
	{
		p.SetState(855)
		p.Match(ProjectParserRIGHT_KEY)
	}

	localctx.(*Bloq_structContext).l = localctx.(*Bloq_structContext).Get_content_struct().GetL()

	return localctx
}

// IContent_structContext is an interface to support dynamic dispatch.
type IContent_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IContent_structContext

	// Get_item_struct returns the _item_struct rule contexts.
	Get_item_struct() IItem_structContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IContent_structContext)

	// Set_item_struct sets the _item_struct rule contexts.
	Set_item_struct(IItem_structContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsContent_structContext differentiates from other interfaces.
	IsContent_structContext()
}

type Content_structContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	l            *arrayList.List
	subList      IContent_structContext
	_item_struct IItem_structContext
}

func NewEmptyContent_structContext() *Content_structContext {
	var p = new(Content_structContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_content_struct
	return p
}

func (*Content_structContext) IsContent_structContext() {}

func NewContent_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Content_structContext {
	var p = new(Content_structContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_content_struct

	return p
}

func (s *Content_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Content_structContext) GetSubList() IContent_structContext { return s.subList }

func (s *Content_structContext) Get_item_struct() IItem_structContext { return s._item_struct }

func (s *Content_structContext) SetSubList(v IContent_structContext) { s.subList = v }

func (s *Content_structContext) Set_item_struct(v IItem_structContext) { s._item_struct = v }

func (s *Content_structContext) GetL() *arrayList.List { return s.l }

func (s *Content_structContext) SetL(v *arrayList.List) { s.l = v }

func (s *Content_structContext) Item_struct() IItem_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItem_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IItem_structContext)
}

func (s *Content_structContext) Content_struct() IContent_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContent_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContent_structContext)
}

func (s *Content_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Content_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Content_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterContent_struct(s)
	}
}

func (s *Content_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitContent_struct(s)
	}
}

func (p *ProjectParser) Content_struct() (localctx IContent_structContext) {
	return p.content_struct(0)
}

func (p *ProjectParser) content_struct(_p int) (localctx IContent_structContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewContent_structContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IContent_structContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 94
	p.EnterRecursionRule(localctx, 94, ProjectParserRULE_content_struct, _p)

	localctx.(*Content_structContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)

		var _x = p.Item_struct()

		localctx.(*Content_structContext)._item_struct = _x
	}

	localctx.(*Content_structContext).l.Add(localctx.(*Content_structContext).Get_item_struct().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewContent_structContext(p, _parentctx, _parentState)
			localctx.(*Content_structContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_content_struct)
			p.SetState(862)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(863)

				var _x = p.Item_struct()

				localctx.(*Content_structContext)._item_struct = _x
			}

			localctx.(*Content_structContext).GetSubList().GetL().Add(localctx.(*Content_structContext).Get_item_struct().GetP())
			localctx.(*Content_structContext).l = localctx.(*Content_structContext).GetSubList().GetL()

		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())
	}

	return localctx
}

// IItem_structContext is an interface to support dynamic dispatch.
type IItem_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsItem_structContext differentiates from other interfaces.
	IsItem_structContext()
}

type Item_structContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	p          Abstract.Expression
	_ID        antlr.Token
	_data_type IData_typeContext
}

func NewEmptyItem_structContext() *Item_structContext {
	var p = new(Item_structContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_item_struct
	return p
}

func (*Item_structContext) IsItem_structContext() {}

func NewItem_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Item_structContext {
	var p = new(Item_structContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_item_struct

	return p
}

func (s *Item_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Item_structContext) Get_ID() antlr.Token { return s._ID }

func (s *Item_structContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Item_structContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *Item_structContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *Item_structContext) GetP() Abstract.Expression { return s.p }

func (s *Item_structContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Item_structContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Item_structContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *Item_structContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Item_structContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Item_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Item_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Item_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterItem_struct(s)
	}
}

func (s *Item_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitItem_struct(s)
	}
}

func (p *ProjectParser) Item_struct() (localctx IItem_structContext) {
	localctx = NewItem_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ProjectParserRULE_item_struct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)

		var _m = p.Match(ProjectParserID)

		localctx.(*Item_structContext)._ID = _m
	}
	{
		p.SetState(872)
		p.Match(ProjectParserCOLON)
	}
	{
		p.SetState(873)

		var _x = p.Data_type()

		localctx.(*Item_structContext)._data_type = _x
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(874)
			p.Match(ProjectParserCOMMA)
		}

	}

	var data SymbolTable.DataType
	switch localctx.(*Item_structContext).Get_data_type().GetData() {
	case "i64":
		data = SymbolTable.INTEGER
	case "f64":
		data = SymbolTable.FLOAT
	case "&str":
		data = SymbolTable.STR
	case "String":
		data = SymbolTable.STRING
	case "bool":
		data = SymbolTable.BOOLEAN
	}

	localctx.(*Item_structContext).p = Expression.NewItemStruct((func() string {
		if localctx.(*Item_structContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Item_structContext).Get_ID().GetText()
		}
	}()), data, (func() int {
		if localctx.(*Item_structContext).Get_ID() == nil {
			return 0
		} else {
			return localctx.(*Item_structContext).Get_ID().GetLine()
		}
	}()), localctx.(*Item_structContext).Get_ID().GetColumn())

	return localctx
}

// IDec_objectContext is an interface to support dynamic dispatch.
type IDec_objectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// GetOb returns the ob token.
	GetOb() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// SetOb sets the ob token.
	SetOb(antlr.Token)

	// Get_def_items returns the _def_items rule contexts.
	Get_def_items() IDef_itemsContext

	// Set_def_items sets the _def_items rule contexts.
	Set_def_items(IDef_itemsContext)

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsDec_objectContext differentiates from other interfaces.
	IsDec_objectContext()
}

type Dec_objectContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	instr      Abstract.Instruction
	_ID        antlr.Token
	ob         antlr.Token
	_def_items IDef_itemsContext
}

func NewEmptyDec_objectContext() *Dec_objectContext {
	var p = new(Dec_objectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_dec_object
	return p
}

func (*Dec_objectContext) IsDec_objectContext() {}

func NewDec_objectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_objectContext {
	var p = new(Dec_objectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_dec_object

	return p
}

func (s *Dec_objectContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_objectContext) Get_ID() antlr.Token { return s._ID }

func (s *Dec_objectContext) GetOb() antlr.Token { return s.ob }

func (s *Dec_objectContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Dec_objectContext) SetOb(v antlr.Token) { s.ob = v }

func (s *Dec_objectContext) Get_def_items() IDef_itemsContext { return s._def_items }

func (s *Dec_objectContext) Set_def_items(v IDef_itemsContext) { s._def_items = v }

func (s *Dec_objectContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Dec_objectContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Dec_objectContext) DECLARAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserDECLARAR, 0)
}

func (s *Dec_objectContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ProjectParserID)
}

func (s *Dec_objectContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ProjectParserID, i)
}

func (s *Dec_objectContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUAL, 0)
}

func (s *Dec_objectContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *Dec_objectContext) Def_items() IDef_itemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_itemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDef_itemsContext)
}

func (s *Dec_objectContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *Dec_objectContext) MUT() antlr.TerminalNode {
	return s.GetToken(ProjectParserMUT, 0)
}

func (s *Dec_objectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_objectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dec_objectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterDec_object(s)
	}
}

func (s *Dec_objectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitDec_object(s)
	}
}

func (p *ProjectParser) Dec_object() (localctx IDec_objectContext) {
	localctx = NewDec_objectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ProjectParserRULE_dec_object)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(ProjectParserDECLARAR)
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ProjectParserMUT {
		{
			p.SetState(880)
			p.Match(ProjectParserMUT)
		}

	}
	{
		p.SetState(883)

		var _m = p.Match(ProjectParserID)

		localctx.(*Dec_objectContext)._ID = _m
	}
	{
		p.SetState(884)
		p.Match(ProjectParserEQUAL)
	}
	{
		p.SetState(885)

		var _m = p.Match(ProjectParserID)

		localctx.(*Dec_objectContext).ob = _m
	}
	{
		p.SetState(886)
		p.Match(ProjectParserLEFT_KEY)
	}
	{
		p.SetState(887)

		var _x = p.def_items(0)

		localctx.(*Dec_objectContext)._def_items = _x
	}
	{
		p.SetState(888)
		p.Match(ProjectParserRIGHT_KEY)
	}

	localctx.(*Dec_objectContext).instr = DecObjects.NewDecObjects((func() string {
		if localctx.(*Dec_objectContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Dec_objectContext).Get_ID().GetText()
		}
	}()), (func() string {
		if localctx.(*Dec_objectContext).GetOb() == nil {
			return ""
		} else {
			return localctx.(*Dec_objectContext).GetOb().GetText()
		}
	}()), localctx.(*Dec_objectContext).Get_def_items().GetL())

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_conditional_prod returns the _conditional_prod rule contexts.
	Get_conditional_prod() IConditional_prodContext

	// Get_loop_prod returns the _loop_prod rule contexts.
	Get_loop_prod() ILoop_prodContext

	// Get_expr_logic returns the _expr_logic rule contexts.
	Get_expr_logic() IExpr_logicContext

	// Get_expr_rel returns the _expr_rel rule contexts.
	Get_expr_rel() IExpr_relContext

	// Get_arraydata returns the _arraydata rule contexts.
	Get_arraydata() IArraydataContext

	// Get_natives_vector returns the _natives_vector rule contexts.
	Get_natives_vector() INatives_vectorContext

	// Get_type_struct returns the _type_struct rule contexts.
	Get_type_struct() IType_structContext

	// Get_access_object returns the _access_object rule contexts.
	Get_access_object() IAccess_objectContext

	// Set_conditional_prod sets the _conditional_prod rule contexts.
	Set_conditional_prod(IConditional_prodContext)

	// Set_loop_prod sets the _loop_prod rule contexts.
	Set_loop_prod(ILoop_prodContext)

	// Set_expr_logic sets the _expr_logic rule contexts.
	Set_expr_logic(IExpr_logicContext)

	// Set_expr_rel sets the _expr_rel rule contexts.
	Set_expr_rel(IExpr_relContext)

	// Set_arraydata sets the _arraydata rule contexts.
	Set_arraydata(IArraydataContext)

	// Set_natives_vector sets the _natives_vector rule contexts.
	Set_natives_vector(INatives_vectorContext)

	// Set_type_struct sets the _type_struct rule contexts.
	Set_type_struct(IType_structContext)

	// Set_access_object sets the _access_object rule contexts.
	Set_access_object(IAccess_objectContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser            antlr.Parser
	p                 Abstract.Expression
	_conditional_prod IConditional_prodContext
	_loop_prod        ILoop_prodContext
	_expr_logic       IExpr_logicContext
	_expr_rel         IExpr_relContext
	_arraydata        IArraydataContext
	_natives_vector   INatives_vectorContext
	_type_struct      IType_structContext
	_access_object    IAccess_objectContext
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Get_conditional_prod() IConditional_prodContext {
	return s._conditional_prod
}

func (s *ExpressionContext) Get_loop_prod() ILoop_prodContext { return s._loop_prod }

func (s *ExpressionContext) Get_expr_logic() IExpr_logicContext { return s._expr_logic }

func (s *ExpressionContext) Get_expr_rel() IExpr_relContext { return s._expr_rel }

func (s *ExpressionContext) Get_arraydata() IArraydataContext { return s._arraydata }

func (s *ExpressionContext) Get_natives_vector() INatives_vectorContext { return s._natives_vector }

func (s *ExpressionContext) Get_type_struct() IType_structContext { return s._type_struct }

func (s *ExpressionContext) Get_access_object() IAccess_objectContext { return s._access_object }

func (s *ExpressionContext) Set_conditional_prod(v IConditional_prodContext) { s._conditional_prod = v }

func (s *ExpressionContext) Set_loop_prod(v ILoop_prodContext) { s._loop_prod = v }

func (s *ExpressionContext) Set_expr_logic(v IExpr_logicContext) { s._expr_logic = v }

func (s *ExpressionContext) Set_expr_rel(v IExpr_relContext) { s._expr_rel = v }

func (s *ExpressionContext) Set_arraydata(v IArraydataContext) { s._arraydata = v }

func (s *ExpressionContext) Set_natives_vector(v INatives_vectorContext) { s._natives_vector = v }

func (s *ExpressionContext) Set_type_struct(v IType_structContext) { s._type_struct = v }

func (s *ExpressionContext) Set_access_object(v IAccess_objectContext) { s._access_object = v }

func (s *ExpressionContext) GetP() Abstract.Expression { return s.p }

func (s *ExpressionContext) SetP(v Abstract.Expression) { s.p = v }

func (s *ExpressionContext) Conditional_prod() IConditional_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_prodContext)
}

func (s *ExpressionContext) Loop_prod() ILoop_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_prodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_prodContext)
}

func (s *ExpressionContext) Expr_logic() IExpr_logicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_logicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_logicContext)
}

func (s *ExpressionContext) Expr_rel() IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *ExpressionContext) Arraydata() IArraydataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArraydataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArraydataContext)
}

func (s *ExpressionContext) Natives_vector() INatives_vectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INatives_vectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INatives_vectorContext)
}

func (s *ExpressionContext) Type_struct() IType_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_structContext)
}

func (s *ExpressionContext) Access_object() IAccess_objectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_objectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_objectContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *ProjectParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ProjectParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(891)

			var _x = p.Conditional_prod()

			localctx.(*ExpressionContext)._conditional_prod = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_conditional_prod().GetP()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)

			var _x = p.Loop_prod()

			localctx.(*ExpressionContext)._loop_prod = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_loop_prod().GetP()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(897)

			var _x = p.expr_logic(0)

			localctx.(*ExpressionContext)._expr_logic = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_expr_logic().GetP()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(900)

			var _x = p.expr_rel(0)

			localctx.(*ExpressionContext)._expr_rel = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_expr_rel().GetP()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(903)

			var _x = p.Arraydata()

			localctx.(*ExpressionContext)._arraydata = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_arraydata().GetP()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(906)

			var _x = p.Natives_vector()

			localctx.(*ExpressionContext)._natives_vector = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_natives_vector().GetP()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(909)

			var _x = p.Type_struct()

			localctx.(*ExpressionContext)._type_struct = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_type_struct().GetP()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(912)

			var _x = p.Access_object()

			localctx.(*ExpressionContext)._access_object = _x
		}
		localctx.(*ExpressionContext).p = localctx.(*ExpressionContext).Get_access_object().GetP()

	}

	return localctx
}

// IArraydataContext is an interface to support dynamic dispatch.
type IArraydataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listExpressions returns the _listExpressions rule contexts.
	Get_listExpressions() IListExpressionsContext

	// GetE1 returns the e1 rule contexts.
	GetE1() IExpressionContext

	// GetE2 returns the e2 rule contexts.
	GetE2() IExpressionContext

	// Set_listExpressions sets the _listExpressions rule contexts.
	Set_listExpressions(IListExpressionsContext)

	// SetE1 sets the e1 rule contexts.
	SetE1(IExpressionContext)

	// SetE2 sets the e2 rule contexts.
	SetE2(IExpressionContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsArraydataContext differentiates from other interfaces.
	IsArraydataContext()
}

type ArraydataContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	p                Abstract.Expression
	_listExpressions IListExpressionsContext
	e1               IExpressionContext
	e2               IExpressionContext
}

func NewEmptyArraydataContext() *ArraydataContext {
	var p = new(ArraydataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_arraydata
	return p
}

func (*ArraydataContext) IsArraydataContext() {}

func NewArraydataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraydataContext {
	var p = new(ArraydataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_arraydata

	return p
}

func (s *ArraydataContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraydataContext) Get_listExpressions() IListExpressionsContext { return s._listExpressions }

func (s *ArraydataContext) GetE1() IExpressionContext { return s.e1 }

func (s *ArraydataContext) GetE2() IExpressionContext { return s.e2 }

func (s *ArraydataContext) Set_listExpressions(v IListExpressionsContext) { s._listExpressions = v }

func (s *ArraydataContext) SetE1(v IExpressionContext) { s.e1 = v }

func (s *ArraydataContext) SetE2(v IExpressionContext) { s.e2 = v }

func (s *ArraydataContext) GetP() Abstract.Expression { return s.p }

func (s *ArraydataContext) SetP(v Abstract.Expression) { s.p = v }

func (s *ArraydataContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_BRACKET, 0)
}

func (s *ArraydataContext) ListExpressions() IListExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListExpressionsContext)
}

func (s *ArraydataContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_BRACKET, 0)
}

func (s *ArraydataContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *ArraydataContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArraydataContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArraydataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraydataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArraydataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterArraydata(s)
	}
}

func (s *ArraydataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitArraydata(s)
	}
}

func (p *ProjectParser) Arraydata() (localctx IArraydataContext) {
	localctx = NewArraydataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ProjectParserRULE_arraydata)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)
			p.Match(ProjectParserLEFT_BRACKET)
		}
		{
			p.SetState(918)

			var _x = p.listExpressions(0)

			localctx.(*ArraydataContext)._listExpressions = _x
		}
		{
			p.SetState(919)
			p.Match(ProjectParserRIGHT_BRACKET)
		}

		localctx.(*ArraydataContext).p = ExpressionSpecial.NewValueArray(localctx.(*ArraydataContext).Get_listExpressions().GetL(), nil, nil)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			p.Match(ProjectParserLEFT_BRACKET)
		}
		{
			p.SetState(923)

			var _x = p.Expression()

			localctx.(*ArraydataContext).e1 = _x
		}
		{
			p.SetState(924)
			p.Match(ProjectParserSEMICOLON)
		}
		{
			p.SetState(925)

			var _x = p.Expression()

			localctx.(*ArraydataContext).e2 = _x
		}
		{
			p.SetState(926)
			p.Match(ProjectParserRIGHT_BRACKET)
		}

		localctx.(*ArraydataContext).p = ExpressionSpecial.NewValueArray(nil, localctx.(*ArraydataContext).GetE1().GetP(), localctx.(*ArraydataContext).GetE2().GetP())

	}

	return localctx
}

// IAccess_arrayContext is an interface to support dynamic dispatch.
type IAccess_arrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_listInArray returns the _listInArray rule contexts.
	Get_listInArray() IListInArrayContext

	// Set_listInArray sets the _listInArray rule contexts.
	Set_listInArray(IListInArrayContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsAccess_arrayContext differentiates from other interfaces.
	IsAccess_arrayContext()
}

type Access_arrayContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	p            Abstract.Expression
	instr        Abstract.Instruction
	_ID          antlr.Token
	_listInArray IListInArrayContext
}

func NewEmptyAccess_arrayContext() *Access_arrayContext {
	var p = new(Access_arrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_access_array
	return p
}

func (*Access_arrayContext) IsAccess_arrayContext() {}

func NewAccess_arrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_arrayContext {
	var p = new(Access_arrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_access_array

	return p
}

func (s *Access_arrayContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_arrayContext) Get_ID() antlr.Token { return s._ID }

func (s *Access_arrayContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Access_arrayContext) Get_listInArray() IListInArrayContext { return s._listInArray }

func (s *Access_arrayContext) Set_listInArray(v IListInArrayContext) { s._listInArray = v }

func (s *Access_arrayContext) GetP() Abstract.Expression { return s.p }

func (s *Access_arrayContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Access_arrayContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Access_arrayContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Access_arrayContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Access_arrayContext) ListInArray() IListInArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListInArrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListInArrayContext)
}

func (s *Access_arrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_arrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_arrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterAccess_array(s)
	}
}

func (s *Access_arrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitAccess_array(s)
	}
}

func (p *ProjectParser) Access_array() (localctx IAccess_arrayContext) {
	localctx = NewAccess_arrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ProjectParserRULE_access_array)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)

		var _m = p.Match(ProjectParserID)

		localctx.(*Access_arrayContext)._ID = _m
	}
	{
		p.SetState(932)

		var _x = p.listInArray(0)

		localctx.(*Access_arrayContext)._listInArray = _x
	}

	localctx.(*Access_arrayContext).p = Access.NewAccessArray((func() string {
		if localctx.(*Access_arrayContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Access_arrayContext).Get_ID().GetText()
		}
	}()), localctx.(*Access_arrayContext).Get_listInArray().GetL())
	localctx.(*Access_arrayContext).instr = Access.NewAccessArray((func() string {
		if localctx.(*Access_arrayContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Access_arrayContext).Get_ID().GetText()
		}
	}()), localctx.(*Access_arrayContext).Get_listInArray().GetL())

	return localctx
}

// IListInArrayContext is an interface to support dynamic dispatch.
type IListInArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSublist returns the sublist rule contexts.
	GetSublist() IListInArrayContext

	// Get_inArray returns the _inArray rule contexts.
	Get_inArray() IInArrayContext

	// SetSublist sets the sublist rule contexts.
	SetSublist(IListInArrayContext)

	// Set_inArray sets the _inArray rule contexts.
	Set_inArray(IInArrayContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListInArrayContext differentiates from other interfaces.
	IsListInArrayContext()
}

type ListInArrayContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	l        *arrayList.List
	sublist  IListInArrayContext
	_inArray IInArrayContext
}

func NewEmptyListInArrayContext() *ListInArrayContext {
	var p = new(ListInArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listInArray
	return p
}

func (*ListInArrayContext) IsListInArrayContext() {}

func NewListInArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListInArrayContext {
	var p = new(ListInArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listInArray

	return p
}

func (s *ListInArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *ListInArrayContext) GetSublist() IListInArrayContext { return s.sublist }

func (s *ListInArrayContext) Get_inArray() IInArrayContext { return s._inArray }

func (s *ListInArrayContext) SetSublist(v IListInArrayContext) { s.sublist = v }

func (s *ListInArrayContext) Set_inArray(v IInArrayContext) { s._inArray = v }

func (s *ListInArrayContext) GetL() *arrayList.List { return s.l }

func (s *ListInArrayContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListInArrayContext) InArray() IInArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInArrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInArrayContext)
}

func (s *ListInArrayContext) ListInArray() IListInArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListInArrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListInArrayContext)
}

func (s *ListInArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListInArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListInArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListInArray(s)
	}
}

func (s *ListInArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListInArray(s)
	}
}

func (p *ProjectParser) ListInArray() (localctx IListInArrayContext) {
	return p.listInArray(0)
}

func (p *ProjectParser) listInArray(_p int) (localctx IListInArrayContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListInArrayContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListInArrayContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 106
	p.EnterRecursionRule(localctx, 106, ProjectParserRULE_listInArray, _p)

	localctx.(*ListInArrayContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)

		var _x = p.InArray()

		localctx.(*ListInArrayContext)._inArray = _x
	}
	localctx.(*ListInArrayContext).l.Add(localctx.(*ListInArrayContext).Get_inArray().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListInArrayContext(p, _parentctx, _parentState)
			localctx.(*ListInArrayContext).sublist = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listInArray)
			p.SetState(939)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(940)

				var _x = p.InArray()

				localctx.(*ListInArrayContext)._inArray = _x
			}

			localctx.(*ListInArrayContext).GetSublist().GetL().Add(localctx.(*ListInArrayContext).Get_inArray().GetP())
			localctx.(*ListInArrayContext).l = localctx.(*ListInArrayContext).GetSublist().GetL()

		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// IInArrayContext is an interface to support dynamic dispatch.
type IInArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsInArrayContext differentiates from other interfaces.
	IsInArrayContext()
}

type InArrayContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	_expression IExpressionContext
}

func NewEmptyInArrayContext() *InArrayContext {
	var p = new(InArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_inArray
	return p
}

func (*InArrayContext) IsInArrayContext() {}

func NewInArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InArrayContext {
	var p = new(InArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_inArray

	return p
}

func (s *InArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *InArrayContext) Get_expression() IExpressionContext { return s._expression }

func (s *InArrayContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *InArrayContext) GetP() Abstract.Expression { return s.p }

func (s *InArrayContext) SetP(v Abstract.Expression) { s.p = v }

func (s *InArrayContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_BRACKET, 0)
}

func (s *InArrayContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InArrayContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_BRACKET, 0)
}

func (s *InArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterInArray(s)
	}
}

func (s *InArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitInArray(s)
	}
}

func (p *ProjectParser) InArray() (localctx IInArrayContext) {
	localctx = NewInArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ProjectParserRULE_inArray)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.Match(ProjectParserLEFT_BRACKET)
	}
	{
		p.SetState(949)

		var _x = p.Expression()

		localctx.(*InArrayContext)._expression = _x
	}
	{
		p.SetState(950)
		p.Match(ProjectParserRIGHT_BRACKET)
	}
	localctx.(*InArrayContext).p = localctx.(*InArrayContext).Get_expression().GetP()

	return localctx
}

// IAccess_vectorContext is an interface to support dynamic dispatch.
type IAccess_vectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_listInVector returns the _listInVector rule contexts.
	Get_listInVector() IListInVectorContext

	// Set_listInVector sets the _listInVector rule contexts.
	Set_listInVector(IListInVectorContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsAccess_vectorContext differentiates from other interfaces.
	IsAccess_vectorContext()
}

type Access_vectorContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	p             Abstract.Expression
	instr         Abstract.Instruction
	_ID           antlr.Token
	_listInVector IListInVectorContext
}

func NewEmptyAccess_vectorContext() *Access_vectorContext {
	var p = new(Access_vectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_access_vector
	return p
}

func (*Access_vectorContext) IsAccess_vectorContext() {}

func NewAccess_vectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_vectorContext {
	var p = new(Access_vectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_access_vector

	return p
}

func (s *Access_vectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_vectorContext) Get_ID() antlr.Token { return s._ID }

func (s *Access_vectorContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Access_vectorContext) Get_listInVector() IListInVectorContext { return s._listInVector }

func (s *Access_vectorContext) Set_listInVector(v IListInVectorContext) { s._listInVector = v }

func (s *Access_vectorContext) GetP() Abstract.Expression { return s.p }

func (s *Access_vectorContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Access_vectorContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Access_vectorContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Access_vectorContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Access_vectorContext) ListInVector() IListInVectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListInVectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListInVectorContext)
}

func (s *Access_vectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_vectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_vectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterAccess_vector(s)
	}
}

func (s *Access_vectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitAccess_vector(s)
	}
}

func (p *ProjectParser) Access_vector() (localctx IAccess_vectorContext) {
	localctx = NewAccess_vectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ProjectParserRULE_access_vector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)

		var _m = p.Match(ProjectParserID)

		localctx.(*Access_vectorContext)._ID = _m
	}
	{
		p.SetState(954)

		var _x = p.listInVector(0)

		localctx.(*Access_vectorContext)._listInVector = _x
	}

	localctx.(*Access_vectorContext).p = Access.NewAccessVector((func() string {
		if localctx.(*Access_vectorContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Access_vectorContext).Get_ID().GetText()
		}
	}()), localctx.(*Access_vectorContext).Get_listInVector().GetL())
	localctx.(*Access_vectorContext).instr = Access.NewAccessVector((func() string {
		if localctx.(*Access_vectorContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Access_vectorContext).Get_ID().GetText()
		}
	}()), localctx.(*Access_vectorContext).Get_listInVector().GetL())

	return localctx
}

// IListInVectorContext is an interface to support dynamic dispatch.
type IListInVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSublist returns the sublist rule contexts.
	GetSublist() IListInVectorContext

	// Get_inVector returns the _inVector rule contexts.
	Get_inVector() IInVectorContext

	// SetSublist sets the sublist rule contexts.
	SetSublist(IListInVectorContext)

	// Set_inVector sets the _inVector rule contexts.
	Set_inVector(IInVectorContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListInVectorContext differentiates from other interfaces.
	IsListInVectorContext()
}

type ListInVectorContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	l         *arrayList.List
	sublist   IListInVectorContext
	_inVector IInVectorContext
}

func NewEmptyListInVectorContext() *ListInVectorContext {
	var p = new(ListInVectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listInVector
	return p
}

func (*ListInVectorContext) IsListInVectorContext() {}

func NewListInVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListInVectorContext {
	var p = new(ListInVectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listInVector

	return p
}

func (s *ListInVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ListInVectorContext) GetSublist() IListInVectorContext { return s.sublist }

func (s *ListInVectorContext) Get_inVector() IInVectorContext { return s._inVector }

func (s *ListInVectorContext) SetSublist(v IListInVectorContext) { s.sublist = v }

func (s *ListInVectorContext) Set_inVector(v IInVectorContext) { s._inVector = v }

func (s *ListInVectorContext) GetL() *arrayList.List { return s.l }

func (s *ListInVectorContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListInVectorContext) InVector() IInVectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInVectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInVectorContext)
}

func (s *ListInVectorContext) ListInVector() IListInVectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListInVectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListInVectorContext)
}

func (s *ListInVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListInVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListInVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListInVector(s)
	}
}

func (s *ListInVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListInVector(s)
	}
}

func (p *ProjectParser) ListInVector() (localctx IListInVectorContext) {
	return p.listInVector(0)
}

func (p *ProjectParser) listInVector(_p int) (localctx IListInVectorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListInVectorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListInVectorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 112
	p.EnterRecursionRule(localctx, 112, ProjectParserRULE_listInVector, _p)

	localctx.(*ListInVectorContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)

		var _x = p.InVector()

		localctx.(*ListInVectorContext)._inVector = _x
	}
	localctx.(*ListInVectorContext).l.Add(localctx.(*ListInVectorContext).Get_inVector().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListInVectorContext(p, _parentctx, _parentState)
			localctx.(*ListInVectorContext).sublist = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listInVector)
			p.SetState(961)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(962)

				var _x = p.InVector()

				localctx.(*ListInVectorContext)._inVector = _x
			}

			localctx.(*ListInVectorContext).GetSublist().GetL().Add(localctx.(*ListInVectorContext).Get_inVector().GetP())
			localctx.(*ListInVectorContext).l = localctx.(*ListInVectorContext).GetSublist().GetL()

		}
		p.SetState(969)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IInVectorContext is an interface to support dynamic dispatch.
type IInVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsInVectorContext differentiates from other interfaces.
	IsInVectorContext()
}

type InVectorContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	_expression IExpressionContext
}

func NewEmptyInVectorContext() *InVectorContext {
	var p = new(InVectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_inVector
	return p
}

func (*InVectorContext) IsInVectorContext() {}

func NewInVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InVectorContext {
	var p = new(InVectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_inVector

	return p
}

func (s *InVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *InVectorContext) Get_expression() IExpressionContext { return s._expression }

func (s *InVectorContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *InVectorContext) GetP() Abstract.Expression { return s.p }

func (s *InVectorContext) SetP(v Abstract.Expression) { s.p = v }

func (s *InVectorContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_BRACKET, 0)
}

func (s *InVectorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InVectorContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_BRACKET, 0)
}

func (s *InVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterInVector(s)
	}
}

func (s *InVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitInVector(s)
	}
}

func (p *ProjectParser) InVector() (localctx IInVectorContext) {
	localctx = NewInVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ProjectParserRULE_inVector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.Match(ProjectParserLEFT_BRACKET)
	}
	{
		p.SetState(971)

		var _x = p.Expression()

		localctx.(*InVectorContext)._expression = _x
	}
	{
		p.SetState(972)
		p.Match(ProjectParserRIGHT_BRACKET)
	}
	localctx.(*InVectorContext).p = localctx.(*InVectorContext).Get_expression().GetP()

	return localctx
}

// IType_structContext is an interface to support dynamic dispatch.
type IType_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_def_items returns the _def_items rule contexts.
	Get_def_items() IDef_itemsContext

	// Set_def_items sets the _def_items rule contexts.
	Set_def_items(IDef_itemsContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsType_structContext differentiates from other interfaces.
	IsType_structContext()
}

type Type_structContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	p          Abstract.Expression
	_ID        antlr.Token
	_def_items IDef_itemsContext
}

func NewEmptyType_structContext() *Type_structContext {
	var p = new(Type_structContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_type_struct
	return p
}

func (*Type_structContext) IsType_structContext() {}

func NewType_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_structContext {
	var p = new(Type_structContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_type_struct

	return p
}

func (s *Type_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_structContext) Get_ID() antlr.Token { return s._ID }

func (s *Type_structContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *Type_structContext) Get_def_items() IDef_itemsContext { return s._def_items }

func (s *Type_structContext) Set_def_items(v IDef_itemsContext) { s._def_items = v }

func (s *Type_structContext) GetP() Abstract.Expression { return s.p }

func (s *Type_structContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Type_structContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *Type_structContext) LEFT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_KEY, 0)
}

func (s *Type_structContext) Def_items() IDef_itemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_itemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDef_itemsContext)
}

func (s *Type_structContext) RIGHT_KEY() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_KEY, 0)
}

func (s *Type_structContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Type_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterType_struct(s)
	}
}

func (s *Type_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitType_struct(s)
	}
}

func (p *ProjectParser) Type_struct() (localctx IType_structContext) {
	localctx = NewType_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ProjectParserRULE_type_struct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)

		var _m = p.Match(ProjectParserID)

		localctx.(*Type_structContext)._ID = _m
	}
	{
		p.SetState(976)
		p.Match(ProjectParserLEFT_KEY)
	}
	{
		p.SetState(977)

		var _x = p.def_items(0)

		localctx.(*Type_structContext)._def_items = _x
	}
	{
		p.SetState(978)
		p.Match(ProjectParserRIGHT_KEY)
	}
	{
		p.SetState(979)
		p.Match(ProjectParserSEMICOLON)
	}
	localctx.(*Type_structContext).p = Objects.NewObject((func() string {
		if localctx.(*Type_structContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*Type_structContext).Get_ID().GetText()
		}
	}()), localctx.(*Type_structContext).Get_def_items().GetL())

	return localctx
}

// IDef_itemsContext is an interface to support dynamic dispatch.
type IDef_itemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IDef_itemsContext

	// Get_item returns the _item rule contexts.
	Get_item() IItemContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IDef_itemsContext)

	// Set_item sets the _item rule contexts.
	Set_item(IItemContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsDef_itemsContext differentiates from other interfaces.
	IsDef_itemsContext()
}

type Def_itemsContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	l       *arrayList.List
	subList IDef_itemsContext
	_item   IItemContext
}

func NewEmptyDef_itemsContext() *Def_itemsContext {
	var p = new(Def_itemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_def_items
	return p
}

func (*Def_itemsContext) IsDef_itemsContext() {}

func NewDef_itemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Def_itemsContext {
	var p = new(Def_itemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_def_items

	return p
}

func (s *Def_itemsContext) GetParser() antlr.Parser { return s.parser }

func (s *Def_itemsContext) GetSubList() IDef_itemsContext { return s.subList }

func (s *Def_itemsContext) Get_item() IItemContext { return s._item }

func (s *Def_itemsContext) SetSubList(v IDef_itemsContext) { s.subList = v }

func (s *Def_itemsContext) Set_item(v IItemContext) { s._item = v }

func (s *Def_itemsContext) GetL() *arrayList.List { return s.l }

func (s *Def_itemsContext) SetL(v *arrayList.List) { s.l = v }

func (s *Def_itemsContext) Item() IItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IItemContext)
}

func (s *Def_itemsContext) Def_items() IDef_itemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_itemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDef_itemsContext)
}

func (s *Def_itemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Def_itemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Def_itemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterDef_items(s)
	}
}

func (s *Def_itemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitDef_items(s)
	}
}

func (p *ProjectParser) Def_items() (localctx IDef_itemsContext) {
	return p.def_items(0)
}

func (p *ProjectParser) def_items(_p int) (localctx IDef_itemsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDef_itemsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDef_itemsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, ProjectParserRULE_def_items, _p)

	localctx.(*Def_itemsContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)

		var _x = p.Item()

		localctx.(*Def_itemsContext)._item = _x
	}
	localctx.(*Def_itemsContext).l.Add(localctx.(*Def_itemsContext).Get_item().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDef_itemsContext(p, _parentctx, _parentState)
			localctx.(*Def_itemsContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_def_items)
			p.SetState(986)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(987)

				var _x = p.Item()

				localctx.(*Def_itemsContext)._item = _x
			}

			localctx.(*Def_itemsContext).GetSubList().GetL().Add(localctx.(*Def_itemsContext).Get_item().GetP())
			localctx.(*Def_itemsContext).l = localctx.(*Def_itemsContext).GetSubList().GetL()

		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}

	return localctx
}

// IItemContext is an interface to support dynamic dispatch.
type IItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsItemContext differentiates from other interfaces.
	IsItemContext()
}

type ItemContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	_ID         antlr.Token
	_expression IExpressionContext
}

func NewEmptyItemContext() *ItemContext {
	var p = new(ItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_item
	return p
}

func (*ItemContext) IsItemContext() {}

func NewItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemContext {
	var p = new(ItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_item

	return p
}

func (s *ItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemContext) Get_ID() antlr.Token { return s._ID }

func (s *ItemContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ItemContext) Get_expression() IExpressionContext { return s._expression }

func (s *ItemContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ItemContext) GetP() Abstract.Expression { return s.p }

func (s *ItemContext) SetP(v Abstract.Expression) { s.p = v }

func (s *ItemContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *ItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOLON, 0)
}

func (s *ItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ItemContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *ItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterItem(s)
	}
}

func (s *ItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitItem(s)
	}
}

func (p *ProjectParser) Item() (localctx IItemContext) {
	localctx = NewItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ProjectParserRULE_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)

		var _m = p.Match(ProjectParserID)

		localctx.(*ItemContext)._ID = _m
	}
	{
		p.SetState(996)
		p.Match(ProjectParserCOLON)
	}
	{
		p.SetState(997)

		var _x = p.Expression()

		localctx.(*ItemContext)._expression = _x
	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(998)
			p.Match(ProjectParserCOMMA)
		}

	}
	localctx.(*ItemContext).SetP(Objects.NewAttribute((func() string {
		if localctx.(*ItemContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*ItemContext).Get_ID().GetText()
		}
	}()), localctx.(*ItemContext).Get_expression().GetP()))

	return localctx
}

// IAccess_objectContext is an interface to support dynamic dispatch.
type IAccess_objectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listAccess returns the _listAccess rule contexts.
	Get_listAccess() IListAccessContext

	// Set_listAccess sets the _listAccess rule contexts.
	Set_listAccess(IListAccessContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsAccess_objectContext differentiates from other interfaces.
	IsAccess_objectContext()
}

type Access_objectContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	_listAccess IListAccessContext
}

func NewEmptyAccess_objectContext() *Access_objectContext {
	var p = new(Access_objectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_access_object
	return p
}

func (*Access_objectContext) IsAccess_objectContext() {}

func NewAccess_objectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_objectContext {
	var p = new(Access_objectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_access_object

	return p
}

func (s *Access_objectContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_objectContext) Get_listAccess() IListAccessContext { return s._listAccess }

func (s *Access_objectContext) Set_listAccess(v IListAccessContext) { s._listAccess = v }

func (s *Access_objectContext) GetP() Abstract.Expression { return s.p }

func (s *Access_objectContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Access_objectContext) ListAccess() IListAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListAccessContext)
}

func (s *Access_objectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_objectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_objectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterAccess_object(s)
	}
}

func (s *Access_objectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitAccess_object(s)
	}
}

func (p *ProjectParser) Access_object() (localctx IAccess_objectContext) {
	localctx = NewAccess_objectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ProjectParserRULE_access_object)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)

		var _x = p.listAccess(0)

		localctx.(*Access_objectContext)._listAccess = _x
	}
	localctx.(*Access_objectContext).p = Access.NewObjectAccess(localctx.(*Access_objectContext).Get_listAccess().GetL())

	return localctx
}

// IListAccessContext is an interface to support dynamic dispatch.
type IListAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSubList returns the subList rule contexts.
	GetSubList() IListAccessContext

	// Get_access returns the _access rule contexts.
	Get_access() IAccessContext

	// SetSubList sets the subList rule contexts.
	SetSubList(IListAccessContext)

	// Set_access sets the _access rule contexts.
	Set_access(IAccessContext)

	// GetL returns the l attribute.
	GetL() *arrayList.List

	// SetL sets the l attribute.
	SetL(*arrayList.List)

	// IsListAccessContext differentiates from other interfaces.
	IsListAccessContext()
}

type ListAccessContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	l       *arrayList.List
	subList IListAccessContext
	_access IAccessContext
}

func NewEmptyListAccessContext() *ListAccessContext {
	var p = new(ListAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_listAccess
	return p
}

func (*ListAccessContext) IsListAccessContext() {}

func NewListAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListAccessContext {
	var p = new(ListAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_listAccess

	return p
}

func (s *ListAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *ListAccessContext) GetSubList() IListAccessContext { return s.subList }

func (s *ListAccessContext) Get_access() IAccessContext { return s._access }

func (s *ListAccessContext) SetSubList(v IListAccessContext) { s.subList = v }

func (s *ListAccessContext) Set_access(v IAccessContext) { s._access = v }

func (s *ListAccessContext) GetL() *arrayList.List { return s.l }

func (s *ListAccessContext) SetL(v *arrayList.List) { s.l = v }

func (s *ListAccessContext) Access() IAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessContext)
}

func (s *ListAccessContext) DOT() antlr.TerminalNode {
	return s.GetToken(ProjectParserDOT, 0)
}

func (s *ListAccessContext) ListAccess() IListAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListAccessContext)
}

func (s *ListAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterListAccess(s)
	}
}

func (s *ListAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitListAccess(s)
	}
}

func (p *ProjectParser) ListAccess() (localctx IListAccessContext) {
	return p.listAccess(0)
}

func (p *ProjectParser) listAccess(_p int) (localctx IListAccessContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewListAccessContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListAccessContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 124
	p.EnterRecursionRule(localctx, 124, ProjectParserRULE_listAccess, _p)

	localctx.(*ListAccessContext).l = arrayList.New()

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)

		var _x = p.Access()

		localctx.(*ListAccessContext)._access = _x
	}
	localctx.(*ListAccessContext).l.Add(localctx.(*ListAccessContext).Get_access().GetP())

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListAccessContext(p, _parentctx, _parentState)
			localctx.(*ListAccessContext).subList = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_listAccess)
			p.SetState(1010)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1011)
				p.Match(ProjectParserDOT)
			}
			{
				p.SetState(1012)

				var _x = p.Access()

				localctx.(*ListAccessContext)._access = _x
			}

			localctx.(*ListAccessContext).GetSubList().GetL().Add(localctx.(*ListAccessContext).Get_access().GetP())
			localctx.(*ListAccessContext).l = localctx.(*ListAccessContext).GetSubList().GetL()

		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}

	return localctx
}

// IAccessContext is an interface to support dynamic dispatch.
type IAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// IsAccessContext differentiates from other interfaces.
	IsAccessContext()
}

type AccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	p      Abstract.Expression
	_ID    antlr.Token
}

func NewEmptyAccessContext() *AccessContext {
	var p = new(AccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_access
	return p
}

func (*AccessContext) IsAccessContext() {}

func NewAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessContext {
	var p = new(AccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_access

	return p
}

func (s *AccessContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessContext) Get_ID() antlr.Token { return s._ID }

func (s *AccessContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *AccessContext) GetP() Abstract.Expression { return s.p }

func (s *AccessContext) SetP(v Abstract.Expression) { s.p = v }

func (s *AccessContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *AccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterAccess(s)
	}
}

func (s *AccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitAccess(s)
	}
}

func (p *ProjectParser) Access() (localctx IAccessContext) {
	localctx = NewAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ProjectParserRULE_access)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)

		var _m = p.Match(ProjectParserID)

		localctx.(*AccessContext)._ID = _m
	}
	localctx.(*AccessContext).p = Expression.NewIdentifier((func() string {
		if localctx.(*AccessContext).Get_ID() == nil {
			return ""
		} else {
			return localctx.(*AccessContext).Get_ID().GetText()
		}
	}()), (func() int {
		if localctx.(*AccessContext).Get_ID() == nil {
			return 0
		} else {
			return localctx.(*AccessContext).Get_ID().GetLine()
		}
	}()), localctx.(*AccessContext).Get_ID().GetColumn())

	return localctx
}

// IExpr_relContext is an interface to support dynamic dispatch.
type IExpr_relContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetOpLeft returns the opLeft rule contexts.
	GetOpLeft() IExpr_relContext

	// Get_expr_arit returns the _expr_arit rule contexts.
	Get_expr_arit() IExpr_aritContext

	// GetOpRight returns the opRight rule contexts.
	GetOpRight() IExpr_relContext

	// SetOpLeft sets the opLeft rule contexts.
	SetOpLeft(IExpr_relContext)

	// Set_expr_arit sets the _expr_arit rule contexts.
	Set_expr_arit(IExpr_aritContext)

	// SetOpRight sets the opRight rule contexts.
	SetOpRight(IExpr_relContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsExpr_relContext differentiates from other interfaces.
	IsExpr_relContext()
}

type Expr_relContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	p          Abstract.Expression
	instr      Abstract.Instruction
	opLeft     IExpr_relContext
	_expr_arit IExpr_aritContext
	op         antlr.Token
	opRight    IExpr_relContext
}

func NewEmptyExpr_relContext() *Expr_relContext {
	var p = new(Expr_relContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_rel
	return p
}

func (*Expr_relContext) IsExpr_relContext() {}

func NewExpr_relContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_relContext {
	var p = new(Expr_relContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_rel

	return p
}

func (s *Expr_relContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_relContext) GetOp() antlr.Token { return s.op }

func (s *Expr_relContext) SetOp(v antlr.Token) { s.op = v }

func (s *Expr_relContext) GetOpLeft() IExpr_relContext { return s.opLeft }

func (s *Expr_relContext) Get_expr_arit() IExpr_aritContext { return s._expr_arit }

func (s *Expr_relContext) GetOpRight() IExpr_relContext { return s.opRight }

func (s *Expr_relContext) SetOpLeft(v IExpr_relContext) { s.opLeft = v }

func (s *Expr_relContext) Set_expr_arit(v IExpr_aritContext) { s._expr_arit = v }

func (s *Expr_relContext) SetOpRight(v IExpr_relContext) { s.opRight = v }

func (s *Expr_relContext) GetP() Abstract.Expression { return s.p }

func (s *Expr_relContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Expr_relContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Expr_relContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Expr_relContext) Expr_arit() IExpr_aritContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_aritContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_aritContext)
}

func (s *Expr_relContext) AllExpr_rel() []IExpr_relContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_relContext)(nil)).Elem())
	var tst = make([]IExpr_relContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_relContext)
		}
	}

	return tst
}

func (s *Expr_relContext) Expr_rel(i int) IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_relContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserGREATER_THAN, 0)
}

func (s *Expr_relContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserLESS_THAN, 0)
}

func (s *Expr_relContext) GREATER_EQUALTHAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserGREATER_EQUALTHAN, 0)
}

func (s *Expr_relContext) LESS_EQUEALTHAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserLESS_EQUEALTHAN, 0)
}

func (s *Expr_relContext) EQUEAL_EQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserEQUEAL_EQUAL, 0)
}

func (s *Expr_relContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserNOTEQUAL, 0)
}

func (s *Expr_relContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_relContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_relContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_rel(s)
	}
}

func (s *Expr_relContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_rel(s)
	}
}

func (p *ProjectParser) Expr_rel() (localctx IExpr_relContext) {
	return p.expr_rel(0)
}

func (p *ProjectParser) expr_rel(_p int) (localctx IExpr_relContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpr_relContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpr_relContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 128
	p.EnterRecursionRule(localctx, 128, ProjectParserRULE_expr_rel, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)

		var _x = p.expr_arit(0)

		localctx.(*Expr_relContext)._expr_arit = _x
	}

	localctx.(*Expr_relContext).p = localctx.(*Expr_relContext).Get_expr_arit().GetP()
	localctx.(*Expr_relContext).instr = localctx.(*Expr_relContext).Get_expr_arit().GetInstr()

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpr_relContext(p, _parentctx, _parentState)
			localctx.(*Expr_relContext).opLeft = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_expr_rel)
			p.SetState(1027)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1028)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*Expr_relContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(ProjectParserEQUEAL_EQUAL-61))|(1<<(ProjectParserNOTEQUAL-61))|(1<<(ProjectParserGREATER_THAN-61))|(1<<(ProjectParserLESS_THAN-61))|(1<<(ProjectParserGREATER_EQUALTHAN-61))|(1<<(ProjectParserLESS_EQUEALTHAN-61)))) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*Expr_relContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1029)

				var _x = p.expr_rel(3)

				localctx.(*Expr_relContext).opRight = _x
			}

			localctx.(*Expr_relContext).p = Expression.NewOperation(localctx.(*Expr_relContext).GetOpLeft().GetP(), (func() string {
				if localctx.(*Expr_relContext).GetOp() == nil {
					return ""
				} else {
					return localctx.(*Expr_relContext).GetOp().GetText()
				}
			}()), localctx.(*Expr_relContext).GetOpRight().GetP(), false, (func() int {
				if localctx.(*Expr_relContext).GetOp() == nil {
					return 0
				} else {
					return localctx.(*Expr_relContext).GetOp().GetLine()
				}
			}()), localctx.(*Expr_relContext).GetOp().GetColumn())
			localctx.(*Expr_relContext).instr = Expression.NewOperation(localctx.(*Expr_relContext).GetOpLeft().GetP(), (func() string {
				if localctx.(*Expr_relContext).GetOp() == nil {
					return ""
				} else {
					return localctx.(*Expr_relContext).GetOp().GetText()
				}
			}()), localctx.(*Expr_relContext).GetOpRight().GetP(), false, (func() int {
				if localctx.(*Expr_relContext).GetOp() == nil {
					return 0
				} else {
					return localctx.(*Expr_relContext).GetOp().GetLine()
				}
			}()), localctx.(*Expr_relContext).GetOp().GetColumn())

		}
		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_aritContext is an interface to support dynamic dispatch.
type IExpr_aritContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetOpLeft returns the opLeft rule contexts.
	GetOpLeft() IExpr_aritContext

	// GetOpU returns the opU rule contexts.
	GetOpU() IExpressionContext

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_pow_op returns the _pow_op rule contexts.
	Get_pow_op() IPow_opContext

	// GetOpRight returns the opRight rule contexts.
	GetOpRight() IExpr_aritContext

	// Get_expr_valor returns the _expr_valor rule contexts.
	Get_expr_valor() IExpr_valorContext

	// SetOpLeft sets the opLeft rule contexts.
	SetOpLeft(IExpr_aritContext)

	// SetOpU sets the opU rule contexts.
	SetOpU(IExpressionContext)

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_pow_op sets the _pow_op rule contexts.
	Set_pow_op(IPow_opContext)

	// SetOpRight sets the opRight rule contexts.
	SetOpRight(IExpr_aritContext)

	// Set_expr_valor sets the _expr_valor rule contexts.
	Set_expr_valor(IExpr_valorContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsExpr_aritContext differentiates from other interfaces.
	IsExpr_aritContext()
}

type Expr_aritContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	instr       Abstract.Instruction
	opLeft      IExpr_aritContext
	opU         IExpressionContext
	_expression IExpressionContext
	_pow_op     IPow_opContext
	opRight     IExpr_aritContext
	_expr_valor IExpr_valorContext
	op          antlr.Token
}

func NewEmptyExpr_aritContext() *Expr_aritContext {
	var p = new(Expr_aritContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_arit
	return p
}

func (*Expr_aritContext) IsExpr_aritContext() {}

func NewExpr_aritContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_aritContext {
	var p = new(Expr_aritContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_arit

	return p
}

func (s *Expr_aritContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_aritContext) GetOp() antlr.Token { return s.op }

func (s *Expr_aritContext) SetOp(v antlr.Token) { s.op = v }

func (s *Expr_aritContext) GetOpLeft() IExpr_aritContext { return s.opLeft }

func (s *Expr_aritContext) GetOpU() IExpressionContext { return s.opU }

func (s *Expr_aritContext) Get_expression() IExpressionContext { return s._expression }

func (s *Expr_aritContext) Get_pow_op() IPow_opContext { return s._pow_op }

func (s *Expr_aritContext) GetOpRight() IExpr_aritContext { return s.opRight }

func (s *Expr_aritContext) Get_expr_valor() IExpr_valorContext { return s._expr_valor }

func (s *Expr_aritContext) SetOpLeft(v IExpr_aritContext) { s.opLeft = v }

func (s *Expr_aritContext) SetOpU(v IExpressionContext) { s.opU = v }

func (s *Expr_aritContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Expr_aritContext) Set_pow_op(v IPow_opContext) { s._pow_op = v }

func (s *Expr_aritContext) SetOpRight(v IExpr_aritContext) { s.opRight = v }

func (s *Expr_aritContext) Set_expr_valor(v IExpr_valorContext) { s._expr_valor = v }

func (s *Expr_aritContext) GetP() Abstract.Expression { return s.p }

func (s *Expr_aritContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Expr_aritContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Expr_aritContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Expr_aritContext) SUB() antlr.TerminalNode {
	return s.GetToken(ProjectParserSUB, 0)
}

func (s *Expr_aritContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_aritContext) Pow_op() IPow_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPow_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPow_opContext)
}

func (s *Expr_aritContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *Expr_aritContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ProjectParserCOMMA, 0)
}

func (s *Expr_aritContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *Expr_aritContext) AllExpr_arit() []IExpr_aritContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_aritContext)(nil)).Elem())
	var tst = make([]IExpr_aritContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_aritContext)
		}
	}

	return tst
}

func (s *Expr_aritContext) Expr_arit(i int) IExpr_aritContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_aritContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_aritContext)
}

func (s *Expr_aritContext) Expr_valor() IExpr_valorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_valorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_valorContext)
}

func (s *Expr_aritContext) MUL() antlr.TerminalNode {
	return s.GetToken(ProjectParserMUL, 0)
}

func (s *Expr_aritContext) DIV() antlr.TerminalNode {
	return s.GetToken(ProjectParserDIV, 0)
}

func (s *Expr_aritContext) MOD() antlr.TerminalNode {
	return s.GetToken(ProjectParserMOD, 0)
}

func (s *Expr_aritContext) ADD() antlr.TerminalNode {
	return s.GetToken(ProjectParserADD, 0)
}

func (s *Expr_aritContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_aritContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_aritContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_arit(s)
	}
}

func (s *Expr_aritContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_arit(s)
	}
}

func (p *ProjectParser) Expr_arit() (localctx IExpr_aritContext) {
	return p.expr_arit(0)
}

func (p *ProjectParser) expr_arit(_p int) (localctx IExpr_aritContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpr_aritContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpr_aritContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, ProjectParserRULE_expr_arit, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1038)
			p.Match(ProjectParserSUB)
		}
		{
			p.SetState(1039)

			var _x = p.Expression()

			localctx.(*Expr_aritContext).opU = _x
			localctx.(*Expr_aritContext)._expression = _x
		}

		localctx.(*Expr_aritContext).p = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpU().GetP(), "-", nil, true, localctx.(*Expr_aritContext).GetOpU().GetStart().GetLine(), localctx.(*Expr_aritContext).GetOpU().GetStart().GetColumn())
		localctx.(*Expr_aritContext).instr = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpU().GetP(), "-", nil, true, localctx.(*Expr_aritContext).GetOpU().GetStart().GetLine(), localctx.(*Expr_aritContext).GetOpU().GetStart().GetColumn())

	case 2:
		{
			p.SetState(1042)

			var _x = p.Pow_op()

			localctx.(*Expr_aritContext)._pow_op = _x
		}
		{
			p.SetState(1043)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(1044)

			var _x = p.expr_arit(0)

			localctx.(*Expr_aritContext).opLeft = _x
		}
		{
			p.SetState(1045)
			p.Match(ProjectParserCOMMA)
		}
		{
			p.SetState(1046)

			var _x = p.expr_arit(0)

			localctx.(*Expr_aritContext).opRight = _x
		}
		{
			p.SetState(1047)
			p.Match(ProjectParserRIGHT_PAR)
		}

		localctx.(*Expr_aritContext).p = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpLeft().GetP(), localctx.(*Expr_aritContext).Get_pow_op().GetOp(), localctx.(*Expr_aritContext).GetOpRight().GetP(), false, localctx.(*Expr_aritContext).Get_pow_op().GetStart().GetLine(), localctx.(*Expr_aritContext).Get_pow_op().GetStart().GetColumn())
		localctx.(*Expr_aritContext).instr = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpLeft().GetP(), localctx.(*Expr_aritContext).Get_pow_op().GetOp(), localctx.(*Expr_aritContext).GetOpRight().GetP(), false, localctx.(*Expr_aritContext).Get_pow_op().GetStart().GetLine(), localctx.(*Expr_aritContext).Get_pow_op().GetStart().GetColumn())

	case 3:
		{
			p.SetState(1050)

			var _x = p.Expr_valor()

			localctx.(*Expr_aritContext)._expr_valor = _x
		}

		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_expr_valor().GetP()
		localctx.(*Expr_aritContext).instr = localctx.(*Expr_aritContext).Get_expr_valor().GetInstr()

	case 4:
		{
			p.SetState(1053)
			p.Match(ProjectParserLEFT_PAR)
		}
		{
			p.SetState(1054)

			var _x = p.Expression()

			localctx.(*Expr_aritContext)._expression = _x
		}
		{
			p.SetState(1055)
			p.Match(ProjectParserRIGHT_PAR)
		}

		localctx.(*Expr_aritContext).p = localctx.(*Expr_aritContext).Get_expression().GetP()
		localctx.(*Expr_aritContext).instr = nil

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1070)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opLeft = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_expr_arit)
				p.SetState(1060)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1061)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Expr_aritContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(ProjectParserMUL-67))|(1<<(ProjectParserDIV-67))|(1<<(ProjectParserMOD-67)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Expr_aritContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1062)

					var _x = p.expr_arit(5)

					localctx.(*Expr_aritContext).opRight = _x
				}

				localctx.(*Expr_aritContext).p = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpLeft().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpRight().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())
				localctx.(*Expr_aritContext).instr = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpLeft().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpRight().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			case 2:
				localctx = NewExpr_aritContext(p, _parentctx, _parentState)
				localctx.(*Expr_aritContext).opLeft = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_expr_arit)
				p.SetState(1065)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1066)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Expr_aritContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ProjectParserADD || _la == ProjectParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Expr_aritContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1067)

					var _x = p.expr_arit(4)

					localctx.(*Expr_aritContext).opRight = _x
				}

				localctx.(*Expr_aritContext).p = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpLeft().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpRight().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())
				localctx.(*Expr_aritContext).instr = Expression.NewOperation(localctx.(*Expr_aritContext).GetOpLeft().GetP(), (func() string {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetText()
					}
				}()), localctx.(*Expr_aritContext).GetOpRight().GetP(), false, (func() int {
					if localctx.(*Expr_aritContext).GetOp() == nil {
						return 0
					} else {
						return localctx.(*Expr_aritContext).GetOp().GetLine()
					}
				}()), localctx.(*Expr_aritContext).GetOp().GetColumn())

			}

		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_valorContext is an interface to support dynamic dispatch.
type IExpr_valorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_called_func returns the _called_func rule contexts.
	Get_called_func() ICalled_funcContext

	// Get_primitive returns the _primitive rule contexts.
	Get_primitive() IPrimitiveContext

	// Get_expr_cast returns the _expr_cast rule contexts.
	Get_expr_cast() IExpr_castContext

	// Get_access_array returns the _access_array rule contexts.
	Get_access_array() IAccess_arrayContext

	// Get_access_vector returns the _access_vector rule contexts.
	Get_access_vector() IAccess_vectorContext

	// Set_called_func sets the _called_func rule contexts.
	Set_called_func(ICalled_funcContext)

	// Set_primitive sets the _primitive rule contexts.
	Set_primitive(IPrimitiveContext)

	// Set_expr_cast sets the _expr_cast rule contexts.
	Set_expr_cast(IExpr_castContext)

	// Set_access_array sets the _access_array rule contexts.
	Set_access_array(IAccess_arrayContext)

	// Set_access_vector sets the _access_vector rule contexts.
	Set_access_vector(IAccess_vectorContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsExpr_valorContext differentiates from other interfaces.
	IsExpr_valorContext()
}

type Expr_valorContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	p              Abstract.Expression
	instr          Abstract.Instruction
	_called_func   ICalled_funcContext
	_primitive     IPrimitiveContext
	_expr_cast     IExpr_castContext
	_access_array  IAccess_arrayContext
	_access_vector IAccess_vectorContext
}

func NewEmptyExpr_valorContext() *Expr_valorContext {
	var p = new(Expr_valorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_valor
	return p
}

func (*Expr_valorContext) IsExpr_valorContext() {}

func NewExpr_valorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_valorContext {
	var p = new(Expr_valorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_valor

	return p
}

func (s *Expr_valorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_valorContext) Get_called_func() ICalled_funcContext { return s._called_func }

func (s *Expr_valorContext) Get_primitive() IPrimitiveContext { return s._primitive }

func (s *Expr_valorContext) Get_expr_cast() IExpr_castContext { return s._expr_cast }

func (s *Expr_valorContext) Get_access_array() IAccess_arrayContext { return s._access_array }

func (s *Expr_valorContext) Get_access_vector() IAccess_vectorContext { return s._access_vector }

func (s *Expr_valorContext) Set_called_func(v ICalled_funcContext) { s._called_func = v }

func (s *Expr_valorContext) Set_primitive(v IPrimitiveContext) { s._primitive = v }

func (s *Expr_valorContext) Set_expr_cast(v IExpr_castContext) { s._expr_cast = v }

func (s *Expr_valorContext) Set_access_array(v IAccess_arrayContext) { s._access_array = v }

func (s *Expr_valorContext) Set_access_vector(v IAccess_vectorContext) { s._access_vector = v }

func (s *Expr_valorContext) GetP() Abstract.Expression { return s.p }

func (s *Expr_valorContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Expr_valorContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Expr_valorContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Expr_valorContext) Called_func() ICalled_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalled_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalled_funcContext)
}

func (s *Expr_valorContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ProjectParserSEMICOLON, 0)
}

func (s *Expr_valorContext) Primitive() IPrimitiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveContext)
}

func (s *Expr_valorContext) Expr_cast() IExpr_castContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_castContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_castContext)
}

func (s *Expr_valorContext) Access_array() IAccess_arrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_arrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_arrayContext)
}

func (s *Expr_valorContext) Access_vector() IAccess_vectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_vectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_vectorContext)
}

func (s *Expr_valorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_valorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_valorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_valor(s)
	}
}

func (s *Expr_valorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_valor(s)
	}
}

func (p *ProjectParser) Expr_valor() (localctx IExpr_valorContext) {
	localctx = NewExpr_valorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ProjectParserRULE_expr_valor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1075)

			var _x = p.Called_func()

			localctx.(*Expr_valorContext)._called_func = _x
		}
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1076)
				p.Match(ProjectParserSEMICOLON)
			}

		}

		localctx.(*Expr_valorContext).p = localctx.(*Expr_valorContext).Get_called_func().GetP()
		localctx.(*Expr_valorContext).instr = localctx.(*Expr_valorContext).Get_called_func().GetInstr()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1081)

			var _x = p.Primitive()

			localctx.(*Expr_valorContext)._primitive = _x
		}

		localctx.(*Expr_valorContext).p = localctx.(*Expr_valorContext).Get_primitive().GetP()
		localctx.(*Expr_valorContext).instr = localctx.(*Expr_valorContext).Get_primitive().GetInstr()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1084)

			var _x = p.Expr_cast()

			localctx.(*Expr_valorContext)._expr_cast = _x
		}

		localctx.(*Expr_valorContext).p = localctx.(*Expr_valorContext).Get_expr_cast().GetP()
		localctx.(*Expr_valorContext).instr = localctx.(*Expr_valorContext).Get_expr_cast().GetInstr()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1087)

			var _x = p.Access_array()

			localctx.(*Expr_valorContext)._access_array = _x
		}

		localctx.(*Expr_valorContext).p = localctx.(*Expr_valorContext).Get_access_array().GetP()
		localctx.(*Expr_valorContext).instr = localctx.(*Expr_valorContext).Get_access_array().GetInstr()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1090)

			var _x = p.Access_vector()

			localctx.(*Expr_valorContext)._access_vector = _x
		}

		localctx.(*Expr_valorContext).p = localctx.(*Expr_valorContext).Get_access_vector().GetP()
		localctx.(*Expr_valorContext).instr = localctx.(*Expr_valorContext).Get_access_vector().GetInstr()

	}

	return localctx
}

// IPow_opContext is an interface to support dynamic dispatch.
type IPow_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_POWI returns the _POWI token.
	Get_POWI() antlr.Token

	// Get_POWF returns the _POWF token.
	Get_POWF() antlr.Token

	// Set_POWI sets the _POWI token.
	Set_POWI(antlr.Token)

	// Set_POWF sets the _POWF token.
	Set_POWF(antlr.Token)

	// GetOp returns the op attribute.
	GetOp() string

	// SetOp sets the op attribute.
	SetOp(string)

	// IsPow_opContext differentiates from other interfaces.
	IsPow_opContext()
}

type Pow_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     string
	_POWI  antlr.Token
	_POWF  antlr.Token
}

func NewEmptyPow_opContext() *Pow_opContext {
	var p = new(Pow_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_pow_op
	return p
}

func (*Pow_opContext) IsPow_opContext() {}

func NewPow_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pow_opContext {
	var p = new(Pow_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_pow_op

	return p
}

func (s *Pow_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Pow_opContext) Get_POWI() antlr.Token { return s._POWI }

func (s *Pow_opContext) Get_POWF() antlr.Token { return s._POWF }

func (s *Pow_opContext) Set_POWI(v antlr.Token) { s._POWI = v }

func (s *Pow_opContext) Set_POWF(v antlr.Token) { s._POWF = v }

func (s *Pow_opContext) GetOp() string { return s.op }

func (s *Pow_opContext) SetOp(v string) { s.op = v }

func (s *Pow_opContext) RINTEGER() antlr.TerminalNode {
	return s.GetToken(ProjectParserRINTEGER, 0)
}

func (s *Pow_opContext) HERITAGE() antlr.TerminalNode {
	return s.GetToken(ProjectParserHERITAGE, 0)
}

func (s *Pow_opContext) POWI() antlr.TerminalNode {
	return s.GetToken(ProjectParserPOWI, 0)
}

func (s *Pow_opContext) RREAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserRREAL, 0)
}

func (s *Pow_opContext) POWF() antlr.TerminalNode {
	return s.GetToken(ProjectParserPOWF, 0)
}

func (s *Pow_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pow_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pow_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterPow_op(s)
	}
}

func (s *Pow_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitPow_op(s)
	}
}

func (p *ProjectParser) Pow_op() (localctx IPow_opContext) {
	localctx = NewPow_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ProjectParserRULE_pow_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1103)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1095)
			p.Match(ProjectParserRINTEGER)
		}
		{
			p.SetState(1096)
			p.Match(ProjectParserHERITAGE)
		}
		{
			p.SetState(1097)

			var _m = p.Match(ProjectParserPOWI)

			localctx.(*Pow_opContext)._POWI = _m
		}
		localctx.(*Pow_opContext).op = (func() string {
			if localctx.(*Pow_opContext).Get_POWI() == nil {
				return ""
			} else {
				return localctx.(*Pow_opContext).Get_POWI().GetText()
			}
		}())

	case ProjectParserRREAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1099)
			p.Match(ProjectParserRREAL)
		}
		{
			p.SetState(1100)
			p.Match(ProjectParserHERITAGE)
		}
		{
			p.SetState(1101)

			var _m = p.Match(ProjectParserPOWF)

			localctx.(*Pow_opContext)._POWF = _m
		}
		localctx.(*Pow_opContext).op = (func() string {
			if localctx.(*Pow_opContext).Get_POWF() == nil {
				return ""
			} else {
				return localctx.(*Pow_opContext).Get_POWF().GetText()
			}
		}())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_logicContext is an interface to support dynamic dispatch.
type IExpr_logicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetOpLeft returns the opLeft rule contexts.
	GetOpLeft() IExpr_logicContext

	// GetOpU returns the opU rule contexts.
	GetOpU() IExpressionContext

	// Get_expr_rel returns the _expr_rel rule contexts.
	Get_expr_rel() IExpr_relContext

	// GetOpRight returns the opRight rule contexts.
	GetOpRight() IExpr_logicContext

	// SetOpLeft sets the opLeft rule contexts.
	SetOpLeft(IExpr_logicContext)

	// SetOpU sets the opU rule contexts.
	SetOpU(IExpressionContext)

	// Set_expr_rel sets the _expr_rel rule contexts.
	Set_expr_rel(IExpr_relContext)

	// SetOpRight sets the opRight rule contexts.
	SetOpRight(IExpr_logicContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsExpr_logicContext differentiates from other interfaces.
	IsExpr_logicContext()
}

type Expr_logicContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	p         Abstract.Expression
	instr     Abstract.Instruction
	opLeft    IExpr_logicContext
	opU       IExpressionContext
	_expr_rel IExpr_relContext
	op        antlr.Token
	opRight   IExpr_logicContext
}

func NewEmptyExpr_logicContext() *Expr_logicContext {
	var p = new(Expr_logicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_logic
	return p
}

func (*Expr_logicContext) IsExpr_logicContext() {}

func NewExpr_logicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_logicContext {
	var p = new(Expr_logicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_logic

	return p
}

func (s *Expr_logicContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_logicContext) GetOp() antlr.Token { return s.op }

func (s *Expr_logicContext) SetOp(v antlr.Token) { s.op = v }

func (s *Expr_logicContext) GetOpLeft() IExpr_logicContext { return s.opLeft }

func (s *Expr_logicContext) GetOpU() IExpressionContext { return s.opU }

func (s *Expr_logicContext) Get_expr_rel() IExpr_relContext { return s._expr_rel }

func (s *Expr_logicContext) GetOpRight() IExpr_logicContext { return s.opRight }

func (s *Expr_logicContext) SetOpLeft(v IExpr_logicContext) { s.opLeft = v }

func (s *Expr_logicContext) SetOpU(v IExpressionContext) { s.opU = v }

func (s *Expr_logicContext) Set_expr_rel(v IExpr_relContext) { s._expr_rel = v }

func (s *Expr_logicContext) SetOpRight(v IExpr_logicContext) { s.opRight = v }

func (s *Expr_logicContext) GetP() Abstract.Expression { return s.p }

func (s *Expr_logicContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Expr_logicContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Expr_logicContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Expr_logicContext) ADMIRATION() antlr.TerminalNode {
	return s.GetToken(ProjectParserADMIRATION, 0)
}

func (s *Expr_logicContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_logicContext) Expr_rel() IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_logicContext) AllExpr_logic() []IExpr_logicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_logicContext)(nil)).Elem())
	var tst = make([]IExpr_logicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_logicContext)
		}
	}

	return tst
}

func (s *Expr_logicContext) Expr_logic(i int) IExpr_logicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_logicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_logicContext)
}

func (s *Expr_logicContext) AND() antlr.TerminalNode {
	return s.GetToken(ProjectParserAND, 0)
}

func (s *Expr_logicContext) OR() antlr.TerminalNode {
	return s.GetToken(ProjectParserOR, 0)
}

func (s *Expr_logicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_logicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_logicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_logic(s)
	}
}

func (s *Expr_logicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_logic(s)
	}
}

func (p *ProjectParser) Expr_logic() (localctx IExpr_logicContext) {
	return p.expr_logic(0)
}

func (p *ProjectParser) expr_logic(_p int) (localctx IExpr_logicContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpr_logicContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpr_logicContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 136
	p.EnterRecursionRule(localctx, 136, ProjectParserRULE_expr_logic, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserADMIRATION:
		{
			p.SetState(1106)
			p.Match(ProjectParserADMIRATION)
		}
		{
			p.SetState(1107)

			var _x = p.Expression()

			localctx.(*Expr_logicContext).opU = _x
		}

		localctx.(*Expr_logicContext).p = Expression.NewOperation(localctx.(*Expr_logicContext).GetOpU().GetP(), "!", nil, true, localctx.(*Expr_logicContext).GetOpU().GetStart().GetLine(), localctx.(*Expr_logicContext).GetOpU().GetStart().GetColumn())
		localctx.(*Expr_logicContext).instr = Expression.NewOperation(localctx.(*Expr_logicContext).GetOpU().GetP(), "!", nil, true, localctx.(*Expr_logicContext).GetOpU().GetStart().GetLine(), localctx.(*Expr_logicContext).GetOpU().GetStart().GetColumn())

	case ProjectParserRINTEGER, ProjectParserRREAL, ProjectParserINTEGER, ProjectParserFLOAT, ProjectParserCHAR, ProjectParserSTRING, ProjectParserBOOLEAN, ProjectParserID, ProjectParserLEFT_PAR, ProjectParserSUB:
		{
			p.SetState(1110)

			var _x = p.expr_rel(0)

			localctx.(*Expr_logicContext)._expr_rel = _x
		}

		localctx.(*Expr_logicContext).p = localctx.(*Expr_logicContext).Get_expr_rel().GetP()
		localctx.(*Expr_logicContext).instr = localctx.(*Expr_logicContext).Get_expr_rel().GetInstr()

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpr_logicContext(p, _parentctx, _parentState)
			localctx.(*Expr_logicContext).opLeft = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ProjectParserRULE_expr_logic)
			p.SetState(1115)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1116)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*Expr_logicContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ProjectParserAND || _la == ProjectParserOR) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*Expr_logicContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1117)

				var _x = p.expr_logic(3)

				localctx.(*Expr_logicContext).opRight = _x
			}

			localctx.(*Expr_logicContext).p = Expression.NewOperation(localctx.(*Expr_logicContext).GetOpLeft().GetP(), (func() string {
				if localctx.(*Expr_logicContext).GetOp() == nil {
					return ""
				} else {
					return localctx.(*Expr_logicContext).GetOp().GetText()
				}
			}()), localctx.(*Expr_logicContext).GetOpRight().GetP(), false, (func() int {
				if localctx.(*Expr_logicContext).GetOp() == nil {
					return 0
				} else {
					return localctx.(*Expr_logicContext).GetOp().GetLine()
				}
			}()), localctx.(*Expr_logicContext).GetOp().GetColumn())
			localctx.(*Expr_logicContext).instr = Expression.NewOperation(localctx.(*Expr_logicContext).GetOpLeft().GetP(), (func() string {
				if localctx.(*Expr_logicContext).GetOp() == nil {
					return ""
				} else {
					return localctx.(*Expr_logicContext).GetOp().GetText()
				}
			}()), localctx.(*Expr_logicContext).GetOpRight().GetP(), false, (func() int {
				if localctx.(*Expr_logicContext).GetOp() == nil {
					return 0
				} else {
					return localctx.(*Expr_logicContext).GetOp().GetLine()
				}
			}()), localctx.(*Expr_logicContext).GetOp().GetColumn())

		}
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_castContext is an interface to support dynamic dispatch.
type IExpr_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RAS returns the _RAS token.
	Get_RAS() antlr.Token

	// Set_RAS sets the _RAS token.
	Set_RAS(antlr.Token)

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_data_type returns the _data_type rule contexts.
	Get_data_type() IData_typeContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_data_type sets the _data_type rule contexts.
	Set_data_type(IData_typeContext)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsExpr_castContext differentiates from other interfaces.
	IsExpr_castContext()
}

type Expr_castContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	p           Abstract.Expression
	instr       Abstract.Instruction
	_expression IExpressionContext
	_RAS        antlr.Token
	_data_type  IData_typeContext
}

func NewEmptyExpr_castContext() *Expr_castContext {
	var p = new(Expr_castContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_expr_cast
	return p
}

func (*Expr_castContext) IsExpr_castContext() {}

func NewExpr_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_castContext {
	var p = new(Expr_castContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_expr_cast

	return p
}

func (s *Expr_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_castContext) Get_RAS() antlr.Token { return s._RAS }

func (s *Expr_castContext) Set_RAS(v antlr.Token) { s._RAS = v }

func (s *Expr_castContext) Get_expression() IExpressionContext { return s._expression }

func (s *Expr_castContext) Get_data_type() IData_typeContext { return s._data_type }

func (s *Expr_castContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *Expr_castContext) Set_data_type(v IData_typeContext) { s._data_type = v }

func (s *Expr_castContext) GetP() Abstract.Expression { return s.p }

func (s *Expr_castContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *Expr_castContext) SetP(v Abstract.Expression) { s.p = v }

func (s *Expr_castContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *Expr_castContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *Expr_castContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expr_castContext) RAS() antlr.TerminalNode {
	return s.GetToken(ProjectParserRAS, 0)
}

func (s *Expr_castContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Expr_castContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *Expr_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_castContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterExpr_cast(s)
	}
}

func (s *Expr_castContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitExpr_cast(s)
	}
}

func (p *ProjectParser) Expr_cast() (localctx IExpr_castContext) {
	localctx = NewExpr_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ProjectParserRULE_expr_cast)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1125)
		p.Match(ProjectParserLEFT_PAR)
	}
	{
		p.SetState(1126)

		var _x = p.Expression()

		localctx.(*Expr_castContext)._expression = _x
	}
	{
		p.SetState(1127)

		var _m = p.Match(ProjectParserRAS)

		localctx.(*Expr_castContext)._RAS = _m
	}
	{
		p.SetState(1128)

		var _x = p.Data_type()

		localctx.(*Expr_castContext)._data_type = _x
	}
	{
		p.SetState(1129)
		p.Match(ProjectParserRIGHT_PAR)
	}

	if localctx.(*Expr_castContext).Get_data_type().GetData() == "i64" {
		localctx.(*Expr_castContext).p = Expression.NewCast(localctx.(*Expr_castContext).Get_expression().GetP(), SymbolTable.INTEGER, (func() int {
			if localctx.(*Expr_castContext).Get_RAS() == nil {
				return 0
			} else {
				return localctx.(*Expr_castContext).Get_RAS().GetLine()
			}
		}()), localctx.(*Expr_castContext).Get_RAS().GetColumn())
		localctx.(*Expr_castContext).instr = Expression.NewCast(localctx.(*Expr_castContext).Get_expression().GetP(), SymbolTable.INTEGER, (func() int {
			if localctx.(*Expr_castContext).Get_RAS() == nil {
				return 0
			} else {
				return localctx.(*Expr_castContext).Get_RAS().GetLine()
			}
		}()), localctx.(*Expr_castContext).Get_RAS().GetColumn())
	} else if localctx.(*Expr_castContext).Get_data_type().GetData() == "f64" {
		localctx.(*Expr_castContext).p = Expression.NewCast(localctx.(*Expr_castContext).Get_expression().GetP(), SymbolTable.FLOAT, (func() int {
			if localctx.(*Expr_castContext).Get_RAS() == nil {
				return 0
			} else {
				return localctx.(*Expr_castContext).Get_RAS().GetLine()
			}
		}()), localctx.(*Expr_castContext).Get_RAS().GetColumn())
		localctx.(*Expr_castContext).instr = Expression.NewCast(localctx.(*Expr_castContext).Get_expression().GetP(), SymbolTable.FLOAT, (func() int {
			if localctx.(*Expr_castContext).Get_RAS() == nil {
				return 0
			} else {
				return localctx.(*Expr_castContext).Get_RAS().GetLine()
			}
		}()), localctx.(*Expr_castContext).Get_RAS().GetColumn())
	}

	return localctx
}

// IData_typeContext is an interface to support dynamic dispatch.
type IData_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RINTEGER returns the _RINTEGER token.
	Get_RINTEGER() antlr.Token

	// Get_RREAL returns the _RREAL token.
	Get_RREAL() antlr.Token

	// Get_RSTR returns the _RSTR token.
	Get_RSTR() antlr.Token

	// Get_RSTRING returns the _RSTRING token.
	Get_RSTRING() antlr.Token

	// Get_RBOOLEAN returns the _RBOOLEAN token.
	Get_RBOOLEAN() antlr.Token

	// Get_RCHAR returns the _RCHAR token.
	Get_RCHAR() antlr.Token

	// Set_RINTEGER sets the _RINTEGER token.
	Set_RINTEGER(antlr.Token)

	// Set_RREAL sets the _RREAL token.
	Set_RREAL(antlr.Token)

	// Set_RSTR sets the _RSTR token.
	Set_RSTR(antlr.Token)

	// Set_RSTRING sets the _RSTRING token.
	Set_RSTRING(antlr.Token)

	// Set_RBOOLEAN sets the _RBOOLEAN token.
	Set_RBOOLEAN(antlr.Token)

	// Set_RCHAR sets the _RCHAR token.
	Set_RCHAR(antlr.Token)

	// GetData returns the data attribute.
	GetData() string

	// SetData sets the data attribute.
	SetData(string)

	// IsData_typeContext differentiates from other interfaces.
	IsData_typeContext()
}

type Data_typeContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	data      string
	_RINTEGER antlr.Token
	_RREAL    antlr.Token
	_RSTR     antlr.Token
	_RSTRING  antlr.Token
	_RBOOLEAN antlr.Token
	_RCHAR    antlr.Token
}

func NewEmptyData_typeContext() *Data_typeContext {
	var p = new(Data_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_data_type
	return p
}

func (*Data_typeContext) IsData_typeContext() {}

func NewData_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_typeContext {
	var p = new(Data_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_data_type

	return p
}

func (s *Data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_typeContext) Get_RINTEGER() antlr.Token { return s._RINTEGER }

func (s *Data_typeContext) Get_RREAL() antlr.Token { return s._RREAL }

func (s *Data_typeContext) Get_RSTR() antlr.Token { return s._RSTR }

func (s *Data_typeContext) Get_RSTRING() antlr.Token { return s._RSTRING }

func (s *Data_typeContext) Get_RBOOLEAN() antlr.Token { return s._RBOOLEAN }

func (s *Data_typeContext) Get_RCHAR() antlr.Token { return s._RCHAR }

func (s *Data_typeContext) Set_RINTEGER(v antlr.Token) { s._RINTEGER = v }

func (s *Data_typeContext) Set_RREAL(v antlr.Token) { s._RREAL = v }

func (s *Data_typeContext) Set_RSTR(v antlr.Token) { s._RSTR = v }

func (s *Data_typeContext) Set_RSTRING(v antlr.Token) { s._RSTRING = v }

func (s *Data_typeContext) Set_RBOOLEAN(v antlr.Token) { s._RBOOLEAN = v }

func (s *Data_typeContext) Set_RCHAR(v antlr.Token) { s._RCHAR = v }

func (s *Data_typeContext) GetData() string { return s.data }

func (s *Data_typeContext) SetData(v string) { s.data = v }

func (s *Data_typeContext) RINTEGER() antlr.TerminalNode {
	return s.GetToken(ProjectParserRINTEGER, 0)
}

func (s *Data_typeContext) RREAL() antlr.TerminalNode {
	return s.GetToken(ProjectParserRREAL, 0)
}

func (s *Data_typeContext) RSTR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRSTR, 0)
}

func (s *Data_typeContext) RSTRING() antlr.TerminalNode {
	return s.GetToken(ProjectParserRSTRING, 0)
}

func (s *Data_typeContext) RBOOLEAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserRBOOLEAN, 0)
}

func (s *Data_typeContext) RCHAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRCHAR, 0)
}

func (s *Data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterData_type(s)
	}
}

func (s *Data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitData_type(s)
	}
}

func (p *ProjectParser) Data_type() (localctx IData_typeContext) {
	localctx = NewData_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ProjectParserRULE_data_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1144)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserRINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1132)

			var _m = p.Match(ProjectParserRINTEGER)

			localctx.(*Data_typeContext)._RINTEGER = _m
		}
		localctx.(*Data_typeContext).data = (func() string {
			if localctx.(*Data_typeContext).Get_RINTEGER() == nil {
				return ""
			} else {
				return localctx.(*Data_typeContext).Get_RINTEGER().GetText()
			}
		}())

	case ProjectParserRREAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1134)

			var _m = p.Match(ProjectParserRREAL)

			localctx.(*Data_typeContext)._RREAL = _m
		}
		localctx.(*Data_typeContext).data = (func() string {
			if localctx.(*Data_typeContext).Get_RREAL() == nil {
				return ""
			} else {
				return localctx.(*Data_typeContext).Get_RREAL().GetText()
			}
		}())

	case ProjectParserRSTR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1136)

			var _m = p.Match(ProjectParserRSTR)

			localctx.(*Data_typeContext)._RSTR = _m
		}
		localctx.(*Data_typeContext).data = (func() string {
			if localctx.(*Data_typeContext).Get_RSTR() == nil {
				return ""
			} else {
				return localctx.(*Data_typeContext).Get_RSTR().GetText()
			}
		}())

	case ProjectParserRSTRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1138)

			var _m = p.Match(ProjectParserRSTRING)

			localctx.(*Data_typeContext)._RSTRING = _m
		}
		localctx.(*Data_typeContext).data = (func() string {
			if localctx.(*Data_typeContext).Get_RSTRING() == nil {
				return ""
			} else {
				return localctx.(*Data_typeContext).Get_RSTRING().GetText()
			}
		}())

	case ProjectParserRBOOLEAN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1140)

			var _m = p.Match(ProjectParserRBOOLEAN)

			localctx.(*Data_typeContext)._RBOOLEAN = _m
		}
		localctx.(*Data_typeContext).data = (func() string {
			if localctx.(*Data_typeContext).Get_RBOOLEAN() == nil {
				return ""
			} else {
				return localctx.(*Data_typeContext).Get_RBOOLEAN().GetText()
			}
		}())

	case ProjectParserRCHAR:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1142)

			var _m = p.Match(ProjectParserRCHAR)

			localctx.(*Data_typeContext)._RCHAR = _m
		}
		localctx.(*Data_typeContext).data = (func() string {
			if localctx.(*Data_typeContext).Get_RCHAR() == nil {
				return ""
			} else {
				return localctx.(*Data_typeContext).Get_RCHAR().GetText()
			}
		}())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimitiveContext is an interface to support dynamic dispatch.
type IPrimitiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_INTEGER returns the _INTEGER token.
	Get_INTEGER() antlr.Token

	// Get_FLOAT returns the _FLOAT token.
	Get_FLOAT() antlr.Token

	// Get_STRING returns the _STRING token.
	Get_STRING() antlr.Token

	// Get_TOSTRING returns the _TOSTRING token.
	Get_TOSTRING() antlr.Token

	// Get_TOOWNED returns the _TOOWNED token.
	Get_TOOWNED() antlr.Token

	// Get_CHAR returns the _CHAR token.
	Get_CHAR() antlr.Token

	// Get_BOOLEAN returns the _BOOLEAN token.
	Get_BOOLEAN() antlr.Token

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_INTEGER sets the _INTEGER token.
	Set_INTEGER(antlr.Token)

	// Set_FLOAT sets the _FLOAT token.
	Set_FLOAT(antlr.Token)

	// Set_STRING sets the _STRING token.
	Set_STRING(antlr.Token)

	// Set_TOSTRING sets the _TOSTRING token.
	Set_TOSTRING(antlr.Token)

	// Set_TOOWNED sets the _TOOWNED token.
	Set_TOOWNED(antlr.Token)

	// Set_CHAR sets the _CHAR token.
	Set_CHAR(antlr.Token)

	// Set_BOOLEAN sets the _BOOLEAN token.
	Set_BOOLEAN(antlr.Token)

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetP returns the p attribute.
	GetP() Abstract.Expression

	// GetInstr returns the instr attribute.
	GetInstr() Abstract.Instruction

	// SetP sets the p attribute.
	SetP(Abstract.Expression)

	// SetInstr sets the instr attribute.
	SetInstr(Abstract.Instruction)

	// IsPrimitiveContext differentiates from other interfaces.
	IsPrimitiveContext()
}

type PrimitiveContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	p         Abstract.Expression
	instr     Abstract.Instruction
	_INTEGER  antlr.Token
	_FLOAT    antlr.Token
	_STRING   antlr.Token
	_TOSTRING antlr.Token
	_TOOWNED  antlr.Token
	_CHAR     antlr.Token
	_BOOLEAN  antlr.Token
	_ID       antlr.Token
}

func NewEmptyPrimitiveContext() *PrimitiveContext {
	var p = new(PrimitiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ProjectParserRULE_primitive
	return p
}

func (*PrimitiveContext) IsPrimitiveContext() {}

func NewPrimitiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveContext {
	var p = new(PrimitiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ProjectParserRULE_primitive

	return p
}

func (s *PrimitiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveContext) Get_INTEGER() antlr.Token { return s._INTEGER }

func (s *PrimitiveContext) Get_FLOAT() antlr.Token { return s._FLOAT }

func (s *PrimitiveContext) Get_STRING() antlr.Token { return s._STRING }

func (s *PrimitiveContext) Get_TOSTRING() antlr.Token { return s._TOSTRING }

func (s *PrimitiveContext) Get_TOOWNED() antlr.Token { return s._TOOWNED }

func (s *PrimitiveContext) Get_CHAR() antlr.Token { return s._CHAR }

func (s *PrimitiveContext) Get_BOOLEAN() antlr.Token { return s._BOOLEAN }

func (s *PrimitiveContext) Get_ID() antlr.Token { return s._ID }

func (s *PrimitiveContext) Set_INTEGER(v antlr.Token) { s._INTEGER = v }

func (s *PrimitiveContext) Set_FLOAT(v antlr.Token) { s._FLOAT = v }

func (s *PrimitiveContext) Set_STRING(v antlr.Token) { s._STRING = v }

func (s *PrimitiveContext) Set_TOSTRING(v antlr.Token) { s._TOSTRING = v }

func (s *PrimitiveContext) Set_TOOWNED(v antlr.Token) { s._TOOWNED = v }

func (s *PrimitiveContext) Set_CHAR(v antlr.Token) { s._CHAR = v }

func (s *PrimitiveContext) Set_BOOLEAN(v antlr.Token) { s._BOOLEAN = v }

func (s *PrimitiveContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *PrimitiveContext) GetP() Abstract.Expression { return s.p }

func (s *PrimitiveContext) GetInstr() Abstract.Instruction { return s.instr }

func (s *PrimitiveContext) SetP(v Abstract.Expression) { s.p = v }

func (s *PrimitiveContext) SetInstr(v Abstract.Instruction) { s.instr = v }

func (s *PrimitiveContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ProjectParserINTEGER, 0)
}

func (s *PrimitiveContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ProjectParserFLOAT, 0)
}

func (s *PrimitiveContext) STRING() antlr.TerminalNode {
	return s.GetToken(ProjectParserSTRING, 0)
}

func (s *PrimitiveContext) LEFT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserLEFT_PAR, 0)
}

func (s *PrimitiveContext) RIGHT_PAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserRIGHT_PAR, 0)
}

func (s *PrimitiveContext) DOT() antlr.TerminalNode {
	return s.GetToken(ProjectParserDOT, 0)
}

func (s *PrimitiveContext) TOSTRING() antlr.TerminalNode {
	return s.GetToken(ProjectParserTOSTRING, 0)
}

func (s *PrimitiveContext) TOOWNED() antlr.TerminalNode {
	return s.GetToken(ProjectParserTOOWNED, 0)
}

func (s *PrimitiveContext) CHAR() antlr.TerminalNode {
	return s.GetToken(ProjectParserCHAR, 0)
}

func (s *PrimitiveContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(ProjectParserBOOLEAN, 0)
}

func (s *PrimitiveContext) ID() antlr.TerminalNode {
	return s.GetToken(ProjectParserID, 0)
}

func (s *PrimitiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.EnterPrimitive(s)
	}
}

func (s *PrimitiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ProjectParserListener); ok {
		listenerT.ExitPrimitive(s)
	}
}

func (p *ProjectParser) Primitive() (localctx IPrimitiveContext) {
	localctx = NewPrimitiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ProjectParserRULE_primitive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1168)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ProjectParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1146)

			var _m = p.Match(ProjectParserINTEGER)

			localctx.(*PrimitiveContext)._INTEGER = _m
		}

		num, err := strconv.Atoi((func() string {
			if localctx.(*PrimitiveContext).Get_INTEGER() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_INTEGER().GetText()
			}
		}()))
		if err != nil {
			fmt.Println(err)
		}
		localctx.(*PrimitiveContext).p = Expression.NewPrimitive(num, SymbolTable.INTEGER, (func() int {
			if localctx.(*PrimitiveContext).Get_INTEGER() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_INTEGER().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_INTEGER().GetColumn())
		localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(num, SymbolTable.INTEGER, (func() int {
			if localctx.(*PrimitiveContext).Get_INTEGER() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_INTEGER().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_INTEGER().GetColumn())

	case ProjectParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1148)

			var _m = p.Match(ProjectParserFLOAT)

			localctx.(*PrimitiveContext)._FLOAT = _m
		}

		num, err := strconv.ParseFloat((func() string {
			if localctx.(*PrimitiveContext).Get_FLOAT() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_FLOAT().GetText()
			}
		}()), 64)
		if err != nil {
			fmt.Println(err)
		}
		localctx.(*PrimitiveContext).p = Expression.NewPrimitive(num, SymbolTable.FLOAT, (func() int {
			if localctx.(*PrimitiveContext).Get_FLOAT() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_FLOAT().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_FLOAT().GetColumn())
		localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(num, SymbolTable.FLOAT, (func() int {
			if localctx.(*PrimitiveContext).Get_FLOAT() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_FLOAT().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_FLOAT().GetColumn())

	case ProjectParserSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1150)

			var _m = p.Match(ProjectParserSTRING)

			localctx.(*PrimitiveContext)._STRING = _m
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			p.SetState(1155)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1151)
					p.Match(ProjectParserDOT)
				}
				{
					p.SetState(1152)

					var _m = p.Match(ProjectParserTOSTRING)

					localctx.(*PrimitiveContext)._TOSTRING = _m
				}

			case 2:
				{
					p.SetState(1153)
					p.Match(ProjectParserDOT)
				}
				{
					p.SetState(1154)

					var _m = p.Match(ProjectParserTOOWNED)

					localctx.(*PrimitiveContext)._TOOWNED = _m
				}

			}
			{
				p.SetState(1157)
				p.Match(ProjectParserLEFT_PAR)
			}
			{
				p.SetState(1158)
				p.Match(ProjectParserRIGHT_PAR)
			}

		}

		str := (func() string {
			if localctx.(*PrimitiveContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_STRING().GetText()
			}
		}())[1 : len((func() string {
			if localctx.(*PrimitiveContext).Get_STRING() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_STRING().GetText()
			}
		}()))-1]
		if (func() string {
			if localctx.(*PrimitiveContext).Get_TOSTRING() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_TOSTRING().GetText()
			}
		}()) != "" || (func() string {
			if localctx.(*PrimitiveContext).Get_TOOWNED() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_TOOWNED().GetText()
			}
		}()) != "" {
			localctx.(*PrimitiveContext).p = Expression.NewPrimitive(str, SymbolTable.STRING, (func() int {
				if localctx.(*PrimitiveContext).Get_STRING() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_STRING().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_STRING().GetColumn())
			localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(str, SymbolTable.STRING, (func() int {
				if localctx.(*PrimitiveContext).Get_STRING() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_STRING().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_STRING().GetColumn())
		} else {
			localctx.(*PrimitiveContext).p = Expression.NewPrimitive(str, SymbolTable.STR, (func() int {
				if localctx.(*PrimitiveContext).Get_STRING() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_STRING().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_STRING().GetColumn())
			localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(str, SymbolTable.STR, (func() int {
				if localctx.(*PrimitiveContext).Get_STRING() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_STRING().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_STRING().GetColumn())
		}

	case ProjectParserCHAR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1162)

			var _m = p.Match(ProjectParserCHAR)

			localctx.(*PrimitiveContext)._CHAR = _m
		}

		chr := (func() string {
			if localctx.(*PrimitiveContext).Get_CHAR() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_CHAR().GetText()
			}
		}())[1 : len((func() string {
			if localctx.(*PrimitiveContext).Get_CHAR() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_CHAR().GetText()
			}
		}()))-1]
		localctx.(*PrimitiveContext).p = Expression.NewPrimitive(chr, SymbolTable.CHAR, (func() int {
			if localctx.(*PrimitiveContext).Get_CHAR() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_CHAR().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_CHAR().GetColumn())
		localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(chr, SymbolTable.CHAR, (func() int {
			if localctx.(*PrimitiveContext).Get_CHAR() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_CHAR().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_CHAR().GetColumn())

	case ProjectParserBOOLEAN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1164)

			var _m = p.Match(ProjectParserBOOLEAN)

			localctx.(*PrimitiveContext)._BOOLEAN = _m
		}

		str := (func() string {
			if localctx.(*PrimitiveContext).Get_BOOLEAN() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_BOOLEAN().GetText()
			}
		}())
		fmt.Println(str)
		if str == "true" {
			localctx.(*PrimitiveContext).p = Expression.NewPrimitive(true, SymbolTable.BOOLEAN, (func() int {
				if localctx.(*PrimitiveContext).Get_BOOLEAN() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_BOOLEAN().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_BOOLEAN().GetColumn())
			localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(true, SymbolTable.BOOLEAN, (func() int {
				if localctx.(*PrimitiveContext).Get_BOOLEAN() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_BOOLEAN().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_BOOLEAN().GetColumn())
		} else {
			localctx.(*PrimitiveContext).p = Expression.NewPrimitive(false, SymbolTable.BOOLEAN, (func() int {
				if localctx.(*PrimitiveContext).Get_BOOLEAN() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_BOOLEAN().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_BOOLEAN().GetColumn())
			localctx.(*PrimitiveContext).instr = Expression.NewPrimitive(false, SymbolTable.BOOLEAN, (func() int {
				if localctx.(*PrimitiveContext).Get_BOOLEAN() == nil {
					return 0
				} else {
					return localctx.(*PrimitiveContext).Get_BOOLEAN().GetLine()
				}
			}()), localctx.(*PrimitiveContext).Get_BOOLEAN().GetColumn())
		}

	case ProjectParserID:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1166)

			var _m = p.Match(ProjectParserID)

			localctx.(*PrimitiveContext)._ID = _m
		}

		localctx.(*PrimitiveContext).p = Expression.NewIdentifier((func() string {
			if localctx.(*PrimitiveContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_ID().GetText()
			}
		}()), (func() int {
			if localctx.(*PrimitiveContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_ID().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_ID().GetColumn())
		localctx.(*PrimitiveContext).instr = Expression.NewIdentifier((func() string {
			if localctx.(*PrimitiveContext).Get_ID() == nil {
				return ""
			} else {
				return localctx.(*PrimitiveContext).Get_ID().GetText()
			}
		}()), (func() int {
			if localctx.(*PrimitiveContext).Get_ID() == nil {
				return 0
			} else {
				return localctx.(*PrimitiveContext).Get_ID().GetLine()
			}
		}()), localctx.(*PrimitiveContext).Get_ID().GetColumn())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *ProjectParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 2:
		var t *ListFuncsContext = nil
		if localctx != nil {
			t = localctx.(*ListFuncsContext)
		}
		return p.ListFuncs_Sempred(t, predIndex)

	case 3:
		var t *ListArraysContext = nil
		if localctx != nil {
			t = localctx.(*ListArraysContext)
		}
		return p.ListArrays_Sempred(t, predIndex)

	case 4:
		var t *ListStructsContext = nil
		if localctx != nil {
			t = localctx.(*ListStructsContext)
		}
		return p.ListStructs_Sempred(t, predIndex)

	case 5:
		var t *ModulesContext = nil
		if localctx != nil {
			t = localctx.(*ModulesContext)
		}
		return p.Modules_Sempred(t, predIndex)

	case 11:
		var t *ListParamsContext = nil
		if localctx != nil {
			t = localctx.(*ListParamsContext)
		}
		return p.ListParams_Sempred(t, predIndex)

	case 15:
		var t *ListVarsContext = nil
		if localctx != nil {
			t = localctx.(*ListVarsContext)
		}
		return p.ListVars_Sempred(t, predIndex)

	case 19:
		var t *ListIdsContext = nil
		if localctx != nil {
			t = localctx.(*ListIdsContext)
		}
		return p.ListIds_Sempred(t, predIndex)

	case 25:
		var t *List_instr_matchContext = nil
		if localctx != nil {
			t = localctx.(*List_instr_matchContext)
		}
		return p.List_instr_match_Sempred(t, predIndex)

	case 27:
		var t *Expr_matchContext = nil
		if localctx != nil {
			t = localctx.(*Expr_matchContext)
		}
		return p.Expr_match_Sempred(t, predIndex)

	case 34:
		var t *ListExpressionsContext = nil
		if localctx != nil {
			t = localctx.(*ListExpressionsContext)
		}
		return p.ListExpressions_Sempred(t, predIndex)

	case 47:
		var t *Content_structContext = nil
		if localctx != nil {
			t = localctx.(*Content_structContext)
		}
		return p.Content_struct_Sempred(t, predIndex)

	case 53:
		var t *ListInArrayContext = nil
		if localctx != nil {
			t = localctx.(*ListInArrayContext)
		}
		return p.ListInArray_Sempred(t, predIndex)

	case 56:
		var t *ListInVectorContext = nil
		if localctx != nil {
			t = localctx.(*ListInVectorContext)
		}
		return p.ListInVector_Sempred(t, predIndex)

	case 59:
		var t *Def_itemsContext = nil
		if localctx != nil {
			t = localctx.(*Def_itemsContext)
		}
		return p.Def_items_Sempred(t, predIndex)

	case 62:
		var t *ListAccessContext = nil
		if localctx != nil {
			t = localctx.(*ListAccessContext)
		}
		return p.ListAccess_Sempred(t, predIndex)

	case 64:
		var t *Expr_relContext = nil
		if localctx != nil {
			t = localctx.(*Expr_relContext)
		}
		return p.Expr_rel_Sempred(t, predIndex)

	case 65:
		var t *Expr_aritContext = nil
		if localctx != nil {
			t = localctx.(*Expr_aritContext)
		}
		return p.Expr_arit_Sempred(t, predIndex)

	case 68:
		var t *Expr_logicContext = nil
		if localctx != nil {
			t = localctx.(*Expr_logicContext)
		}
		return p.Expr_logic_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ProjectParser) ListFuncs_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListArrays_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListStructs_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Modules_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListParams_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListVars_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListIds_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) List_instr_match_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Expr_match_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListExpressions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Content_struct_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListInArray_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListInVector_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Def_items_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) ListAccess_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Expr_rel_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Expr_arit_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ProjectParser) Expr_logic_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
